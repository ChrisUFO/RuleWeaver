[
  {
    "url": "https://api.github.com/repos/ChrisUFO/RuleWeaver/pulls/comments/2838816586",
    "pull_request_review_id": 3838836979,
    "id": 2838816586,
    "node_id": "PRRC_kwDORVf-8M6pNOdK",
    "diff_hunk": "@@ -758,144 +778,209 @@ async fn handle_skill_call(\n     args_map: serde_json::Map<String, serde_json::Value>,\n     shared_db: &Option<Arc<Database>>,\n ) -> serde_json::Value {\n-    let input = args_map\n-        .get(\"input\")\n-        .and_then(|v| v.as_str())\n-        .unwrap_or_default()\n-        .to_string();\n+    let mut skill_envs: Vec<(String, String)> = Vec::new();\n+    let mut invalid_arg_message: Option<String> = None;\n+    let mut missing_required: Vec<String> = Vec::new();\n \n-    // Security: DO NOT use string replacement for {{input}} as it leads to command injection.\n-    // Instead, we pass the input via environment variables.\n-    #[cfg(target_os = \"windows\")]\n-    let rendered = skill.instructions.replace(\"{{input}}\", \"%RW_SKILL_INPUT%\");\n-    #[cfg(not(target_os = \"windows\"))]\n-    let rendered = skill.instructions.replace(\"{{input}}\", \"$RW_SKILL_INPUT\");\n+    for param in &skill.input_schema {\n+        let raw_value = args_map\n+            .get(&param.name)\n+            .map(|v| {\n+                if let Some(s) = v.as_str() {\n+                    s.to_string()\n+                } else {\n+                    v.to_string()\n+                }\n+            })\n+            .or_else(|| param.default_value.clone())\n+            .unwrap_or_default();\n \n-    let steps = extract_skill_steps(&rendered);\n+        if raw_value.is_empty() && param.required {\n+            missing_required.push(param.name.clone());\n+            continue;\n+        }\n \n-    if steps.is_empty() {\n-        // If no shell steps, just return the instructions (with input placeholder)\n-        // Note: If we really want to return the text with the input replaced,\n-        // we should do it safely here ONLY for the returned text, not for execution.\n-        let display_text = skill.instructions.replace(\"{{input}}\", &input);\n-        json!({\n-            \"jsonrpc\": \"2.0\",\n-            \"id\": id,\n-            \"result\": {\n-                \"content\": [{\n-                    \"type\": \"text\",\n-                    \"text\": display_text\n-                }],\n-                \"isError\": false\n-            }\n-        })\n-    } else {\n-        let mut output = String::new();\n-        let mut is_error = false;\n+        if raw_value.is_empty() {\n+            continue;\n+        }\n \n-        let start = Instant::now();\n-        let skill_envs = vec![(\"RW_SKILL_INPUT\".to_string(), input.clone())];\n+        match sanitize_argument_value(&raw_value) {\n+            Ok(safe_value) => {\n+                if matches!(param.param_type, SkillParameterType::Enum) {\n+                    if let Some(ref options) = param.enum_values {\n+                        if !options.contains(&raw_value) {\n+                            invalid_arg_message = Some(format!(\n+                                \"Parameter '{}' must be one of: {}\",\n+                                param.name,\n+                                options.join(\", \")\n+                            ));\n+                            break;\n+                        }\n+                    }\n+                }\n \n-        for (idx, step) in steps.iter().take(MAX_SKILL_STEPS).enumerate() {\n-            if step.len() > MAX_STEP_LENGTH {\n-                is_error = true;\n-                output.push_str(&format!(\"Step {} rejected: too long\\n\", idx + 1));\n+                let env_name = format!(\n+                    \"SKILL_PARAM_{}\",\n+                    param.name.replace('-', \"_\").to_uppercase()\n+                );\n+                skill_envs.push((env_name, safe_value));\n+            }\n+            Err(e) => {\n+                invalid_arg_message = Some(e.to_string());\n                 break;\n             }\n+        }\n+    }\n \n-            if let Some(pattern) = contains_disallowed_pattern(step) {\n-                is_error = true;\n-                output.push_str(&format!(\n-                    \"Step {} rejected due to unsafe pattern: {}\\n\",\n-                    idx + 1,\n-                    pattern\n-                ));\n-                break;\n+    if !missing_required.is_empty() {\n+        return json!({\n+            \"jsonrpc\": \"2.0\",\n+            \"id\": id,\n+            \"error\": {\n+                \"code\": -32602,\n+                \"message\": format!(\"Missing required parameters: {}\", missing_required.join(\", \"))\n             }\n+        });\n+    }\n \n-            match execute_shell_with_timeout_env(step, SKILL_EXEC_TIMEOUT, &skill_envs).await {\n-                Ok((exit_code, stdout, stderr)) => {\n-                    let step_stdout = truncate_output_custom(stdout, 1024 * 1024); // 1MB per step\n-                    let step_stderr = truncate_output_custom(stderr, 1024 * 1024); // 1MB per step\n-\n-                    output.push_str(&format!(\n-                        \"[step {}] exit_code: {}\\nstdout:\\n{}\\nstderr:\\n{}\\n\\n\",\n-                        idx + 1,\n-                        exit_code,\n-                        step_stdout,\n-                        step_stderr\n-                    ));\n-                    if exit_code != 0 {\n-                        is_error = true;\n-                        break;\n-                    }\n-                }\n-                Err(e) => {\n-                    is_error = true;\n-                    output.push_str(&format!(\"[step {}] execution error: {}\\n\", idx + 1, e));\n-                    break;\n-                }\n+    if let Some(message) = invalid_arg_message {\n+        return json!({\n+            \"jsonrpc\": \"2.0\",\n+            \"id\": id,\n+            \"error\": {\n+                \"code\": -32602,\n+                \"message\": format!(\"Invalid parameter value: {}\", message)\n             }\n-        }\n+        });\n+    }\n \n-        let duration_ms = start.elapsed().as_millis() as u64;\n-        let _ = manager\n-            .log(format!(\n-                \"MCP tools/call '{}' skill execution {} ({}ms)\",\n-                skill.name,\n-                if is_error { \"failed\" } else { \"succeeded\" },\n-                duration_ms\n-            ))\n-            .await;\n-\n-        if let Some(db) = shared_db {\n-            let args_json = match serde_json::to_string(&args_map) {\n-                Ok(s) => s,\n-                Err(e) => {\n-                    let _ = manager\n-                        .log(format!(\"Skill execution serialization error: {}\", e))\n-                        .await;\n-                    String::new()\n-                }\n-            };\n-            let skill_name = format!(\"skill:{}\", skill.name);\n-            let _ = db.add_execution_log(&ExecutionLogInput {\n-                command_id: &skill.id,\n-                command_name: &skill_name,\n-                arguments_json: &args_json,\n-                stdout: &output,\n-                stderr: \"\",\n-                exit_code: if is_error { 1 } else { 0 },\n-                duration_ms,\n-                triggered_by: \"mcp-skill\",\n-            });\n+    skill_envs.push((\"RULEWEAVER_SKILL_ID\".to_string(), skill.id.clone()));\n+    skill_envs.push((\"RULEWEAVER_SKILL_NAME\".to_string(), skill.name.clone()));\n+    skill_envs.push((\n+        \"RULEWEAVER_SKILL_DIR\".to_string(),\n+        skill.directory_path.clone(),\n+    ));\n+\n+    // Inject all settings as SKILL_SECRET_*\n+    if let Some(db) = shared_db {\n+        if let Ok(settings) = db.get_all_settings() {\n+            for (k, v) in settings {\n+                let env_name = format!(\"SKILL_SECRET_{}\", k.replace('-', \"_\").to_uppercase());\n+                skill_envs.push((env_name, v));\n+            }\n         }\n+    }",
    "path": "src-tauri/src/mcp/mod.rs",
    "commit_id": "1f31e790049c2d7f764ddae60f0cb2de1b9c9062",
    "original_commit_id": "1f31e790049c2d7f764ddae60f0cb2de1b9c9062",
    "user": {
      "login": "gemini-code-assist[bot]",
      "id": 176961590,
      "node_id": "BOT_kgDOCow4Ng",
      "avatar_url": "https://avatars.githubusercontent.com/in/956858?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gemini-code-assist%5Bbot%5D",
      "html_url": "https://github.com/apps/gemini-code-assist",
      "followers_url": "https://api.github.com/users/gemini-code-assist%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/gemini-code-assist%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/gemini-code-assist%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gemini-code-assist%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gemini-code-assist%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/gemini-code-assist%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/gemini-code-assist%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/gemini-code-assist%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gemini-code-assist%5Bbot%5D/received_events",
      "type": "Bot",
      "user_view_type": "public",
      "site_admin": false
    },
    "body": "![security-high](https://www.gstatic.com/codereviewagent/security-high-priority.svg) ![high](https://www.gstatic.com/codereviewagent/high-priority.svg)\n\nInjecting all global settings into the environment of every skill execution poses a significant security risk. If any sensitive information (like API keys, personal tokens, or system paths) is stored in the settings table, it becomes accessible to any skill script, including those that might be imported from untrusted sources. It is recommended to implement a more granular approach, such as a dedicated secrets management system or allowing users to explicitly map specific settings to specific skills.",
    "created_at": "2026-02-23T02:14:00Z",
    "updated_at": "2026-02-23T02:14:00Z",
    "html_url": "https://github.com/ChrisUFO/RuleWeaver/pull/20#discussion_r2838816586",
    "pull_request_url": "https://api.github.com/repos/ChrisUFO/RuleWeaver/pulls/20",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/ChrisUFO/RuleWeaver/pulls/comments/2838816586"
      },
      "html": { "href": "https://github.com/ChrisUFO/RuleWeaver/pull/20#discussion_r2838816586" },
      "pull_request": { "href": "https://api.github.com/repos/ChrisUFO/RuleWeaver/pulls/20" }
    },
    "reactions": {
      "url": "https://api.github.com/repos/ChrisUFO/RuleWeaver/pulls/comments/2838816586/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": 865,
    "original_start_line": 865,
    "start_side": "RIGHT",
    "line": 872,
    "original_line": 872,
    "side": "RIGHT",
    "author_association": "NONE",
    "original_position": 285,
    "position": 285,
    "subject_type": "line"
  },
  {
    "url": "https://api.github.com/repos/ChrisUFO/RuleWeaver/pulls/comments/2838816589",
    "pull_request_review_id": 3838836979,
    "id": 2838816589,
    "node_id": "PRRC_kwDORVf-8M6pNOdN",
    "diff_hunk": "@@ -2,29 +2,63 @@ use std::sync::Arc;\n use tauri::State;\n \n use crate::database::Database;\n-use crate::error::Result;\n+use crate::error::{AppError, Result};\n+use crate::file_storage::skills::{\n+    delete_skill_from_disk, load_skills_from_disk, save_skill_to_disk,\n+};\n use crate::models::{CreateSkillInput, Skill, UpdateSkillInput};\n+use crate::templates::skills::{get_bundled_skill_templates, TemplateSkill};\n \n-use super::validate_skill_input;\n+use super::{validate_skill_entry_point, validate_skill_input, validate_skill_schema};\n \n #[tauri::command]\n pub fn get_all_skills(db: State<'_, Arc<Database>>) -> Result<Vec<Skill>> {\n-    db.get_all_skills()\n+    // For now, load from disk directly to act as source of truth, but we could also return DB\n+    if let Ok(skills) = load_skills_from_disk() {\n+        Ok(skills)\n+    } else {\n+        db.get_all_skills()\n+    }",
    "path": "src-tauri/src/commands/skill_commands.rs",
    "commit_id": "1f31e790049c2d7f764ddae60f0cb2de1b9c9062",
    "original_commit_id": "1f31e790049c2d7f764ddae60f0cb2de1b9c9062",
    "user": {
      "login": "gemini-code-assist[bot]",
      "id": 176961590,
      "node_id": "BOT_kgDOCow4Ng",
      "avatar_url": "https://avatars.githubusercontent.com/in/956858?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gemini-code-assist%5Bbot%5D",
      "html_url": "https://github.com/apps/gemini-code-assist",
      "followers_url": "https://api.github.com/users/gemini-code-assist%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/gemini-code-assist%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/gemini-code-assist%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gemini-code-assist%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gemini-code-assist%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/gemini-code-assist%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/gemini-code-assist%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/gemini-code-assist%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gemini-code-assist%5Bbot%5D/received_events",
      "type": "Bot",
      "user_view_type": "public",
      "site_admin": false
    },
    "body": "![medium](https://www.gstatic.com/codereviewagent/medium-priority.svg)\n\nThe fallback logic in `get_all_skills` is inconsistent with `get_skill_by_id`. If `load_skills_from_disk()` succeeds but returns an empty list (e.g., if the directory exists but contains no valid skills), the function returns an empty vector and never queries the database. This means skills that exist in the database but are missing from the disk will not be listed, even though `get_skill_by_id` would still be able to retrieve them. Consider falling back to the database if the disk list is empty.\n\n```rust\n    let skills = load_skills_from_disk().unwrap_or_default();\n    if skills.is_empty() {\n        db.get_all_skills()\n    } else {\n        Ok(skills)\n    }\n```",
    "created_at": "2026-02-23T02:14:00Z",
    "updated_at": "2026-02-23T02:14:00Z",
    "html_url": "https://github.com/ChrisUFO/RuleWeaver/pull/20#discussion_r2838816589",
    "pull_request_url": "https://api.github.com/repos/ChrisUFO/RuleWeaver/pulls/20",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/ChrisUFO/RuleWeaver/pulls/comments/2838816589"
      },
      "html": { "href": "https://github.com/ChrisUFO/RuleWeaver/pull/20#discussion_r2838816589" },
      "pull_request": { "href": "https://api.github.com/repos/ChrisUFO/RuleWeaver/pulls/20" }
    },
    "reactions": {
      "url": "https://api.github.com/repos/ChrisUFO/RuleWeaver/pulls/comments/2838816589/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": 17,
    "original_start_line": 17,
    "start_side": "RIGHT",
    "line": 21,
    "original_line": 21,
    "side": "RIGHT",
    "author_association": "NONE",
    "original_position": 23,
    "position": 23,
    "subject_type": "line"
  },
  {
    "url": "https://api.github.com/repos/ChrisUFO/RuleWeaver/pulls/comments/2838816590",
    "pull_request_review_id": 3838836979,
    "id": 2838816590,
    "node_id": "PRRC_kwDORVf-8M6pNOdO",
    "diff_hunk": "@@ -37,10 +71,85 @@ pub fn update_skill(id: String, input: UpdateSkillInput, db: State<'_, Arc<Datab\n         validate_skill_input(&existing.name, instructions)?;\n     }\n \n-    db.update_skill(&id, input)\n+    if let Some(ref schema) = input.input_schema {\n+        validate_skill_schema(schema)?;\n+    }\n+\n+    if let Some(ref ep) = input.entry_point {\n+        validate_skill_entry_point(ep)?;\n+    }\n+\n+    let updated = db.update_skill(&id, input)?;\n+    let _ = save_skill_to_disk(&updated);\n+    Ok(updated)\n }\n \n #[tauri::command]\n pub fn delete_skill(id: String, db: State<'_, Arc<Database>>) -> Result<()> {\n+    if let Ok(existing) = db.get_skill_by_id(&id) {\n+        let _ = delete_skill_from_disk(&existing);\n+    }\n     db.delete_skill(&id)\n }\n+\n+#[tauri::command]\n+pub fn get_skill_templates() -> Result<Vec<TemplateSkill>> {\n+    Ok(get_bundled_skill_templates())\n+}\n+\n+#[tauri::command]\n+pub fn install_skill_template(template_id: String, db: State<'_, Arc<Database>>) -> Result<Skill> {\n+    // 1. Check idempotency: is it already installed?\n+    if let Ok(existing) = db.get_skill_by_id(&template_id) {\n+        return Ok(existing);\n+    }\n+\n+    // 2. Find template\n+    let templates = get_bundled_skill_templates();\n+    let template = templates\n+        .into_iter()\n+        .find(|t| t.template_id == template_id)\n+        .ok_or_else(|| AppError::Validation(format!(\"Template '{}' not found\", template_id)))?;\n+\n+    // 3. Ensure the metadata uses our specific template ID\n+    let mut metadata = template.metadata.clone();\n+    metadata.id = Some(template_id.clone());\n+\n+    // 4. Create in DB first so it generates default timestamps etc (using our prescribed ID)\n+    let created = db.create_skill(metadata)?;\n+\n+    // 5. Save the SKILL.md and skill.json to disk (generates directory for us)\n+    match save_skill_to_disk(&created) {\n+        Ok(path) => {\n+            // Write the custom template files\n+            for file in template.files {\n+                let file_path = path.join(&file.filename);\n+                if let Err(e) = std::fs::write(&file_path, &file.content) {\n+                    // Rollback DB entry if file write fails\n+                    let _ = db.delete_skill(&created.id);\n+                    return Err(AppError::Io(e));\n+                }\n+            }\n+\n+            // 6. Update the DB with the absolute directory path that save_skill_to_disk determined\n+            let update = UpdateSkillInput {\n+                directory_path: Some(path.to_string_lossy().to_string()),\n+                ..Default::default()\n+            };\n+            if let Err(e) = db.update_skill(&created.id, update) {\n+                // Rollback DB entry and disk if update fails\n+                let _ = delete_skill_from_disk(&created);\n+                let _ = db.delete_skill(&created.id);\n+                return Err(e);\n+            }",
    "path": "src-tauri/src/commands/skill_commands.rs",
    "commit_id": "1f31e790049c2d7f764ddae60f0cb2de1b9c9062",
    "original_commit_id": "1f31e790049c2d7f764ddae60f0cb2de1b9c9062",
    "user": {
      "login": "gemini-code-assist[bot]",
      "id": 176961590,
      "node_id": "BOT_kgDOCow4Ng",
      "avatar_url": "https://avatars.githubusercontent.com/in/956858?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gemini-code-assist%5Bbot%5D",
      "html_url": "https://github.com/apps/gemini-code-assist",
      "followers_url": "https://api.github.com/users/gemini-code-assist%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/gemini-code-assist%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/gemini-code-assist%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gemini-code-assist%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gemini-code-assist%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/gemini-code-assist%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/gemini-code-assist%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/gemini-code-assist%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gemini-code-assist%5Bbot%5D/received_events",
      "type": "Bot",
      "user_view_type": "public",
      "site_admin": false
    },
    "body": "![medium](https://www.gstatic.com/codereviewagent/medium-priority.svg)\n\nThe rollback logic here is ineffective. `delete_skill_from_disk(&created)` relies on `created.directory_path`, which is empty at this point because it was initialized from metadata before the directory was actually created and saved. Consequently, if `db.update_skill` fails, the files written to disk will not be cleaned up. You should use the `path` variable returned by `save_skill_to_disk` to perform the cleanup.\n\n```rust\n            if let Err(e) = db.update_skill(&created.id, update) {\n                // Rollback DB entry and disk if update fails\n                let _ = std::fs::remove_dir_all(&path);\n                let _ = db.delete_skill(&created.id);\n                return Err(e);\n            }\n```",
    "created_at": "2026-02-23T02:14:00Z",
    "updated_at": "2026-02-23T02:14:00Z",
    "html_url": "https://github.com/ChrisUFO/RuleWeaver/pull/20#discussion_r2838816590",
    "pull_request_url": "https://api.github.com/repos/ChrisUFO/RuleWeaver/pulls/20",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/ChrisUFO/RuleWeaver/pulls/comments/2838816590"
      },
      "html": { "href": "https://github.com/ChrisUFO/RuleWeaver/pull/20#discussion_r2838816590" },
      "pull_request": { "href": "https://api.github.com/repos/ChrisUFO/RuleWeaver/pulls/20" }
    },
    "reactions": {
      "url": "https://api.github.com/repos/ChrisUFO/RuleWeaver/pulls/comments/2838816590/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": 139,
    "original_start_line": 139,
    "start_side": "RIGHT",
    "line": 144,
    "original_line": 144,
    "side": "RIGHT",
    "author_association": "NONE",
    "original_position": 144,
    "position": 144,
    "subject_type": "line"
  }
]
