use std::collections::{HashMap, HashSet};
use std::fs;
use std::path::{Path, PathBuf};

use sha2::{Digest, Sha256};

use crate::constants::{
    ANTIGRAVITY_FILENAME, GEMINI_FILENAME, LEGACY_ANTIGRAVITY_DIR, LEGACY_OPENCODE_DIR,
    NEW_GEMINI_DIR, NEW_OPENCODE_DIR, OPENCODE_FILENAME,
};
use crate::database::Database;
use crate::error::Result;
use crate::models::registry::{ArtifactType, REGISTRY};
use crate::models::{AdapterType, Conflict, DiffSummary, Rule, Scope, SyncError, SyncResult};
use crate::path_resolver::path_resolver;

fn registry_entry(adapter: &AdapterType) -> &'static crate::models::registry::ToolEntry {
    REGISTRY.get(adapter).unwrap_or_else(|| {
        panic!(
            "ToolRegistry missing entry for adapter '{}'. All AdapterType variants must be registered.",
            adapter.as_str()
        )
    })
}

/// Resolve a registry path string (e.g., "~/path" or "~") to an absolute PathBuf.
///
/// This is a convenience wrapper for backward compatibility.
fn resolve_registry_path(path: &str) -> Result<PathBuf> {
    crate::path_resolver::resolve_registry_path(path)
}

/// Validate a target path string.
///
/// This is a convenience wrapper for backward compatibility.
fn validate_target_path(base_path: &str) -> Result<PathBuf> {
    crate::path_resolver::validate_target_path(base_path)
}

pub trait SyncAdapter: Send + Sync {
    fn id(&self) -> AdapterType;
    fn name(&self) -> &str;
    fn file_name(&self) -> &str;
    fn description(&self) -> &str;
    fn global_path(&self) -> Result<PathBuf>;

    fn format_content(&self, rules: &[Rule], enabled_rules_only: bool) -> String;
    fn format_rule(&self, rule: &Rule) -> String;
}

pub fn format_markdown_sync_helper(
    rules: &[Rule],
    header_level: usize,
    use_html_meta: bool,
    use_rule_prefix: bool,
) -> String {
    let timestamp = rules
        .iter()
        .filter(|r| r.enabled)
        .map(|r| r.updated_at)
        .max()
        .map(|ts| ts.format("%Y-%m-%dT%H:%M:%SZ").to_string())
        .unwrap_or_else(|| chrono::Utc::now().format("%Y-%m-%dT%H:%M:%SZ").to_string());
    let rule_names: Vec<&str> = rules
        .iter()
        .filter(|r| r.enabled)
        .map(|r| r.name.as_str())
        .collect();

    let (meta_start, meta_end) = if use_html_meta {
        ("<!-- ", " -->")
    } else {
        ("# ", "")
    };

    let mut content = format!(
        "{}Generated by RuleWeaver - Do not edit manually{}\n\
         {}Last synced: {}{}\n\
         {}Rules: {}{}\n\n",
        meta_start,
        meta_end,
        meta_start,
        timestamp,
        meta_end,
        meta_start,
        rule_names.join(", "),
        meta_end
    );

    let prefix = "#".repeat(header_level);
    let rule_header_prefix = if use_rule_prefix { "Rule: " } else { "" };

    for rule in rules.iter().filter(|r| r.enabled) {
        content.push_str(&format!(
            "{} {}{}\n{}",
            prefix, rule_header_prefix, rule.name, rule.content
        ));
        content.push_str("\n\n");
    }

    content
}

pub struct AntigravityAdapter;

impl SyncAdapter for AntigravityAdapter {
    fn id(&self) -> AdapterType {
        AdapterType::Antigravity
    }

    fn name(&self) -> &str {
        registry_entry(&self.id()).name
    }

    fn file_name(&self) -> &str {
        let entry = registry_entry(&self.id());
        Path::new(entry.paths.local_path_template)
            .file_name()
            .and_then(|s| s.to_str())
            .expect("local_path_template in registry must have a valid file name")
    }

    fn description(&self) -> &str {
        registry_entry(&self.id()).description
    }

    fn global_path(&self) -> Result<PathBuf> {
        let entry = registry_entry(&self.id());
        resolve_registry_path(entry.paths.global_path)
    }

    fn format_content(&self, rules: &[Rule], _enabled_rules_only: bool) -> String {
        format_markdown_sync_helper(rules, 3, true, true)
    }

    fn format_rule(&self, rule: &Rule) -> String {
        format!("### Rule: {}\n{}", rule.name, rule.content)
    }
}

pub struct GeminiAdapter;

impl SyncAdapter for GeminiAdapter {
    fn id(&self) -> AdapterType {
        AdapterType::Gemini
    }

    fn name(&self) -> &str {
        registry_entry(&self.id()).name
    }

    fn file_name(&self) -> &str {
        let entry = registry_entry(&self.id());
        Path::new(entry.paths.local_path_template)
            .file_name()
            .and_then(|s| s.to_str())
            .expect("local_path_template in registry must have a valid file name")
    }

    fn description(&self) -> &str {
        registry_entry(&self.id()).description
    }

    fn global_path(&self) -> Result<PathBuf> {
        let entry = registry_entry(&self.id());
        resolve_registry_path(entry.paths.global_path)
    }

    fn format_content(&self, rules: &[Rule], _enabled_rules_only: bool) -> String {
        format_markdown_sync_helper(rules, 3, true, true)
    }

    fn format_rule(&self, rule: &Rule) -> String {
        format!("### Rule: {}\n{}", rule.name, rule.content)
    }
}

pub struct OpenCodeAdapter;

impl SyncAdapter for OpenCodeAdapter {
    fn id(&self) -> AdapterType {
        AdapterType::OpenCode
    }

    fn name(&self) -> &str {
        registry_entry(&self.id()).name
    }

    fn file_name(&self) -> &str {
        let entry = registry_entry(&self.id());
        Path::new(entry.paths.local_path_template)
            .file_name()
            .and_then(|s| s.to_str())
            .expect("local_path_template in registry must have a valid file name")
    }

    fn description(&self) -> &str {
        registry_entry(&self.id()).description
    }

    fn global_path(&self) -> Result<PathBuf> {
        let entry = registry_entry(&self.id());
        resolve_registry_path(entry.paths.global_path)
    }

    fn format_content(&self, rules: &[Rule], _enabled_rules_only: bool) -> String {
        format_markdown_sync_helper(rules, 2, true, false)
    }

    fn format_rule(&self, rule: &Rule) -> String {
        format!("## {}\n{}", rule.name, rule.content)
    }
}

pub struct ClineAdapter;

impl SyncAdapter for ClineAdapter {
    fn id(&self) -> AdapterType {
        AdapterType::Cline
    }

    fn name(&self) -> &str {
        registry_entry(&self.id()).name
    }

    fn file_name(&self) -> &str {
        let entry = registry_entry(&self.id());
        Path::new(entry.paths.local_path_template)
            .file_name()
            .and_then(|s| s.to_str())
            .expect("local_path_template in registry must have a valid file name")
    }

    fn description(&self) -> &str {
        registry_entry(&self.id()).description
    }

    fn global_path(&self) -> Result<PathBuf> {
        let entry = registry_entry(&self.id());
        resolve_registry_path(entry.paths.global_path)
    }

    fn format_content(&self, rules: &[Rule], _enabled_rules_only: bool) -> String {
        format_markdown_sync_helper(rules, 1, false, true)
    }

    fn format_rule(&self, rule: &Rule) -> String {
        format!("# Rule: {}\n{}", rule.name, rule.content)
    }
}

pub struct ClaudeCodeAdapter;

impl SyncAdapter for ClaudeCodeAdapter {
    fn id(&self) -> AdapterType {
        AdapterType::ClaudeCode
    }

    fn name(&self) -> &str {
        registry_entry(&self.id()).name
    }

    fn file_name(&self) -> &str {
        let entry = registry_entry(&self.id());
        Path::new(entry.paths.local_path_template)
            .file_name()
            .and_then(|s| s.to_str())
            .expect("local_path_template in registry must have a valid file name")
    }

    fn description(&self) -> &str {
        registry_entry(&self.id()).description
    }

    fn global_path(&self) -> Result<PathBuf> {
        let entry = registry_entry(&self.id());
        resolve_registry_path(entry.paths.global_path)
    }

    fn format_content(&self, rules: &[Rule], _enabled_rules_only: bool) -> String {
        format_markdown_sync_helper(rules, 2, true, false)
    }

    fn format_rule(&self, rule: &Rule) -> String {
        format!("## {}\n{}", rule.name, rule.content)
    }
}

pub struct CodexAdapter;

impl SyncAdapter for CodexAdapter {
    fn id(&self) -> AdapterType {
        AdapterType::Codex
    }

    fn name(&self) -> &str {
        registry_entry(&self.id()).name
    }

    fn file_name(&self) -> &str {
        let entry = registry_entry(&self.id());
        Path::new(entry.paths.local_path_template)
            .file_name()
            .and_then(|s| s.to_str())
            .expect("local_path_template in registry must have a valid file name")
    }

    fn description(&self) -> &str {
        registry_entry(&self.id()).description
    }

    fn global_path(&self) -> Result<PathBuf> {
        let entry = registry_entry(&self.id());
        resolve_registry_path(entry.paths.global_path)
    }

    fn format_content(&self, rules: &[Rule], _enabled_rules_only: bool) -> String {
        format_markdown_sync_helper(rules, 2, true, false)
    }

    fn format_rule(&self, rule: &Rule) -> String {
        format!("## {}\n{}", rule.name, rule.content)
    }
}

pub struct KiloAdapter;

impl SyncAdapter for KiloAdapter {
    fn id(&self) -> AdapterType {
        AdapterType::Kilo
    }

    fn name(&self) -> &str {
        registry_entry(&self.id()).name
    }

    fn file_name(&self) -> &str {
        let entry = registry_entry(&self.id());
        Path::new(entry.paths.local_path_template)
            .file_name()
            .and_then(|s| s.to_str())
            .expect("local_path_template in registry must have a valid file name")
    }

    fn description(&self) -> &str {
        registry_entry(&self.id()).description
    }

    fn global_path(&self) -> Result<PathBuf> {
        let entry = registry_entry(&self.id());
        resolve_registry_path(entry.paths.global_path)
    }

    fn format_content(&self, rules: &[Rule], _enabled_rules_only: bool) -> String {
        format_markdown_sync_helper(rules, 2, true, false)
    }

    fn format_rule(&self, rule: &Rule) -> String {
        format!("## {}\n{}", rule.name, rule.content)
    }
}

pub struct CursorAdapter;

impl SyncAdapter for CursorAdapter {
    fn id(&self) -> AdapterType {
        AdapterType::Cursor
    }

    fn name(&self) -> &str {
        registry_entry(&self.id()).name
    }

    fn file_name(&self) -> &str {
        let entry = registry_entry(&self.id());
        Path::new(entry.paths.local_path_template)
            .file_name()
            .and_then(|s| s.to_str())
            .expect("local_path_template in registry must have a valid file name")
    }

    fn description(&self) -> &str {
        registry_entry(&self.id()).description
    }

    fn global_path(&self) -> Result<PathBuf> {
        let entry = registry_entry(&self.id());
        resolve_registry_path(entry.paths.global_path)
    }

    fn format_content(&self, rules: &[Rule], _enabled_rules_only: bool) -> String {
        format_markdown_sync_helper(rules, 2, true, false)
    }

    fn format_rule(&self, rule: &Rule) -> String {
        format!("### {}\n{}", rule.name, rule.content)
    }
}

pub struct WindsurfAdapter;

impl SyncAdapter for WindsurfAdapter {
    fn id(&self) -> AdapterType {
        AdapterType::Windsurf
    }

    fn name(&self) -> &str {
        registry_entry(&self.id()).name
    }

    fn file_name(&self) -> &str {
        let entry = registry_entry(&self.id());
        Path::new(entry.paths.local_path_template)
            .file_name()
            .and_then(|s| s.to_str())
            .unwrap_or("rules.md")
    }

    fn description(&self) -> &str {
        registry_entry(&self.id()).description
    }

    fn global_path(&self) -> Result<PathBuf> {
        let entry = registry_entry(&self.id());
        resolve_registry_path(entry.paths.global_path)
    }

    fn format_content(&self, rules: &[Rule], _enabled_rules_only: bool) -> String {
        format_markdown_sync_helper(rules, 2, true, false)
    }

    fn format_rule(&self, rule: &Rule) -> String {
        format!("## {}\n{}", rule.name, rule.content)
    }
}

pub struct RooCodeAdapter;

impl SyncAdapter for RooCodeAdapter {
    fn id(&self) -> AdapterType {
        AdapterType::RooCode
    }

    fn name(&self) -> &str {
        registry_entry(&self.id()).name
    }

    fn file_name(&self) -> &str {
        let entry = registry_entry(&self.id());
        Path::new(entry.paths.local_path_template)
            .file_name()
            .and_then(|s| s.to_str())
            .expect("local_path_template in registry must have a valid file name")
    }

    fn description(&self) -> &str {
        registry_entry(&self.id()).description
    }

    fn global_path(&self) -> Result<PathBuf> {
        let entry = registry_entry(&self.id());
        resolve_registry_path(entry.paths.global_path)
    }

    fn format_content(&self, rules: &[Rule], _enabled_rules_only: bool) -> String {
        format_markdown_sync_helper(rules, 2, true, false)
    }

    fn format_rule(&self, rule: &Rule) -> String {
        format!("## {}\n{}", rule.name, rule.content)
    }
}

pub fn get_all_adapters() -> Vec<Box<dyn SyncAdapter>> {
    vec![
        Box::new(AntigravityAdapter),
        Box::new(GeminiAdapter),
        Box::new(OpenCodeAdapter),
        Box::new(ClineAdapter),
        Box::new(ClaudeCodeAdapter),
        Box::new(CodexAdapter),
        Box::new(KiloAdapter),
        Box::new(CursorAdapter),
        Box::new(WindsurfAdapter),
        Box::new(RooCodeAdapter),
    ]
}

#[allow(dead_code)]
pub fn get_adapter(adapter_type: AdapterType) -> Option<Box<dyn SyncAdapter>> {
    match adapter_type {
        AdapterType::Antigravity => Some(Box::new(AntigravityAdapter)),
        AdapterType::Gemini => Some(Box::new(GeminiAdapter)),
        AdapterType::OpenCode => Some(Box::new(OpenCodeAdapter)),
        AdapterType::Cline => Some(Box::new(ClineAdapter)),
        AdapterType::ClaudeCode => Some(Box::new(ClaudeCodeAdapter)),
        AdapterType::Codex => Some(Box::new(CodexAdapter)),
        AdapterType::Kilo => Some(Box::new(KiloAdapter)),
        AdapterType::Cursor => Some(Box::new(CursorAdapter)),
        AdapterType::Windsurf => Some(Box::new(WindsurfAdapter)),
        AdapterType::RooCode => Some(Box::new(RooCodeAdapter)),
    }
}

pub struct SyncEngine<'a> {
    db: &'a Database,
}

impl<'a> SyncEngine<'a> {
    pub fn new(db: &'a Database) -> Self {
        Self { db }
    }

    async fn get_disabled_adapters(&self) -> HashSet<AdapterType> {
        match self.db.get_setting("adapter_settings").await {
            Ok(Some(settings_json)) => {
                match serde_json::from_str::<HashMap<String, bool>>(&settings_json) {
                    Ok(settings_map) => settings_map
                        .into_iter()
                        .filter(|(_, enabled)| !enabled)
                        .filter_map(|(id, _)| AdapterType::from_str(&id))
                        .collect(),
                    Err(e) => {
                        eprintln!("Warning: Failed to deserialize adapter_settings: {}", e);
                        HashSet::new()
                    }
                }
            }
            Ok(None) => HashSet::new(),
            Err(e) => {
                eprintln!(
                    "Warning: Failed to load adapter_settings from database: {}",
                    e
                );
                HashSet::new()
            }
        }
    }

    pub async fn sync_all(&self, rules: Vec<Rule>) -> SyncResult {
        let mut files_written = Vec::new();
        let mut errors = Vec::new();
        let conflicts = Vec::new();

        let disabled_adapters = self.get_disabled_adapters().await;
        let adapters = get_all_adapters();

        for adapter in &adapters {
            if disabled_adapters.contains(&adapter.id()) {
                continue;
            }

            let adapter_rules: Vec<Rule> = rules
                .iter()
                .filter(|r| {
                    r.enabled_adapters.contains(&adapter.id())
                        && REGISTRY
                            .validate_support(&adapter.id(), &r.scope, ArtifactType::Rule)
                            .is_ok()
                })
                .cloned()
                .collect();

            if adapter_rules.is_empty() {
                continue;
            }

            let global_rules: Vec<Rule> = adapter_rules
                .iter()
                .filter(|r| r.scope == Scope::Global)
                .cloned()
                .collect();

            if !global_rules.is_empty() {
                let path = match adapter.global_path() {
                    Ok(p) => p,
                    Err(e) => {
                        errors.push(SyncError {
                            file_path: String::new(),
                            adapter_name: adapter.name().to_string(),
                            message: e.to_string(),
                        });
                        continue;
                    }
                };
                match self.sync_file(adapter.as_ref(), &global_rules, &path).await {
                    Ok(()) => files_written.push(path.to_string_lossy().to_string()),
                    Err(e) => errors.push(SyncError {
                        file_path: path.to_string_lossy().to_string(),
                        adapter_name: adapter.name().to_string(),
                        message: e.to_string(),
                    }),
                }
            }

            let local_rules_by_path: HashMap<String, Vec<Rule>> = {
                let mut map: HashMap<String, Vec<Rule>> = HashMap::new();
                for rule in adapter_rules.iter().filter(|r| r.scope == Scope::Local) {
                    if let Some(paths) = &rule.target_paths {
                        for path in paths {
                            match validate_target_path(path) {
                                Ok(_) => {
                                    map.entry(path.clone()).or_default().push(rule.clone());
                                }
                                Err(e) => {
                                    errors.push(SyncError {
                                        file_path: path.clone(),
                                        adapter_name: adapter.name().to_string(),
                                        message: e.to_string(),
                                    });
                                }
                            }
                        }
                    }
                }
                map
            };

            for (base_path, path_rules) in local_rules_by_path {
                let path = PathBuf::from(&base_path).join(adapter.file_name());
                match self.sync_file(adapter.as_ref(), &path_rules, &path).await {
                    Ok(()) => files_written.push(path.to_string_lossy().to_string()),
                    Err(e) => errors.push(SyncError {
                        file_path: path.to_string_lossy().to_string(),
                        adapter_name: adapter.name().to_string(),
                        message: e.to_string(),
                    }),
                }
            }
        }

        let success = errors.is_empty() && conflicts.is_empty();

        let status = if errors.is_empty() {
            "success"
        } else if !files_written.is_empty() {
            "partial"
        } else {
            "failed"
        };

        let _ = self
            .db
            .add_sync_log(files_written.len() as u32, status, "manual")
            .await;

        SyncResult {
            success,
            files_written,
            errors,
            conflicts,
        }
    }

    pub async fn sync_rule(&self, rule: Rule) -> SyncResult {
        let mut files_written = Vec::new();
        let mut errors = Vec::new();
        let conflicts = Vec::new();

        let disabled_adapters = self.get_disabled_adapters().await;
        let adapters = get_all_adapters();

        let all_rules = match self.db.get_all_rules().await {
            Ok(r) => r,
            Err(e) => {
                return SyncResult {
                    success: false,
                    files_written: vec![],
                    errors: vec![SyncError {
                        file_path: "".to_string(),
                        adapter_name: "".to_string(),
                        message: format!("Failed to fetch rules: {}", e),
                    }],
                    conflicts: vec![],
                };
            }
        };

        for adapter in &adapters {
            if disabled_adapters.contains(&adapter.id())
                || !rule.enabled_adapters.contains(&adapter.id())
                || REGISTRY
                    .validate_support(&adapter.id(), &rule.scope, ArtifactType::Rule)
                    .is_err()
            {
                continue;
            }

            // For each adapter, we need to sync the file(s) this rule belongs to.
            // This means re-collecting ALL rules for that target file to ensure its content is correct.

            if rule.scope == Scope::Global {
                let path = match adapter.global_path() {
                    Ok(p) => p,
                    Err(e) => {
                        errors.push(SyncError {
                            file_path: String::new(),
                            adapter_name: adapter.name().to_string(),
                            message: e.to_string(),
                        });
                        continue;
                    }
                };

                let global_rules: Vec<Rule> = all_rules
                    .iter()
                    .filter(|r| {
                        r.scope == Scope::Global && r.enabled_adapters.contains(&adapter.id())
                    })
                    .cloned()
                    .collect();

                match self.sync_file(adapter.as_ref(), &global_rules, &path).await {
                    Ok(()) => files_written.push(path.to_string_lossy().to_string()),
                    Err(e) => errors.push(SyncError {
                        file_path: path.to_string_lossy().to_string(),
                        adapter_name: adapter.name().to_string(),
                        message: e.to_string(),
                    }),
                }
            } else if rule.scope == Scope::Local {
                if let Some(paths) = &rule.target_paths {
                    for base_path in paths {
                        if validate_target_path(base_path).is_ok() {
                            let path = PathBuf::from(base_path).join(adapter.file_name());

                            let path_rules: Vec<Rule> = all_rules
                                .iter()
                                .filter(|r| {
                                    r.scope == Scope::Local
                                        && r.enabled_adapters.contains(&adapter.id())
                                        && r.target_paths
                                            .as_ref()
                                            .map(|p| p.contains(base_path))
                                            .unwrap_or(false)
                                })
                                .cloned()
                                .collect();

                            match self.sync_file(adapter.as_ref(), &path_rules, &path).await {
                                Ok(()) => files_written.push(path.to_string_lossy().to_string()),
                                Err(e) => errors.push(SyncError {
                                    file_path: path.to_string_lossy().to_string(),
                                    adapter_name: adapter.name().to_string(),
                                    message: e.to_string(),
                                }),
                            }
                        }
                    }
                }
            }
        }

        let status = if errors.is_empty() {
            "success"
        } else if !files_written.is_empty() {
            "partial"
        } else {
            "failed"
        };

        let _ = self
            .db
            .add_sync_log(files_written.len() as u32, status, "auto")
            .await;

        SyncResult {
            success: errors.is_empty(),
            files_written,
            errors,
            conflicts,
        }
    }

    pub async fn preview(&self, rules: Vec<Rule>) -> SyncResult {
        let mut files_written = Vec::new();
        let mut conflicts = Vec::new();

        let disabled_adapters = self.get_disabled_adapters().await;
        let adapters = get_all_adapters();

        for adapter in &adapters {
            if disabled_adapters.contains(&adapter.id()) {
                continue;
            }

            let adapter_rules: Vec<Rule> = rules
                .iter()
                .filter(|r| {
                    r.enabled_adapters.contains(&adapter.id())
                        && REGISTRY
                            .validate_support(&adapter.id(), &r.scope, ArtifactType::Rule)
                            .is_ok()
                })
                .cloned()
                .collect();

            if adapter_rules.is_empty() {
                continue;
            }

            let global_rules: Vec<Rule> = adapter_rules
                .iter()
                .filter(|r| r.scope == Scope::Global)
                .cloned()
                .collect();

            if !global_rules.is_empty() {
                let path = match adapter.global_path() {
                    Ok(p) => p,
                    Err(_) => continue,
                };
                files_written.push(path.to_string_lossy().to_string());

                // Snapshot: read file content once into memory before any hash comparison.
                // This eliminates the race window between reading the stored hash and computing
                // the current hash — both operations now use the same in-memory buffer.
                if let Some(stored_hash) = self
                    .db
                    .get_file_hash(&path.to_string_lossy())
                    .await
                    .ok()
                    .flatten()
                {
                    if path.exists() {
                        if let Ok(current_content) = fs::read_to_string(&path) {
                            let current_hash = compute_content_hash(&current_content);
                            if stored_hash != current_hash {
                                let expected_content =
                                    adapter.format_content(&global_rules, true);
                                let diff_summary =
                                    compute_diff_summary(&expected_content, &current_content);
                                conflicts.push(Conflict {
                                    id: uuid::Uuid::new_v4().to_string(),
                                    file_path: path.to_string_lossy().to_string(),
                                    adapter_name: adapter.name().to_string(),
                                    adapter_id: Some(adapter.id()),
                                    local_hash: stored_hash,
                                    current_hash,
                                    scope: Some("global".to_string()),
                                    diff_summary: Some(diff_summary),
                                });
                            }
                        }
                    }
                }
            }

            let local_rules_by_path: HashMap<String, Vec<Rule>> = {
                let mut map: HashMap<String, Vec<Rule>> = HashMap::new();
                for rule in adapter_rules.iter().filter(|r| r.scope == Scope::Local) {
                    if let Some(paths) = &rule.target_paths {
                        for base_path in paths {
                            if validate_target_path(base_path).is_ok() {
                                map.entry(base_path.clone()).or_default().push(rule.clone());
                            }
                        }
                    }
                }
                map
            };

            for (base_path, path_rules) in local_rules_by_path {
                let path = PathBuf::from(&base_path).join(adapter.file_name());
                files_written.push(path.to_string_lossy().to_string());

                // Snapshot: read file content once into memory before any hash comparison.
                // This eliminates the race window between reading the stored hash and computing
                // the current hash — both operations now use the same in-memory buffer.
                if let Some(stored_hash) = self
                    .db
                    .get_file_hash(&path.to_string_lossy())
                    .await
                    .ok()
                    .flatten()
                {
                    if path.exists() {
                        if let Ok(current_content) = fs::read_to_string(&path) {
                            let current_hash = compute_content_hash(&current_content);
                            if stored_hash != current_hash {
                                let expected_content =
                                    adapter.format_content(&path_rules, true);
                                let diff_summary =
                                    compute_diff_summary(&expected_content, &current_content);
                                conflicts.push(Conflict {
                                    id: uuid::Uuid::new_v4().to_string(),
                                    file_path: path.to_string_lossy().to_string(),
                                    adapter_name: adapter.name().to_string(),
                                    adapter_id: Some(adapter.id()),
                                    local_hash: stored_hash,
                                    current_hash,
                                    scope: Some("local".to_string()),
                                    diff_summary: Some(diff_summary),
                                });
                            }
                        }
                    }
                }
            }
        }

        SyncResult {
            success: true,
            files_written,
            errors: vec![],
            conflicts,
        }
    }

    async fn sync_file(
        &self,
        adapter: &dyn SyncAdapter,
        rules: &[Rule],
        path: &Path,
    ) -> Result<()> {
        log::debug!(
            "Syncing {} rules to {} ({}) at {}",
            rules.len(),
            adapter.name(),
            adapter.description(),
            path.display()
        );

        for rule in rules {
            log::trace!("Rule content: {}", adapter.format_rule(rule));
        }

        if let Some(parent) = path.parent() {
            fs::create_dir_all(parent)?;
        }

        let content = adapter.format_content(rules, true);
        let hash = compute_content_hash(&content);

        fs::write(path, &content)?;

        self.db
            .set_file_hash(&path.to_string_lossy(), &hash)
            .await?;

        Ok(())
    }

    pub async fn sync_file_by_path(&self, rules: &[Rule], file_path: &str) -> Result<()> {
        validate_target_path(file_path)?;

        let path = PathBuf::from(file_path);
        let adapters = get_all_adapters();

        for adapter in &adapters {
            if let Ok(adapter_path) = adapter.global_path() {
                if adapter_path == path {
                    let adapter_rules: Vec<Rule> = rules
                        .iter()
                        .filter(|r| {
                            r.enabled_adapters.contains(&adapter.id()) && r.scope == Scope::Global
                        })
                        .cloned()
                        .collect();

                    if !adapter_rules.is_empty() {
                        return self
                            .sync_file(adapter.as_ref(), &adapter_rules, &path)
                            .await;
                    }
                }
            }

            let file_name = path.file_name().and_then(|n| n.to_str()).unwrap_or("");
            if file_name == adapter.file_name() {
                if let Some(parent) = path.parent() {
                    let parent_str = parent.to_string_lossy();
                    let local_rules: Vec<Rule> = rules
                        .iter()
                        .filter(|r| {
                            r.enabled_adapters.contains(&adapter.id())
                                && r.scope == Scope::Local
                                && r.target_paths
                                    .as_ref()
                                    .map(|paths| paths.contains(&parent_str.to_string()))
                                    .unwrap_or(false)
                        })
                        .cloned()
                        .collect();

                    if !local_rules.is_empty() {
                        return self.sync_file(adapter.as_ref(), &local_rules, &path).await;
                    }
                }
            }
        }

        Err(crate::error::AppError::InvalidInput {
            message: format!("No adapter found for path: {}", file_path),
        })
    }
}

/// Computes a simple line-level diff summary between two content strings.
///
/// Uses set difference to count lines unique to each side.  Lines present in
/// `actual` but not in `expected` are "added" (externally inserted); lines in
/// `expected` but not in `actual` are "removed" (externally deleted).
/// `changed` is approximated as the minimum of both — representing lines that
/// were likely modified in-place rather than purely added or removed.
fn compute_diff_summary(expected: &str, actual: &str) -> DiffSummary {
    use std::collections::HashSet;

    let expected_lines: HashSet<&str> = expected.lines().collect();
    let actual_lines: HashSet<&str> = actual.lines().collect();

    let added = actual_lines.difference(&expected_lines).count();
    let removed = expected_lines.difference(&actual_lines).count();
    let changed = added.min(removed);

    DiffSummary {
        added: added.saturating_sub(changed),
        removed: removed.saturating_sub(changed),
        changed,
    }
}

fn compute_content_hash(content: &str) -> String {
    let mut hasher = Sha256::new();
    hasher.update(content.as_bytes());
    format!("{:x}", hasher.finalize())
}

pub fn compute_content_hash_public(content: &str) -> String {
    compute_content_hash(content)
}

#[allow(dead_code)]
fn compute_file_hash(path: &Path) -> Result<String> {
    let content = fs::read_to_string(path)?;
    Ok(compute_content_hash(&content))
}

pub fn check_and_migrate_legacy_paths() -> Result<()> {
    let resolver = path_resolver();
    let home = resolver.home_dir().to_path_buf();

    // 1. Antigravity -> Gemini
    let legacy_antigravity = home.join(LEGACY_ANTIGRAVITY_DIR).join(ANTIGRAVITY_FILENAME);
    let new_gemini = home.join(NEW_GEMINI_DIR).join(GEMINI_FILENAME);

    if legacy_antigravity.exists() && !new_gemini.exists() {
        log::info!(
            "Migrating legacy Antigravity config from {} to {}",
            legacy_antigravity.display(),
            new_gemini.display()
        );
        if let Some(parent) = new_gemini.parent() {
            fs::create_dir_all(parent)?;
        }
        fs::rename(&legacy_antigravity, &new_gemini)?;

        // Clean up legacy dir if empty
        if let Some(parent) = legacy_antigravity.parent() {
            if fs::read_dir(parent)?.next().is_none() {
                let _ = fs::remove_dir(parent);
            }
        }
    }

    // 2. OpenCode legacy -> new
    let legacy_opencode = home.join(LEGACY_OPENCODE_DIR).join(OPENCODE_FILENAME);
    let new_opencode = home.join(NEW_OPENCODE_DIR).join(OPENCODE_FILENAME);

    if legacy_opencode.exists() && !new_opencode.exists() {
        log::info!(
            "Migrating legacy OpenCode config from {} to {}",
            legacy_opencode.display(),
            new_opencode.display()
        );
        if let Some(parent) = new_opencode.parent() {
            fs::create_dir_all(parent)?;
        }
        fs::rename(&legacy_opencode, &new_opencode)?;

        // Clean up legacy dir if empty
        if let Some(parent) = legacy_opencode.parent() {
            if fs::read_dir(parent)?.next().is_none() {
                let _ = fs::remove_dir(parent);
            }
        }
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    fn create_test_rule(name: &str, content: &str, scope: Scope) -> Rule {
        let _now = chrono::Utc::now();
        Rule {
            id: uuid::Uuid::new_v4().to_string(),
            name: name.to_string(),
            description: "Test description".to_string(),
            content: content.to_string(),
            scope,
            target_paths: None,
            enabled_adapters: vec![AdapterType::Gemini],
            enabled: true,
            created_at: chrono::Utc::now(),
            updated_at: chrono::Utc::now(),
        }
    }

    #[test]
    fn test_gemini_adapter_format() {
        let adapter = GeminiAdapter;
        let rules = vec![
            create_test_rule("Rule 1", "Content 1", Scope::Global),
            create_test_rule("Rule 2", "Content 2", Scope::Global),
        ];

        let content = adapter.format_content(&rules, true);

        assert!(content.contains("Generated by RuleWeaver"));
        assert!(content.contains("Rule 1"));
        assert!(content.contains("Rule 2"));
        assert!(content.contains("Content 1"));
        assert!(content.contains("Content 2"));
    }

    #[test]
    fn test_opencode_adapter_format() {
        let adapter = OpenCodeAdapter;
        let rules = vec![create_test_rule("Test Rule", "Test Content", Scope::Global)];

        let content = adapter.format_content(&rules, true);

        assert!(content.contains("## Test Rule"));
        assert!(content.contains("Test Content"));
    }

    #[test]
    fn test_cline_adapter_format() {
        let adapter = ClineAdapter;
        let rules = vec![create_test_rule("Test Rule", "Test Content", Scope::Global)];

        let content = adapter.format_content(&rules, true);

        assert!(content.contains("# Rule: Test Rule"));
        assert!(content.contains("Test Content"));
        assert!(content.starts_with("# Generated by RuleWeaver"));
    }

    #[test]
    fn test_adapter_global_path() {
        let adapter = GeminiAdapter;
        let path = adapter.global_path().expect("Failed to get home directory");
        assert!(path.to_string_lossy().contains(".gemini"));
        assert!(path.to_string_lossy().contains("GEMINI.md"));
    }

    #[test]
    fn test_compute_content_hash() {
        let hash1 = compute_content_hash("test content");
        let hash2 = compute_content_hash("test content");
        let hash3 = compute_content_hash("different content");

        assert_eq!(hash1, hash2);
        assert_ne!(hash1, hash3);
        assert_eq!(hash1.len(), 64);
    }

    #[test]
    fn test_disabled_rules_not_included() {
        let adapter = GeminiAdapter;
        let mut rule = create_test_rule("Disabled Rule", "Should not appear", Scope::Global);
        rule.enabled = false;

        let content = adapter.format_content(&[rule], true);
        assert!(!content.contains("Should not appear"));
    }

    #[test]
    fn test_all_adapters_have_consistent_interface() {
        let adapters = get_all_adapters();

        for adapter in adapters {
            assert!(!adapter.name().is_empty());
            assert!(!adapter.file_name().is_empty());
            assert!(!adapter.description().is_empty());

            let rules = vec![create_test_rule("Test", "Content", Scope::Global)];
            let content = adapter.format_content(&rules, true);
            assert!(!content.is_empty());
        }
    }

    // --- Issue #58: compute_diff_summary tests ---

    #[test]
    fn test_diff_summary_identical_content() {
        let content = "line1\nline2\nline3";
        let summary = compute_diff_summary(content, content);
        assert_eq!(summary.added, 0);
        assert_eq!(summary.removed, 0);
        assert_eq!(summary.changed, 0);
    }

    #[test]
    fn test_diff_summary_added_lines() {
        let expected = "line1\nline2";
        let actual = "line1\nline2\nline3\nline4";
        let summary = compute_diff_summary(expected, actual);
        // line3 and line4 are in actual but not expected → 2 added (net of changed)
        assert!(summary.added > 0 || summary.changed > 0);
        assert_eq!(summary.removed, 0);
    }

    #[test]
    fn test_diff_summary_removed_lines() {
        let expected = "line1\nline2\nline3\nline4";
        let actual = "line1\nline2";
        let summary = compute_diff_summary(expected, actual);
        assert!(summary.removed > 0 || summary.changed > 0);
        assert_eq!(summary.added, 0);
    }

    #[test]
    fn test_diff_summary_changed_lines() {
        let expected = "line1\nline2\nline3";
        let actual = "line1\nchanged2\nchanged3";
        let summary = compute_diff_summary(expected, actual);
        // Some combination of added/removed/changed should be non-zero
        assert!(summary.added + summary.removed + summary.changed > 0);
    }

    #[test]
    fn test_diff_summary_empty_strings() {
        let summary = compute_diff_summary("", "");
        assert_eq!(summary.added, 0);
        assert_eq!(summary.removed, 0);
        assert_eq!(summary.changed, 0);
    }

    #[test]
    fn test_diff_summary_completely_different() {
        let expected = "aaa\nbbb\nccc";
        let actual = "xxx\nyyy\nzzz";
        let summary = compute_diff_summary(expected, actual);
        // All lines are different → some non-zero count
        assert!(summary.added + summary.removed + summary.changed > 0);
    }

    // --- Issue #58: Conflict struct field tests ---

    #[test]
    fn test_conflict_includes_scope_and_diff_summary() {
        use crate::models::DiffSummary;

        let conflict = Conflict {
            id: "test-id".to_string(),
            file_path: "/some/path".to_string(),
            adapter_name: "gemini".to_string(),
            adapter_id: Some(AdapterType::Gemini),
            local_hash: "abc".to_string(),
            current_hash: "def".to_string(),
            scope: Some("global".to_string()),
            diff_summary: Some(DiffSummary { added: 1, removed: 2, changed: 0 }),
        };

        assert_eq!(conflict.scope.as_deref(), Some("global"));
        let summary = conflict.diff_summary.unwrap();
        assert_eq!(summary.added, 1);
        assert_eq!(summary.removed, 2);
        assert_eq!(summary.changed, 0);
    }

    #[test]
    fn test_conflict_serializes_scope_and_diff_summary() {
        use crate::models::DiffSummary;

        let conflict = Conflict {
            id: "id".to_string(),
            file_path: "/path".to_string(),
            adapter_name: "cline".to_string(),
            adapter_id: None,
            local_hash: "h1".to_string(),
            current_hash: "h2".to_string(),
            scope: Some("local".to_string()),
            diff_summary: Some(DiffSummary { added: 3, removed: 0, changed: 1 }),
        };

        let json = serde_json::to_string(&conflict).unwrap();
        assert!(json.contains("\"scope\":\"local\""));
        assert!(json.contains("\"diffSummary\""));
        assert!(json.contains("\"added\":3"));
        assert!(json.contains("\"changed\":1"));
    }
}
