use std::collections::HashMap;
use crate::models::{Command};
use crate::execution::slugify;
use super::markdown_escape_inline;

pub trait CommandAdapter {
    fn format(&self, commands: &[Command]) -> String;
    fn name(&self) -> &'static str;
}

pub struct GeminiAdapter;
impl CommandAdapter for GeminiAdapter {
    fn name(&self) -> &'static str { "gemini" }
    fn format(&self, commands: &[Command]) -> String {
        use serde::Serialize;
        #[derive(Serialize)]
        struct CommandStub {
            name: String,
            description: String,
            script: String,
            arguments: Option<HashMap<String, ArgumentStub>>,
        }

        #[derive(Serialize)]
        struct ArgumentStub {
            #[serde(rename = "type")]
            arg_type: String,
            required: bool,
        }

        #[derive(Serialize)]
        struct CommandsFile {
            command: Vec<CommandStub>,
        }

        let mut stubs = Vec::new();
        for cmd in commands.iter().filter(|c| c.expose_via_mcp) {
            let mut args = HashMap::new();
            for arg in &cmd.arguments {
                args.insert(
                    arg.name.clone(),
                    ArgumentStub {
                        arg_type: "string".to_string(),
                        required: arg.required,
                    },
                );
            }

            stubs.push(CommandStub {
                name: slugify(&cmd.name),
                description: cmd.description.clone(),
                script: cmd.script.clone(),
                arguments: if args.is_empty() { None } else { Some(args) },
            });
        }

        let file = CommandsFile { command: stubs };
        let toml_content = toml::to_string(&file).unwrap_or_default();
        format!("# Generated by RuleWeaver - Do not edit manually

{}", toml_content)
    }
}

pub struct OpenCodeAdapter;
impl CommandAdapter for OpenCodeAdapter {
    fn name(&self) -> &'static str { "opencode" }
    fn format(&self, commands: &[Command]) -> String {
        format_markdown(commands, "RuleWeaver Commands")
    }
}

pub struct ClaudeAdapter;
impl CommandAdapter for ClaudeAdapter {
    fn name(&self) -> &'static str { "claude-code" }
    fn format(&self, commands: &[Command]) -> String {
        format_markdown(commands, "RuleWeaver Commands (Claude Code)")
    }
}

fn format_markdown(commands: &[Command], title: &str) -> String {
    let mut out = format!("# {}

", title);
    out.push_str("<!-- Generated by RuleWeaver - Do not edit manually -->

");
    for cmd in commands.iter().filter(|c| c.expose_via_mcp) {
        out.push_str(&format!("## {}

", cmd.name));
        out.push_str(&format!("{}

", cmd.description));
        out.push_str(&format!(
            "**Command:** `{}`

",
            markdown_escape_inline(&cmd.script)
        ));
        if !cmd.arguments.is_empty() {
            out.push_str("**Arguments:**
");
            for arg in &cmd.arguments {
                out.push_str(&format!(
                    "- `{}` (string, {}): {}
",
                    arg.name,
                    if arg.required { "required" } else { "optional" },
                    arg.description
                ));
            }
            out.push('\n');
        }
    }
    out
}
