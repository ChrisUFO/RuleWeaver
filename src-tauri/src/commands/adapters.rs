use super::markdown_escape_inline;
use crate::execution::slugify;
use crate::models::Command;
use std::collections::HashMap;

pub trait CommandAdapter: Send + Sync {
    fn format(&self, commands: &[Command]) -> String;
    fn name(&self) -> &'static str;
}

pub struct GeminiAdapter;
impl CommandAdapter for GeminiAdapter {
    fn name(&self) -> &'static str {
        "gemini"
    }
    fn format(&self, commands: &[Command]) -> String {
        use serde::Serialize;
        #[derive(Serialize)]
        struct CommandStub {
            name: String,
            description: String,
            script: String,
            arguments: Option<HashMap<String, ArgumentStub>>,
        }

        #[derive(Serialize)]
        struct ArgumentStub {
            #[serde(rename = "type")]
            arg_type: String,
            required: bool,
        }

        #[derive(Serialize)]
        struct CommandsFile {
            command: Vec<CommandStub>,
        }

        let mut stubs = Vec::new();
        for cmd in commands.iter().filter(|c| c.expose_via_mcp) {
            let mut args = HashMap::new();
            for arg in &cmd.arguments {
                args.insert(
                    arg.name.clone(),
                    ArgumentStub {
                        arg_type: "string".to_string(),
                        required: arg.required,
                    },
                );
            }

            stubs.push(CommandStub {
                name: slugify(&cmd.name),
                description: cmd.description.clone(),
                script: cmd.script.clone(),
                arguments: if args.is_empty() { None } else { Some(args) },
            });
        }

        let file = CommandsFile { command: stubs };
        let toml_content = toml::to_string(&file).unwrap_or_default();
        format!(
            "# Generated by RuleWeaver - Do not edit manually

{}",
            toml_content
        )
    }
}

pub struct OpenCodeAdapter;
impl CommandAdapter for OpenCodeAdapter {
    fn name(&self) -> &'static str {
        "opencode"
    }
    fn format(&self, commands: &[Command]) -> String {
        format_markdown(commands, "RuleWeaver Commands")
    }
}

pub struct ClaudeAdapter;
impl CommandAdapter for ClaudeAdapter {
    fn name(&self) -> &'static str {
        "claude-code"
    }
    fn format(&self, commands: &[Command]) -> String {
        format_markdown(commands, "RuleWeaver Commands (Claude Code)")
    }
}

pub struct KiloAdapter;
impl CommandAdapter for KiloAdapter {
    fn name(&self) -> &'static str {
        "kilo"
    }
    fn format(&self, commands: &[Command]) -> String {
        format_markdown(commands, "RuleWeaver Commands (Kilo Code)")
    }
}

pub struct CursorAdapter;
impl CommandAdapter for CursorAdapter {
    fn name(&self) -> &'static str {
        "cursor"
    }
    fn format(&self, commands: &[Command]) -> String {
        format_markdown(commands, "RuleWeaver Commands (Cursor)")
    }
}

pub struct WindsurfAdapter;
impl CommandAdapter for WindsurfAdapter {
    fn name(&self) -> &'static str {
        "windsurf"
    }
    fn format(&self, commands: &[Command]) -> String {
        format_markdown(commands, "RuleWeaver Commands (Windsurf)")
    }
}

pub struct RooCodeAdapter;
impl CommandAdapter for RooCodeAdapter {
    fn name(&self) -> &'static str {
        "roocode"
    }
    fn format(&self, commands: &[Command]) -> String {
        format_markdown(commands, "RuleWeaver Commands (Roo Code)")
    }
}

fn format_markdown(commands: &[Command], title: &str) -> String {
    let mut out = format!(
        "# {}

",
        title
    );
    out.push_str(
        "<!-- Generated by RuleWeaver - Do not edit manually -->

",
    );
    for cmd in commands.iter().filter(|c| c.expose_via_mcp) {
        out.push_str(&format!(
            "## {}

",
            cmd.name
        ));
        out.push_str(&format!(
            "{}

",
            cmd.description
        ));
        out.push_str(&format!(
            "**Command:** `{}`

",
            markdown_escape_inline(&cmd.script)
        ));
        if !cmd.arguments.is_empty() {
            out.push_str(
                "**Arguments:**
",
            );
            for arg in &cmd.arguments {
                out.push_str(&format!(
                    "- `{}` (string, {}): {}
",
                    arg.name,
                    if arg.required { "required" } else { "optional" },
                    arg.description
                ));
            }
            out.push('\n');
        }
    }
    out
}
