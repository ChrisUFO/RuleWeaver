use super::SlashCommandAdapter;
use crate::models::registry::{ToolEntry, REGISTRY};
use crate::models::AdapterType;
use crate::models::Command;
use serde::Serialize;
use std::borrow::Cow;

fn registry_entry(adapter: &AdapterType) -> &'static ToolEntry {
    REGISTRY.get(adapter).unwrap_or_else(|| {
        panic!(
            "ToolRegistry missing entry for adapter '{}'. All AdapterType variants must be registered.",
            adapter.as_str()
        )
    })
}

#[derive(Serialize)]
struct StandardFrontmatter<'a> {
    name: Cow<'a, str>,
    description: Cow<'a, str>,
    #[serde(skip_serializing_if = "Option::is_none")]
    arguments: Option<Vec<ArgumentEntry<'a>>>,
    #[serde(rename = "argument-hint", skip_serializing_if = "Option::is_none")]
    argument_hint: Option<Cow<'a, str>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    tools: Option<Vec<Cow<'a, str>>>,
}

#[derive(Serialize)]
struct ArgumentEntry<'a> {
    name: Cow<'a, str>,
    description: Cow<'a, str>,
    required: bool,
}

fn format_with_frontmatter(frontmatter: &StandardFrontmatter<'_>, script: &str) -> String {
    let yaml = match serde_yaml::to_string(frontmatter) {
        Ok(y) => y,
        Err(e) => {
            log::error!("Failed to serialize frontmatter: {}", e);
            return script.to_string();
        }
    };
    format!(
        "<!-- Generated by RuleWeaver - Do not edit manually -->
---
{}---

{}",
        yaml, script
    )
}

/// OpenCode slash command adapter
/// Format: YAML frontmatter + markdown content
/// Arguments: $ARGUMENTS, $1-$9, !`command` for shell, @filename for file refs
pub struct OpenCodeSlashAdapter;

impl SlashCommandAdapter for OpenCodeSlashAdapter {
    fn name(&self) -> &'static str {
        AdapterType::OpenCode.as_str()
    }

    fn file_extension(&self) -> &'static str {
        registry_entry(&AdapterType::OpenCode)
            .slash_command_extension
            .unwrap_or("md")
    }

    fn global_dir(&self) -> &'static str {
        registry_entry(&AdapterType::OpenCode)
            .paths
            .global_commands_dir
            .unwrap_or("")
    }

    fn local_dir(&self) -> &'static str {
        registry_entry(&AdapterType::OpenCode)
            .paths
            .local_commands_dir
            .unwrap_or("")
    }

    fn format_command(&self, command: &Command) -> String {
        let arguments = if command.arguments.is_empty() {
            None
        } else {
            Some(
                command
                    .arguments
                    .iter()
                    .map(|arg| ArgumentEntry {
                        name: Cow::from(&arg.name),
                        description: Cow::from(&arg.description),
                        required: arg.required,
                    })
                    .collect(),
            )
        };

        let frontmatter = StandardFrontmatter {
            name: Cow::from(&command.name),
            description: Cow::from(&command.description),
            arguments,
            argument_hint: None,
            tools: None,
        };

        format_with_frontmatter(&frontmatter, &command.script)
    }

    fn supports_argument_substitution(&self) -> bool {
        true
    }

    fn argument_pattern(&self) -> Option<&'static str> {
        Some("$ARGUMENTS")
    }
}

/// Claude Code slash command adapter
/// Format: YAML frontmatter + markdown (Agent Skills standard)
/// Arguments: $ARGUMENTS, $1-$9
pub struct ClaudeCodeSlashAdapter;

impl SlashCommandAdapter for ClaudeCodeSlashAdapter {
    fn name(&self) -> &'static str {
        AdapterType::ClaudeCode.as_str()
    }

    fn file_extension(&self) -> &'static str {
        registry_entry(&AdapterType::ClaudeCode)
            .slash_command_extension
            .unwrap_or("md")
    }

    fn global_dir(&self) -> &'static str {
        registry_entry(&AdapterType::ClaudeCode)
            .paths
            .global_commands_dir
            .unwrap_or("")
    }

    fn local_dir(&self) -> &'static str {
        registry_entry(&AdapterType::ClaudeCode)
            .paths
            .local_commands_dir
            .unwrap_or("")
    }

    fn format_command(&self, command: &Command) -> String {
        let frontmatter = StandardFrontmatter {
            name: Cow::from(&command.name),
            description: Cow::from(&command.description),
            arguments: None,
            argument_hint: None,
            tools: Some(vec![Cow::from("bash")]),
        };

        format_with_frontmatter(&frontmatter, &command.script)
    }

    fn supports_argument_substitution(&self) -> bool {
        true
    }

    fn argument_pattern(&self) -> Option<&'static str> {
        Some("$ARGUMENTS")
    }
}

/// Cline slash command adapter (Workflows)
/// Format: Markdown with numbered steps
/// Arguments: Natural language (no substitution)
pub struct ClineSlashAdapter;

impl SlashCommandAdapter for ClineSlashAdapter {
    fn name(&self) -> &'static str {
        AdapterType::Cline.as_str()
    }

    fn file_extension(&self) -> &'static str {
        REGISTRY
            .get(&AdapterType::Cline)
            .and_then(|e| e.slash_command_extension)
            .unwrap_or("md")
    }

    fn global_dir(&self) -> &'static str {
        REGISTRY
            .get(&AdapterType::Cline)
            .and_then(|e| e.paths.global_commands_dir)
            .unwrap_or("")
    }

    fn local_dir(&self) -> &'static str {
        REGISTRY
            .get(&AdapterType::Cline)
            .and_then(|e| e.paths.local_commands_dir)
            .unwrap_or("")
    }

    fn format_command(&self, command: &Command) -> String {
        let mut output = String::new();

        output.push_str(&format!("# {}\n\n", command.name));
        output.push_str(&command.description);
        output.push_str("\n\n");
        output.push_str(&command.script);

        output
    }

    fn supports_argument_substitution(&self) -> bool {
        false
    }
}

/// Gemini CLI slash command adapter
/// Format: TOML files
/// Arguments: {{args}}
pub struct GeminiSlashAdapter;

impl SlashCommandAdapter for GeminiSlashAdapter {
    fn name(&self) -> &'static str {
        AdapterType::Gemini.as_str()
    }

    fn file_extension(&self) -> &'static str {
        REGISTRY
            .get(&AdapterType::Gemini)
            .and_then(|e| e.slash_command_extension)
            .unwrap_or("md")
    }

    fn global_dir(&self) -> &'static str {
        REGISTRY
            .get(&AdapterType::Gemini)
            .and_then(|e| e.paths.global_commands_dir)
            .unwrap_or("")
    }

    fn local_dir(&self) -> &'static str {
        REGISTRY
            .get(&AdapterType::Gemini)
            .and_then(|e| e.paths.local_commands_dir)
            .unwrap_or("")
    }

    fn format_command(&self, command: &Command) -> String {
        let mut output = String::new();

        output.push_str(&format!("description = \"{}\"\n", command.description));
        output.push_str("prompt = \"\"\"\n");
        output.push_str(&command.script);
        output.push_str("\n{{args}}\n");
        output.push_str("\"\"\"\n");

        output
    }

    fn supports_argument_substitution(&self) -> bool {
        true
    }

    fn argument_pattern(&self) -> Option<&'static str> {
        REGISTRY
            .get(&AdapterType::Gemini)
            .and_then(|e| e.slash_command_argument_pattern)
    }
}

/// Cursor slash command adapter
/// Format: Plain Markdown
/// Arguments: Natural language (auto-included after command)
pub struct CursorSlashAdapter;

impl SlashCommandAdapter for CursorSlashAdapter {
    fn name(&self) -> &'static str {
        AdapterType::Cursor.as_str()
    }

    fn file_extension(&self) -> &'static str {
        REGISTRY
            .get(&AdapterType::Cursor)
            .and_then(|e| e.slash_command_extension)
            .unwrap_or("md")
    }

    fn global_dir(&self) -> &'static str {
        REGISTRY
            .get(&AdapterType::Cursor)
            .and_then(|e| e.paths.global_commands_dir)
            .unwrap_or("")
    }

    fn local_dir(&self) -> &'static str {
        REGISTRY
            .get(&AdapterType::Cursor)
            .and_then(|e| e.paths.local_commands_dir)
            .unwrap_or("")
    }

    fn format_command(&self, command: &Command) -> String {
        let mut output = String::new();

        output.push_str(&format!("# {}\n\n", command.name));
        output.push_str(&command.script);

        output
    }

    fn supports_argument_substitution(&self) -> bool {
        false
    }
}

/// Roo Code slash command adapter
/// Format: YAML frontmatter + Markdown
/// Arguments: argument-hint in frontmatter
pub struct RooCodeSlashAdapter;

impl SlashCommandAdapter for RooCodeSlashAdapter {
    fn name(&self) -> &'static str {
        AdapterType::RooCode.as_str()
    }

    fn file_extension(&self) -> &'static str {
        REGISTRY
            .get(&AdapterType::RooCode)
            .and_then(|e| e.slash_command_extension)
            .unwrap_or("md")
    }

    fn global_dir(&self) -> &'static str {
        REGISTRY
            .get(&AdapterType::RooCode)
            .and_then(|e| e.paths.global_commands_dir)
            .unwrap_or("")
    }

    fn local_dir(&self) -> &'static str {
        REGISTRY
            .get(&AdapterType::RooCode)
            .and_then(|e| e.paths.local_commands_dir)
            .unwrap_or("")
    }

    fn format_command(&self, command: &Command) -> String {
        let argument_hint = if command.arguments.is_empty() {
            None
        } else {
            let hints: Vec<String> = command
                .arguments
                .iter()
                .map(|arg| format!("<{}>", arg.name))
                .collect();
            Some(hints.join(" "))
        };

        let frontmatter = StandardFrontmatter {
            name: Cow::from(&command.name),
            description: Cow::from(&command.description),
            arguments: None,
            argument_hint: argument_hint.map(Cow::from),
            tools: None,
        };

        format_with_frontmatter(&frontmatter, &command.script)
    }

    fn supports_argument_substitution(&self) -> bool {
        false
    }
}

/// Antigravity slash command adapter (Workflows)
/// Format: YAML frontmatter + markdown
/// Arguments: Natural language
pub struct AntigravitySlashAdapter;

impl SlashCommandAdapter for AntigravitySlashAdapter {
    fn name(&self) -> &'static str {
        AdapterType::Antigravity.as_str()
    }

    fn file_extension(&self) -> &'static str {
        REGISTRY
            .get(&AdapterType::Antigravity)
            .and_then(|e| e.slash_command_extension)
            .unwrap_or("md")
    }

    fn global_dir(&self) -> &'static str {
        REGISTRY
            .get(&AdapterType::Antigravity)
            .and_then(|e| e.paths.global_commands_dir)
            .unwrap_or("")
    }

    fn local_dir(&self) -> &'static str {
        REGISTRY
            .get(&AdapterType::Antigravity)
            .and_then(|e| e.paths.local_commands_dir)
            .unwrap_or("")
    }

    fn format_command(&self, command: &Command) -> String {
        let frontmatter = StandardFrontmatter {
            name: Cow::from(&command.name),
            description: Cow::from(&command.description),
            arguments: None,
            argument_hint: None,
            tools: None,
        };

        format_with_frontmatter(&frontmatter, &command.script)
    }

    fn supports_argument_substitution(&self) -> bool {
        false
    }
}

/// Codex slash command adapter (Skills)
/// Format: Agent Skills directory structure
/// Note: Codex uses Skills AS slash commands
pub struct CodexSlashAdapter;

impl SlashCommandAdapter for CodexSlashAdapter {
    fn name(&self) -> &'static str {
        AdapterType::Codex.as_str()
    }

    fn file_extension(&self) -> &'static str {
        REGISTRY
            .get(&AdapterType::Codex)
            .and_then(|e| e.slash_command_extension)
            .unwrap_or("md")
    }

    fn global_dir(&self) -> &'static str {
        REGISTRY
            .get(&AdapterType::Codex)
            .and_then(|e| e.paths.global_commands_dir)
            .unwrap_or("")
    }

    fn local_dir(&self) -> &'static str {
        REGISTRY
            .get(&AdapterType::Codex)
            .and_then(|e| e.paths.local_commands_dir)
            .unwrap_or("")
    }

    fn format_command(&self, command: &Command) -> String {
        let frontmatter = StandardFrontmatter {
            name: Cow::from(&command.name),
            description: Cow::from(&command.description),
            arguments: None,
            argument_hint: None,
            tools: None,
        };

        format_with_frontmatter(&frontmatter, &command.script)
    }

    fn get_filename(&self, command_name: &str) -> String {
        // Skills use a directory structure: {name}/SKILL.md
        format!("{}/{}", command_name, "SKILL.md")
    }

    fn supports_argument_substitution(&self) -> bool {
        false
    }
}

/// Factory function to get adapter by name
pub fn get_adapter(name: &str) -> Option<Box<dyn SlashCommandAdapter>> {
    match name {
        "opencode" => Some(Box::new(OpenCodeSlashAdapter)),
        "claude-code" => Some(Box::new(ClaudeCodeSlashAdapter)),
        "cline" => Some(Box::new(ClineSlashAdapter)),
        "gemini" => Some(Box::new(GeminiSlashAdapter)),
        "cursor" => Some(Box::new(CursorSlashAdapter)),
        "roocode" => Some(Box::new(RooCodeSlashAdapter)),
        "antigravity" => Some(Box::new(AntigravitySlashAdapter)),
        "codex" => Some(Box::new(CodexSlashAdapter)),
        // Kilo Code and Windsurf have no slash command directory in the registry
        // (slash_command_extension: None) so they are intentionally unsupported here.
        "kilo" | "windsurf" => None,
        _ => None,
    }
}

/// Get all available adapters
pub fn get_all_adapters() -> Vec<Box<dyn SlashCommandAdapter>> {
    vec![
        Box::new(OpenCodeSlashAdapter),
        Box::new(ClaudeCodeSlashAdapter),
        Box::new(ClineSlashAdapter),
        Box::new(GeminiSlashAdapter),
        Box::new(CursorSlashAdapter),
        Box::new(RooCodeSlashAdapter),
        Box::new(AntigravitySlashAdapter),
        Box::new(CodexSlashAdapter),
    ]
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::models::Command;

    fn create_test_command() -> Command {
        Command::new(
            "test-cmd".to_string(),
            "Test command description".to_string(),
            "npm test".to_string(),
            false,
        )
    }

    #[test]
    fn test_opencode_adapter() {
        let adapter = OpenCodeSlashAdapter;
        assert_eq!(adapter.name(), "opencode");
        assert_eq!(adapter.file_extension(), "md");
        assert!(adapter.supports_argument_substitution());

        let command = create_test_command();
        let content = adapter.format_command(&command);
        assert!(content.contains("name: test-cmd"));
        assert!(content.contains("npm test"));
    }

    #[test]
    fn test_claude_adapter() {
        let adapter = ClaudeCodeSlashAdapter;
        assert_eq!(adapter.name(), "claude-code");
        assert!(adapter.supports_argument_substitution());

        let command = create_test_command();
        let content = adapter.format_command(&command);
        assert!(content.contains("tools:"));
    }

    #[test]
    fn test_gemini_adapter_toml_format() {
        let adapter = GeminiSlashAdapter;
        assert_eq!(adapter.file_extension(), "toml");

        let command = create_test_command();
        let content = adapter.format_command(&command);
        assert!(content.contains("description = "));
        assert!(content.contains("{{args}}"));
    }

    #[test]
    fn test_codex_skill_structure() {
        let adapter = CodexSlashAdapter;
        let path = adapter
            .get_command_path("my-skill", true)
            .expect("Failed to get path");
        let path_str = path.to_string_lossy();
        // Codex uses .agents/skills directory for slash commands
        // The PathResolver generates {name}.{extension} format
        assert!(path_str.contains(".agents"));
        assert!(path_str.contains("skills"));
        assert!(path_str.contains("my-skill.md"));
    }

    #[test]
    fn test_all_adapters_produce_content() {
        let adapters: Vec<Box<dyn SlashCommandAdapter>> = vec![
            Box::new(OpenCodeSlashAdapter),
            Box::new(ClaudeCodeSlashAdapter),
            Box::new(ClineSlashAdapter),
            Box::new(GeminiSlashAdapter),
            Box::new(CursorSlashAdapter),
            Box::new(RooCodeSlashAdapter),
            Box::new(AntigravitySlashAdapter),
            Box::new(CodexSlashAdapter),
        ];

        let command = create_test_command();

        for adapter in adapters {
            let content = adapter.format_command(&command);
            assert!(
                !content.is_empty(),
                "Adapter {} should produce non-empty content",
                adapter.name()
            );
        }
    }

    #[test]
    fn test_standard_frontmatter_serialization() {
        let command = Command::new(
            "test-cmd".to_string(),
            "Description".to_string(),
            "echo hello".to_string(),
            false,
        );

        let frontmatter = StandardFrontmatter {
            name: Cow::from(&command.name),
            description: Cow::from(&command.description),
            arguments: Some(vec![ArgumentEntry {
                name: Cow::from("arg1"),
                description: Cow::from("desc1"),
                required: true,
            }]),
            argument_hint: Some(Cow::from("<arg1>")),
            tools: Some(vec![Cow::from("bash")]),
        };

        let result = format_with_frontmatter(&frontmatter, &command.script);

        let expected_yaml = r#"name: test-cmd
description: Description
arguments:
- name: arg1
  description: desc1
  required: true
argument-hint: <arg1>
tools:
- bash
"#;
        let expected = format!(
            "<!-- Generated by RuleWeaver - Do not edit manually -->\n---\n{}---\n\n{}",
            expected_yaml, &command.script
        );
        assert_eq!(result, expected);
    }

    #[test]
    fn test_adapter_name_uniqueness() {
        let names = [
            OpenCodeSlashAdapter.name(),
            ClaudeCodeSlashAdapter.name(),
            ClineSlashAdapter.name(),
            GeminiSlashAdapter.name(),
            CursorSlashAdapter.name(),
            RooCodeSlashAdapter.name(),
            AntigravitySlashAdapter.name(),
            CodexSlashAdapter.name(),
        ];

        let unique: std::collections::HashSet<_> = names.iter().cloned().collect();
        assert_eq!(names.len(), unique.len(), "Adapter names must be unique");
    }
}
