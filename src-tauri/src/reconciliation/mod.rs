//! Reconciliation engine for RuleWeaver.
//!
//! This module provides a desired-state reconciliation system that automatically
//! cleans up stale artifacts when rules/commands/skills are renamed, deleted, or retargeted.
//!
//! # Design Principles
//!
//! - **Desired State**: Computed from database artifacts
//! - **Actual State**: Scanned from filesystem
//! - **Idempotent**: Safe to run multiple times; produces same result
//! - **Dry-Run First**: All operations support preview mode
//! - **Audit Logging**: All operations are logged for diagnostics
//!
//!
//! # Status
//!
//! This module exposes public APIs that are not yet integrated into the main application.
//! The `allow(dead_code)` attribute suppresses warnings during this transitional phase.
//! TODO: Remove #![allow(dead_code)] once reconciliation is fully integrated.

#![allow(dead_code)]

use std::collections::HashMap;
use std::fs;
use std::path::{Path, PathBuf};
use std::sync::Arc;

use serde::{Deserialize, Serialize};

use crate::database::Database;
use crate::error::Result;
use crate::models::registry::{ArtifactType, REGISTRY};
use crate::models::{AdapterType, ReconcileOperation, ReconcileResultType, Scope};
use crate::path_resolver::PathResolver;
use crate::slash_commands::adapters::get_adapter;

const MAX_FILE_SIZE_BYTES: u64 = 10 * 1024 * 1024;

/// Marker string that identifies files created/managed by RuleWeaver.
/// Only files containing this marker should be considered for removal during reconciliation.
const RULEWEAVER_MARKER: &str = "Generated by RuleWeaver";

pub mod formatter;

/// Represents the desired state of generated artifacts.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct DesiredState {
    /// All paths that should exist with their expected content hashes
    #[serde(default)]
    pub expected_paths: HashMap<String, ExpectedArtifact>,
}

/// An artifact that should exist in the desired state.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ExpectedArtifact {
    /// The unique ID of the artifact (e.g., rule ID, command name)
    pub id: String,
    /// The display name of the artifact
    pub name: String,
    /// The adapter this artifact is for
    pub adapter: AdapterType,
    /// The type of artifact
    pub artifact_type: ArtifactType,
    /// The scope (global or local)
    pub scope: Scope,
    /// The repository root for local artifacts (None for global)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub repo_root: Option<PathBuf>,
    /// Expected content hash
    pub content_hash: String,
    /// The actual content to write (not serialized, used internally)
    #[serde(skip)]
    pub content: Option<String>,
}

/// Represents actual filesystem state.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ActualState {
    /// All generated artifacts currently on disk
    #[serde(default)]
    pub found_paths: HashMap<String, FoundArtifact>,
}

/// An artifact found on the filesystem.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct FoundArtifact {
    /// The path to the artifact
    pub path: PathBuf,
    /// The adapter this artifact is for (inferred from path)
    pub adapter: Option<AdapterType>,
    /// The type of artifact (inferred from path)
    pub artifact_type: Option<ArtifactType>,
    /// The scope (global or local)
    pub scope: Option<Scope>,
    /// Current content hash
    pub content_hash: String,
}

/// Reconciliation plan.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ReconcilePlan {
    /// Paths that need to be created
    #[serde(default)]
    pub to_create: Vec<ResolvedArtifact>,
    /// Paths that need to be updated
    #[serde(default)]
    pub to_update: Vec<ResolvedArtifact>,
    /// Paths that need to be removed (stale)
    #[serde(default)]
    pub to_remove: Vec<FoundArtifact>,
    /// Paths that are unchanged
    #[serde(default)]
    pub unchanged: Vec<PathBuf>,
}

/// A resolved artifact in the reconciliation plan.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ResolvedArtifact {
    pub path: PathBuf,
    pub adapter: AdapterType,
    pub artifact_type: ArtifactType,
    pub scope: Scope,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub repo_root: Option<PathBuf>,
    pub content_hash: String,
    /// The actual content to write (not serialized, used internally)
    #[serde(skip)]
    pub content: Option<String>,
}

/// Result of a reconciliation operation.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ReconcileResult {
    /// Whether the operation was successful
    pub success: bool,
    /// Number of artifacts created
    pub created: usize,
    /// Number of artifacts updated
    pub updated: usize,
    /// Number of artifacts removed
    pub removed: usize,
    /// Number of artifacts unchanged
    pub unchanged: usize,
    /// Errors encountered during reconciliation
    #[serde(default)]
    pub errors: Vec<String>,
    /// Non-fatal warnings
    #[serde(default)]
    pub warnings: Vec<String>,
}

/// Engine for reconciling desired state with actual filesystem state.
pub struct ReconciliationEngine {
    db: Arc<Database>,
    path_resolver: PathResolver,
}

impl ReconciliationEngine {
    /// Create a new ReconciliationEngine.
    pub fn new(db: Arc<Database>) -> Result<Self> {
        let path_resolver = PathResolver::new()?;
        Ok(Self { db, path_resolver })
    }

    /// Create a ReconciliationEngine with an explicit PathResolver (for tests only).
    #[cfg(any(test, feature = "test-helpers"))]
    pub fn new_with_resolver(db: Arc<Database>, path_resolver: PathResolver) -> Self {
        Self { db, path_resolver }
    }

    /// Compute desired state from all database artifacts.
    ///
    /// This scans all rules, commands, and skills in the database and computes
    /// what paths should exist for each artifact type.
    pub async fn compute_desired_state(&self) -> Result<DesiredState> {
        let mut desired = DesiredState::default();

        self.compute_desired_state_rules(&mut desired).await?;
        self.compute_desired_state_command_stubs(&mut desired)
            .await?;
        self.compute_desired_state_slash_commands(&mut desired)
            .await?;
        self.compute_desired_state_skills(&mut desired).await?;

        Ok(desired)
    }

    /// Compute desired state for rules.
    async fn compute_desired_state_rules(&self, desired: &mut DesiredState) -> Result<()> {
        let rules = self.db.get_all_rules().await?;

        for rule in rules {
            if !rule.enabled {
                continue;
            }

            for adapter in &rule.enabled_adapters {
                if REGISTRY
                    .validate_support(adapter, &rule.scope, ArtifactType::Rule)
                    .is_err()
                {
                    continue;
                }

                let formatted = formatter::format_rule_content(&rule.name, &rule.content);
                let content_hash = compute_content_hash(&formatted);

                match rule.scope {
                    Scope::Global => {
                        if let Ok(resolved) =
                            self.path_resolver.global_path(*adapter, ArtifactType::Rule)
                        {
                            let path_str = resolved.path.to_string_lossy().to_string();
                            desired.expected_paths.insert(
                                path_str.clone(),
                                ExpectedArtifact {
                                    id: rule.id.clone(),
                                    name: rule.name.clone(),
                                    adapter: *adapter,
                                    artifact_type: ArtifactType::Rule,
                                    scope: Scope::Global,
                                    repo_root: None,
                                    content_hash: content_hash.clone(),
                                    content: Some(formatted.clone()),
                                },
                            );
                        }
                    }
                    Scope::Local => {
                        if let Some(target_paths) = &rule.target_paths {
                            for target_path in target_paths {
                                if let Ok(resolved) = self.path_resolver.local_path(
                                    *adapter,
                                    ArtifactType::Rule,
                                    Path::new(target_path),
                                ) {
                                    let path_str = resolved.path.to_string_lossy().to_string();
                                    desired.expected_paths.insert(
                                        path_str.clone(),
                                        ExpectedArtifact {
                                            id: rule.id.clone(),
                                            name: rule.name.clone(),
                                            adapter: *adapter,
                                            artifact_type: ArtifactType::Rule,
                                            scope: Scope::Local,
                                            repo_root: Some(PathBuf::from(target_path)),
                                            content_hash: content_hash.clone(),
                                            content: Some(formatted.clone()),
                                        },
                                    );
                                }
                            }
                        }
                    }
                }
            }
        }

        Ok(())
    }

    /// Compute desired state for command stubs (COMMANDS.md/COMMANDS.toml files).
    async fn compute_desired_state_command_stubs(&self, desired: &mut DesiredState) -> Result<()> {
        let commands = self.db.get_all_commands().await?;

        let exposed_commands: Vec<_> = commands.into_iter().filter(|c| c.expose_via_mcp).collect();
        if exposed_commands.is_empty() {
            return Ok(());
        }

        for adapter in AdapterType::all() {
            if REGISTRY
                .validate_support(&adapter, &Scope::Global, ArtifactType::CommandStub)
                .is_err()
            {
                continue;
            }

            if let Ok(resolved) = self
                .path_resolver
                .global_path(adapter, ArtifactType::CommandStub)
            {
                let content = formatter::format_command_stub_content(&adapter, &exposed_commands);
                let content_hash = compute_content_hash(&content);
                let path_str = resolved.path.to_string_lossy().to_string();

                desired.expected_paths.insert(
                    path_str.clone(),
                    ExpectedArtifact {
                        id: "command-stubs".to_string(),
                        name: "COMMANDS.md".to_string(),
                        adapter,
                        artifact_type: ArtifactType::CommandStub,
                        scope: Scope::Global,
                        repo_root: None,
                        content_hash,
                        content: Some(content),
                    },
                );
            }
        }

        Ok(())
    }

    /// Compute desired state for slash commands (individual command files).
    async fn compute_desired_state_slash_commands(&self, desired: &mut DesiredState) -> Result<()> {
        let commands = self.db.get_all_commands().await?;

        for command in commands {
            if !command.generate_slash_commands {
                continue;
            }

            for adapter_name in &command.slash_command_adapters {
                let adapter_type = match AdapterType::from_str(adapter_name) {
                    Some(a) => a,
                    None => continue,
                };

                if REGISTRY
                    .validate_support(&adapter_type, &Scope::Global, ArtifactType::SlashCommand)
                    .is_err()
                {
                    continue;
                }

                let slash_adapter = match get_adapter(adapter_name) {
                    Some(a) => a,
                    None => continue,
                };

                let safe_name =
                    match crate::slash_commands::sync::validate_command_name(&command.name) {
                        Ok(name) => name,
                        Err(_) => continue,
                    };

                let content = slash_adapter.format_command(&command);
                let content_hash = compute_content_hash(&content);

                if let Ok(resolved) =
                    self.path_resolver
                        .slash_command_path(adapter_type, &safe_name, true)
                {
                    let path_str = resolved.path.to_string_lossy().to_string();
                    desired.expected_paths.insert(
                        path_str.clone(),
                        ExpectedArtifact {
                            id: format!("command-{}", safe_name),
                            name: safe_name.clone(),
                            adapter: adapter_type,
                            artifact_type: ArtifactType::SlashCommand,
                            scope: Scope::Global,
                            repo_root: None,
                            content_hash: content_hash.clone(),
                            content: Some(content.clone()),
                        },
                    );
                }

                for target_path in &command.target_paths {
                    if let Ok(resolved) = self.path_resolver.local_slash_command_path(
                        adapter_type,
                        &safe_name,
                        Path::new(target_path),
                    ) {
                        let path_str = resolved.path.to_string_lossy().to_string();
                        desired.expected_paths.insert(
                            path_str.clone(),
                            ExpectedArtifact {
                                id: format!("command-{}", safe_name),
                                name: safe_name.clone(),
                                adapter: adapter_type,
                                artifact_type: ArtifactType::SlashCommand,
                                scope: Scope::Local,
                                repo_root: Some(PathBuf::from(target_path)),
                                content_hash: content_hash.clone(),
                                content: Some(content.clone()),
                            },
                        );
                    }
                }
            }
        }

        Ok(())
    }

    /// Compute desired state for skills.
    ///
    /// Respects per-skill `target_adapters`: when non-empty only those adapters
    /// are included; unsupported adapters are silently skipped (MCP-only fallback
    /// is handled by the MCP layer). When `target_adapters` is empty all registry-
    /// supported adapters are used (existing behaviour).
    ///
    /// For local-scope skills, `target_paths` on the skill take priority over the
    /// global repository roots when non-empty.
    async fn compute_desired_state_skills(&self, desired: &mut DesiredState) -> Result<()> {
        let skills = self.db.get_all_skills().await?;

        for skill in skills {
            if !skill.enabled {
                continue;
            }

            // Determine which adapters to target for this skill.
            let candidate_adapters: Vec<AdapterType> = if skill.target_adapters.is_empty() {
                // Default: all adapters that support skills.
                AdapterType::all()
                    .into_iter()
                    .filter(|a| {
                        REGISTRY
                            .validate_support(a, &skill.scope, ArtifactType::Skill)
                            .is_ok()
                    })
                    .collect()
            } else {
                // Per-skill: only the explicitly listed adapters (skip unsupported).
                skill
                    .target_adapters
                    .iter()
                    .filter_map(|s| crate::models::AdapterType::from_str(s))
                    .filter(|a| {
                        REGISTRY
                            .validate_support(a, &skill.scope, ArtifactType::Skill)
                            .is_ok()
                    })
                    .collect()
            };

            let content = formatter::format_skill_content(&skill);
            let content_hash = compute_content_hash(&content);
            let safe_name = crate::path_resolver::sanitize_skill_name(&skill.name);

            for adapter in candidate_adapters {
                match skill.scope {
                    Scope::Global => {
                        if let Ok(resolved) = self.path_resolver.skill_path(adapter, &safe_name) {
                            let path_str = resolved.path.to_string_lossy().to_string();
                            desired.expected_paths.insert(
                                path_str,
                                ExpectedArtifact {
                                    id: skill.id.clone(),
                                    name: skill.name.clone(),
                                    adapter,
                                    artifact_type: ArtifactType::Skill,
                                    scope: Scope::Global,
                                    repo_root: None,
                                    content_hash: content_hash.clone(),
                                    content: Some(content.clone()),
                                },
                            );
                        }
                    }
                    Scope::Local => {
                        // Per-skill target_paths take priority; fall back to global roots.
                        let roots: Vec<std::path::PathBuf> = if !skill.target_paths.is_empty() {
                            skill
                                .target_paths
                                .iter()
                                .map(std::path::PathBuf::from)
                                .collect()
                        } else {
                            self.path_resolver.repository_roots().to_vec()
                        };

                        for repo_root in &roots {
                            if let Ok(resolved) = self
                                .path_resolver
                                .local_skill_path(adapter, &safe_name, repo_root)
                            {
                                let path_str = resolved.path.to_string_lossy().to_string();
                                desired.expected_paths.insert(
                                    path_str,
                                    ExpectedArtifact {
                                        id: skill.id.clone(),
                                        name: skill.name.clone(),
                                        adapter,
                                        artifact_type: ArtifactType::Skill,
                                        scope: Scope::Local,
                                        repo_root: Some(repo_root.clone()),
                                        content_hash: content_hash.clone(),
                                        content: Some(content.clone()),
                                    },
                                );
                            }
                        }
                    }
                }
            }
        }

        Ok(())
    }

    /// Scan filesystem for actual state.
    ///
    /// This scans known paths for all adapters to find what artifacts currently exist.
    pub async fn scan_actual_state(&self) -> Result<ActualState> {
        let mut actual = ActualState::default();

        self.scan_actual_state_rules(&mut actual)?;
        self.scan_actual_state_command_stubs(&mut actual)?;
        self.scan_actual_state_slash_commands(&mut actual)?;
        self.scan_actual_state_skills(&mut actual)?;

        Ok(actual)
    }

    /// Scan for rule artifacts.
    fn scan_actual_state_rules(&self, actual: &mut ActualState) -> Result<()> {
        for adapter in AdapterType::all() {
            if let Ok(resolved) = self.path_resolver.global_path(adapter, ArtifactType::Rule) {
                if let Some(found) = self.scan_artifact_file(
                    &resolved.path,
                    Some(adapter),
                    Some(ArtifactType::Rule),
                    Scope::Global,
                )? {
                    actual
                        .found_paths
                        .insert(resolved.path.to_string_lossy().to_string(), found);
                }
            }
        }

        let repo_roots = self.path_resolver.repository_roots();
        for repo_root in repo_roots {
            for adapter in AdapterType::all() {
                if let Ok(resolved) =
                    self.path_resolver
                        .local_path(adapter, ArtifactType::Rule, repo_root)
                {
                    if let Some(found) = self.scan_artifact_file(
                        &resolved.path,
                        Some(adapter),
                        Some(ArtifactType::Rule),
                        Scope::Local,
                    )? {
                        actual
                            .found_paths
                            .insert(resolved.path.to_string_lossy().to_string(), found);
                    }
                }
            }
        }

        Ok(())
    }

    /// Scan for command stub artifacts (COMMANDS.md files).
    fn scan_actual_state_command_stubs(&self, actual: &mut ActualState) -> Result<()> {
        for adapter in AdapterType::all() {
            if let Ok(resolved) = self
                .path_resolver
                .global_path(adapter, ArtifactType::CommandStub)
            {
                if let Some(found) = self.scan_artifact_file(
                    &resolved.path,
                    Some(adapter),
                    Some(ArtifactType::CommandStub),
                    Scope::Global,
                )? {
                    actual
                        .found_paths
                        .insert(resolved.path.to_string_lossy().to_string(), found);
                }
            }
        }

        let repo_roots = self.path_resolver.repository_roots();
        for repo_root in repo_roots {
            for adapter in AdapterType::all() {
                if let Ok(resolved) =
                    self.path_resolver
                        .local_path(adapter, ArtifactType::CommandStub, repo_root)
                {
                    if let Some(found) = self.scan_artifact_file(
                        &resolved.path,
                        Some(adapter),
                        Some(ArtifactType::CommandStub),
                        Scope::Local,
                    )? {
                        actual
                            .found_paths
                            .insert(resolved.path.to_string_lossy().to_string(), found);
                    }
                }
            }
        }

        Ok(())
    }

    /// Scan for slash command artifacts.
    fn scan_actual_state_slash_commands(&self, actual: &mut ActualState) -> Result<()> {
        for adapter in AdapterType::all() {
            let entry = match REGISTRY.get(&adapter) {
                Some(e) => e,
                None => continue,
            };

            let extension = match entry.slash_command_extension {
                Some(ext) => ext,
                None => continue,
            };

            if let Some(global_dir) = entry.paths.global_commands_dir {
                let dir_path = self.path_resolver.home_dir().join(global_dir);
                self.scan_command_directory(&dir_path, adapter, extension, Scope::Global, actual)?;
            }
        }

        let repo_roots = self.path_resolver.repository_roots();
        for repo_root in repo_roots {
            for adapter in AdapterType::all() {
                let entry = match REGISTRY.get(&adapter) {
                    Some(e) => e,
                    None => continue,
                };

                let extension = match entry.slash_command_extension {
                    Some(ext) => ext,
                    None => continue,
                };

                if let Some(local_dir) = entry.paths.local_commands_dir {
                    let dir_path = repo_root.join(local_dir);
                    self.scan_command_directory(
                        &dir_path,
                        adapter,
                        extension,
                        Scope::Local,
                        actual,
                    )?;
                }
            }
        }

        Ok(())
    }

    /// Scan a directory for command files.
    fn scan_command_directory(
        &self,
        dir: &Path,
        adapter: AdapterType,
        extension: &str,
        scope: Scope,
        actual: &mut ActualState,
    ) -> Result<()> {
        if !dir.exists() {
            return Ok(());
        }

        let entries = match fs::read_dir(dir) {
            Ok(e) => e,
            Err(_) => return Ok(()),
        };

        for entry in entries {
            let entry = entry?;
            let path = entry.path();

            if path.is_file() && path.extension().map(|e| e == extension).unwrap_or(false) {
                if let Some(found) = self.scan_artifact_file(
                    &path,
                    Some(adapter),
                    Some(ArtifactType::SlashCommand),
                    scope,
                )? {
                    actual
                        .found_paths
                        .insert(path.to_string_lossy().to_string(), found);
                }
            }
        }

        Ok(())
    }

    /// Scan for skill artifacts.
    fn scan_actual_state_skills(&self, actual: &mut ActualState) -> Result<()> {
        for adapter in AdapterType::all() {
            if let Ok(resolved) = self.path_resolver.skill_dir(adapter) {
                self.scan_skill_directory(&resolved.path, adapter, Scope::Global, actual)?;
            }
        }

        let repo_roots = self.path_resolver.repository_roots();
        for repo_root in repo_roots {
            for adapter in AdapterType::all() {
                if let Ok(resolved) = self.path_resolver.local_skill_dir(adapter, repo_root) {
                    self.scan_skill_directory(&resolved.path, adapter, Scope::Local, actual)?;
                }
            }
        }

        Ok(())
    }

    /// Scan a skill directory for SKILL.md files.
    fn scan_skill_directory(
        &self,
        dir: &Path,
        adapter: AdapterType,
        scope: Scope,
        actual: &mut ActualState,
    ) -> Result<()> {
        if !dir.exists() {
            return Ok(());
        }

        let entries = match fs::read_dir(dir) {
            Ok(e) => e,
            Err(_) => return Ok(()),
        };

        for entry in entries {
            let entry = entry?;
            let path = entry.path();

            if path.is_dir() {
                let skill_filename = REGISTRY
                    .get(&adapter)
                    .map(|e| e.paths.skill_filename)
                    .unwrap_or("SKILL.md");
                let skill_file = path.join(skill_filename);
                if skill_file.exists() {
                    if let Some(found) = self.scan_artifact_file(
                        &skill_file,
                        Some(adapter),
                        Some(ArtifactType::Skill),
                        scope,
                    )? {
                        actual
                            .found_paths
                            .insert(skill_file.to_string_lossy().to_string(), found);
                    }
                }
            }
        }

        Ok(())
    }

    fn scan_artifact_file(
        &self,
        path: &Path,
        adapter: Option<AdapterType>,
        artifact_type: Option<ArtifactType>,
        scope: Scope,
    ) -> Result<Option<FoundArtifact>> {
        if !path.exists() {
            return Ok(None);
        }

        let metadata = fs::metadata(path)?;
        if metadata.len() > MAX_FILE_SIZE_BYTES {
            log::warn!(
                "Skipping artifact {}: file size {} exceeds limit of {} bytes",
                path.display(),
                metadata.len(),
                MAX_FILE_SIZE_BYTES
            );
            return Ok(None);
        }

        let content = fs::read_to_string(path)?;

        // Only track files that were created by RuleWeaver.
        // User-created custom commands/rules should NOT be touched.
        if !content.contains(RULEWEAVER_MARKER) {
            log::debug!(
                "Skipping file not managed by RuleWeaver: {}",
                path.display()
            );
            return Ok(None);
        }

        let hash = compute_content_hash(&content);

        Ok(Some(FoundArtifact {
            path: path.to_path_buf(),
            adapter,
            artifact_type,
            scope: Some(scope),
            content_hash: hash,
        }))
    }

    /// Compare desired vs actual to produce a reconciliation plan.
    pub fn plan(&self, desired: &DesiredState, actual: &ActualState) -> ReconcilePlan {
        let mut plan = ReconcilePlan::default();

        // Find paths that should exist but don't (to create)
        for (path_str, expected) in &desired.expected_paths {
            if let Some(found) = actual.found_paths.get(path_str) {
                // Path exists, check if content matches
                if found.content_hash == expected.content_hash {
                    plan.unchanged.push(PathBuf::from(path_str));
                } else {
                    plan.to_update.push(ResolvedArtifact {
                        path: PathBuf::from(path_str),
                        adapter: expected.adapter,
                        artifact_type: expected.artifact_type,
                        scope: expected.scope,
                        repo_root: expected.repo_root.clone(),
                        content_hash: expected.content_hash.clone(),
                        content: expected.content.clone(),
                    });
                }
            } else {
                // Path doesn't exist, needs to be created
                plan.to_create.push(ResolvedArtifact {
                    path: PathBuf::from(path_str),
                    adapter: expected.adapter,
                    artifact_type: expected.artifact_type,
                    scope: expected.scope,
                    repo_root: expected.repo_root.clone(),
                    content_hash: expected.content_hash.clone(),
                    content: expected.content.clone(),
                });
            }
        }

        // Find paths that exist but shouldn't (to remove - stale artifacts)
        for found in actual.found_paths.values() {
            if !desired
                .expected_paths
                .contains_key(&found.path.to_string_lossy().to_string())
            {
                plan.to_remove.push(found.clone());
            }
        }

        plan
    }

    /// Execute a reconciliation plan.
    ///
    /// If dry_run is true, no actual changes are made.
    pub async fn execute(&self, plan: &ReconcilePlan, dry_run: bool) -> Result<ReconcileResult> {
        let mut result = ReconcileResult {
            success: true,
            ..Default::default()
        };

        // Handle creates
        for artifact in &plan.to_create {
            if dry_run {
                log::info!("[DRY RUN] Would create: {}", artifact.path.display());
                result.created += 1;
            } else {
                match self.create_artifact(artifact).await {
                    Ok(()) => {
                        result.created += 1;
                        self.log_operation(
                            ReconcileOperation::Create,
                            Some(artifact.artifact_type),
                            Some(artifact.adapter),
                            Some(artifact.scope),
                            &artifact.path,
                            ReconcileResultType::Success,
                        )
                        .await;
                    }
                    Err(e) => {
                        result.success = false;
                        result.errors.push(format!(
                            "Failed to create {}: {}",
                            artifact.path.display(),
                            e
                        ));
                        self.log_operation(
                            ReconcileOperation::Create,
                            Some(artifact.artifact_type),
                            Some(artifact.adapter),
                            Some(artifact.scope),
                            &artifact.path,
                            ReconcileResultType::Failed,
                        )
                        .await;
                    }
                }
            }
        }

        // Handle updates
        for artifact in &plan.to_update {
            if dry_run {
                log::info!("[DRY RUN] Would update: {}", artifact.path.display());
                result.updated += 1;
            } else {
                match self.update_artifact(artifact).await {
                    Ok(()) => {
                        result.updated += 1;
                        self.log_operation(
                            ReconcileOperation::Update,
                            Some(artifact.artifact_type),
                            Some(artifact.adapter),
                            Some(artifact.scope),
                            &artifact.path,
                            ReconcileResultType::Success,
                        )
                        .await;
                    }
                    Err(e) => {
                        result.success = false;
                        result.errors.push(format!(
                            "Failed to update {}: {}",
                            artifact.path.display(),
                            e
                        ));
                        self.log_operation(
                            ReconcileOperation::Update,
                            Some(artifact.artifact_type),
                            Some(artifact.adapter),
                            Some(artifact.scope),
                            &artifact.path,
                            ReconcileResultType::Failed,
                        )
                        .await;
                    }
                }
            }
        }

        // Handle removes
        for artifact in &plan.to_remove {
            if dry_run {
                log::info!("[DRY RUN] Would remove: {}", artifact.path.display());
                result.removed += 1;
            } else {
                match fs::remove_file(&artifact.path) {
                    Ok(()) => {
                        result.removed += 1;
                        self.log_operation(
                            ReconcileOperation::Remove,
                            artifact.artifact_type,
                            artifact.adapter,
                            artifact.scope,
                            &artifact.path,
                            ReconcileResultType::Success,
                        )
                        .await;
                    }
                    Err(e) => {
                        result.success = false;
                        result.errors.push(format!(
                            "Failed to remove {}: {}",
                            artifact.path.display(),
                            e
                        ));
                        self.log_operation(
                            ReconcileOperation::Remove,
                            artifact.artifact_type,
                            artifact.adapter,
                            artifact.scope,
                            &artifact.path,
                            ReconcileResultType::Failed,
                        )
                        .await;
                    }
                }
            }
        }

        result.unchanged = plan.unchanged.len();

        Ok(result)
    }

    /// Full reconciliation in one call.
    ///
    /// This computes desired state, scans actual state, generates a plan, and executes it.
    pub async fn reconcile(
        &self,
        dry_run: bool,
        target_path: Option<String>,
    ) -> Result<ReconcileResult> {
        log::info!("Starting reconciliation (dry_run: {})", dry_run);

        let desired = self.compute_desired_state().await?;
        log::info!("Desired state: {} paths", desired.expected_paths.len());

        let actual = self.scan_actual_state().await?;
        log::info!("Actual state: {} paths", actual.found_paths.len());

        let mut plan = self.plan(&desired, &actual);

        if let Some(target) = target_path {
            plan.to_create
                .retain(|a| a.path.to_string_lossy() == target);
            plan.to_update
                .retain(|a| a.path.to_string_lossy() == target);
            plan.to_remove
                .retain(|a| a.path.to_string_lossy() == target);
            plan.unchanged.retain(|p| p.to_string_lossy() == target);
        }

        let result = self.execute(&plan, dry_run).await?;

        log::info!(
            "Reconciliation complete: {} created, {} updated, {} removed, {} unchanged",
            result.created,
            result.updated,
            result.removed,
            result.unchanged
        );

        Ok(result)
    }

    /// Create a single artifact with atomic write safety.
    async fn create_artifact(&self, artifact: &ResolvedArtifact) -> Result<()> {
        if let Some(parent) = artifact.path.parent() {
            fs::create_dir_all(parent)?;
        }

        let content = artifact.content.clone().unwrap_or_else(|| {
            generate_placeholder_content(&artifact.adapter, artifact.artifact_type, artifact.scope)
        });

        write_atomic(&artifact.path, &content)
    }

    /// Update a single artifact with atomic write safety.
    async fn update_artifact(&self, artifact: &ResolvedArtifact) -> Result<()> {
        let content = artifact.content.clone().unwrap_or_else(|| {
            generate_placeholder_content(&artifact.adapter, artifact.artifact_type, artifact.scope)
        });

        write_atomic(&artifact.path, &content)
    }

    /// Repair orphaned artifacts by removing them.
    ///
    /// This scans for files that exist but shouldn't and removes them.
    pub async fn repair(&self, dry_run: bool) -> Result<ReconcileResult> {
        log::info!("Starting repair (dry_run: {})", dry_run);

        let desired = self.compute_desired_state().await?;
        let actual = self.scan_actual_state().await?;
        let plan = self.plan(&desired, &actual);

        let mut result = ReconcileResult {
            success: true,
            ..Default::default()
        };

        for artifact in &plan.to_remove {
            if dry_run {
                log::info!("[DRY RUN] Would remove orphan: {}", artifact.path.display());
                result.removed += 1;
            } else {
                match fs::remove_file(&artifact.path) {
                    Ok(()) => {
                        result.removed += 1;
                        self.log_operation(
                            ReconcileOperation::Remove,
                            artifact.artifact_type,
                            artifact.adapter,
                            artifact.scope,
                            &artifact.path,
                            ReconcileResultType::Success,
                        )
                        .await;
                    }
                    Err(e) => {
                        result.success = false;
                        result.errors.push(format!(
                            "Failed to remove orphan {}: {}",
                            artifact.path.display(),
                            e
                        ));
                    }
                }
            }
        }

        result.unchanged = plan.unchanged.len();
        log::info!("Repair complete: {} orphans removed", result.removed);

        Ok(result)
    }

    /// Check if reconciliation is needed.
    pub async fn needs_reconciliation(&self) -> Result<bool> {
        let desired = self.compute_desired_state().await?;
        let actual = self.scan_actual_state().await?;
        let plan = self.plan(&desired, &actual);
        Ok(!plan.to_create.is_empty() || !plan.to_update.is_empty() || !plan.to_remove.is_empty())
    }

    /// Get stale artifact paths for display.
    pub async fn get_stale_paths(&self) -> Result<Vec<FoundArtifact>> {
        let desired = self.compute_desired_state().await?;
        let actual = self.scan_actual_state().await?;
        let plan = self.plan(&desired, &actual);
        Ok(plan.to_remove)
    }

    /// Log a reconciliation operation to both console and database.
    async fn log_operation(
        &self,
        operation: ReconcileOperation,
        artifact_type: Option<ArtifactType>,
        adapter: Option<AdapterType>,
        scope: Option<Scope>,
        path: &Path,
        result: ReconcileResultType,
    ) {
        log::debug!(
            "Reconciliation log: op={:?}, type={:?}, adapter={:?}, scope={:?}, path={:?}, result={:?}",
            operation,
            artifact_type,
            adapter,
            scope,
            path,
            result
        );

        let _ = self
            .db
            .log_reconciliation(
                operation,
                artifact_type.map(|a| a.as_str()),
                adapter,
                scope,
                &path.to_string_lossy(),
                result,
                None,
            )
            .await;
    }
}

/// Compute a content hash.
fn compute_content_hash(content: &str) -> String {
    use sha2::{Digest, Sha256};
    let mut hasher = Sha256::new();
    hasher.update(content.as_bytes());
    format!("{:x}", hasher.finalize())
}

/// Write content to a file atomically using temp file + rename.
///
/// This ensures that:
/// 1. Partial writes don't corrupt existing files
/// 2. Readers never see incomplete content
/// 3. Crashes during write leave either old or new content, never corrupted
fn write_atomic(path: &Path, content: &str) -> Result<()> {
    let temp_path = path.with_extension("tmp");

    fs::write(&temp_path, content).map_err(crate::error::AppError::Io)?;

    fs::rename(&temp_path, path).map_err(|e| {
        let _ = fs::remove_file(&temp_path);
        crate::error::AppError::Io(e)
    })?;

    Ok(())
}

/// Generate placeholder content for an artifact.
fn generate_placeholder_content(
    adapter: &AdapterType,
    artifact_type: ArtifactType,
    scope: Scope,
) -> String {
    format!(
        "# Generated by RuleWeaver\n# Adapter: {}\n# Artifact: {:?}\n# Scope: {:?}\n",
        adapter.as_str(),
        artifact_type,
        scope
    )
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::database::ReconciliationLogEntry;

    #[test]
    fn test_content_hash() {
        let hash1 = compute_content_hash("test content");
        let hash2 = compute_content_hash("test content");
        let hash3 = compute_content_hash("different content");

        assert_eq!(hash1, hash2);
        assert_ne!(hash1, hash3);
    }

    #[tokio::test]
    async fn test_reconcile_plan_empty() {
        let db = crate::database::Database::new_in_memory().await.unwrap();
        let engine = ReconciliationEngine::new(std::sync::Arc::new(db)).unwrap();
        let desired = DesiredState::default();
        let actual = ActualState::default();

        let plan = engine.plan(&desired, &actual);

        assert!(plan.to_create.is_empty());
        assert!(plan.to_update.is_empty());
        assert!(plan.to_remove.is_empty());
        assert!(plan.unchanged.is_empty());
    }

    #[tokio::test]
    async fn test_plan_detects_creates() {
        let db = std::sync::Arc::new(crate::database::Database::new_in_memory().await.unwrap());
        let engine = ReconciliationEngine::new(db).unwrap();

        let mut desired = DesiredState::default();
        desired.expected_paths.insert(
            "/new/path.md".to_string(),
            ExpectedArtifact {
                id: "rule-1".to_string(),
                name: "Rule 1".to_string(),
                adapter: AdapterType::ClaudeCode,
                artifact_type: ArtifactType::Rule,
                scope: Scope::Global,
                repo_root: None,
                content_hash: "hash123".to_string(),
                content: Some("content".to_string()),
            },
        );

        let actual = ActualState::default();
        let plan = engine.plan(&desired, &actual);

        assert_eq!(plan.to_create.len(), 1);
        assert!(plan.to_update.is_empty());
        assert!(plan.to_remove.is_empty());
    }

    #[tokio::test]
    async fn test_plan_detects_updates() {
        let db = std::sync::Arc::new(crate::database::Database::new_in_memory().await.unwrap());
        let engine = ReconciliationEngine::new(db).unwrap();

        let mut desired = DesiredState::default();
        desired.expected_paths.insert(
            "/existing/path.md".to_string(),
            ExpectedArtifact {
                id: "rule-1".to_string(),
                name: "Rule 1".to_string(),
                adapter: AdapterType::ClaudeCode,
                artifact_type: ArtifactType::Rule,
                scope: Scope::Global,
                repo_root: None,
                content_hash: "new_hash".to_string(),
                content: Some("new content".to_string()),
            },
        );

        let mut actual = ActualState::default();
        actual.found_paths.insert(
            "/existing/path.md".to_string(),
            FoundArtifact {
                path: PathBuf::from("/existing/path.md"),
                adapter: Some(AdapterType::ClaudeCode),
                artifact_type: Some(ArtifactType::Rule),
                scope: Some(Scope::Global),
                content_hash: "old_hash".to_string(),
            },
        );

        let plan = engine.plan(&desired, &actual);

        assert!(plan.to_create.is_empty());
        assert_eq!(plan.to_update.len(), 1);
        assert!(plan.to_remove.is_empty());
    }

    #[tokio::test]
    async fn test_plan_detects_removes() {
        let db = std::sync::Arc::new(crate::database::Database::new_in_memory().await.unwrap());
        let engine = ReconciliationEngine::new(db).unwrap();

        let desired = DesiredState::default();

        let mut actual = ActualState::default();
        actual.found_paths.insert(
            "/stale/path.md".to_string(),
            FoundArtifact {
                path: PathBuf::from("/stale/path.md"),
                adapter: Some(AdapterType::ClaudeCode),
                artifact_type: Some(ArtifactType::Rule),
                scope: Some(Scope::Global),
                content_hash: "hash".to_string(),
            },
        );

        let plan = engine.plan(&desired, &actual);

        assert!(plan.to_create.is_empty());
        assert!(plan.to_update.is_empty());
        assert_eq!(plan.to_remove.len(), 1);
        assert_eq!(plan.to_remove[0].path, PathBuf::from("/stale/path.md"));
    }

    #[tokio::test]
    async fn test_plan_detects_unchanged() {
        let db = std::sync::Arc::new(crate::database::Database::new_in_memory().await.unwrap());
        let engine = ReconciliationEngine::new(db).unwrap();

        let mut desired = DesiredState::default();
        desired.expected_paths.insert(
            "/existing/path.md".to_string(),
            ExpectedArtifact {
                id: "rule-1".to_string(),
                name: "Rule 1".to_string(),
                adapter: AdapterType::ClaudeCode,
                artifact_type: ArtifactType::Rule,
                scope: Scope::Global,
                repo_root: None,
                content_hash: "same_hash".to_string(),
                content: Some("content".to_string()),
            },
        );

        let mut actual = ActualState::default();
        actual.found_paths.insert(
            "/existing/path.md".to_string(),
            FoundArtifact {
                path: PathBuf::from("/existing/path.md"),
                adapter: Some(AdapterType::ClaudeCode),
                artifact_type: Some(ArtifactType::Rule),
                scope: Some(Scope::Global),
                content_hash: "same_hash".to_string(),
            },
        );

        let plan = engine.plan(&desired, &actual);

        assert!(plan.to_create.is_empty());
        assert!(plan.to_update.is_empty());
        assert!(plan.to_remove.is_empty());
        assert_eq!(plan.unchanged.len(), 1);
    }

    #[tokio::test]
    async fn test_plan_mixed_operations() {
        let db = std::sync::Arc::new(crate::database::Database::new_in_memory().await.unwrap());
        let engine = ReconciliationEngine::new(db).unwrap();

        let mut desired = DesiredState::default();
        desired.expected_paths.insert(
            "/new/path.md".to_string(),
            ExpectedArtifact {
                id: "new-rule".to_string(),
                name: "New Rule".to_string(),
                adapter: AdapterType::ClaudeCode,
                artifact_type: ArtifactType::Rule,
                scope: Scope::Global,
                repo_root: None,
                content_hash: "hash1".to_string(),
                content: Some("new".to_string()),
            },
        );
        desired.expected_paths.insert(
            "/update/path.md".to_string(),
            ExpectedArtifact {
                id: "update-rule".to_string(),
                name: "Update Rule".to_string(),
                adapter: AdapterType::ClaudeCode,
                artifact_type: ArtifactType::Rule,
                scope: Scope::Global,
                repo_root: None,
                content_hash: "hash2_new".to_string(),
                content: Some("updated".to_string()),
            },
        );
        desired.expected_paths.insert(
            "/unchanged/path.md".to_string(),
            ExpectedArtifact {
                id: "unchanged-rule".to_string(),
                name: "Unchanged Rule".to_string(),
                adapter: AdapterType::ClaudeCode,
                artifact_type: ArtifactType::Rule,
                scope: Scope::Global,
                repo_root: None,
                content_hash: "hash3".to_string(),
                content: Some("same".to_string()),
            },
        );

        let mut actual = ActualState::default();
        actual.found_paths.insert(
            "/update/path.md".to_string(),
            FoundArtifact {
                path: PathBuf::from("/update/path.md"),
                adapter: Some(AdapterType::ClaudeCode),
                artifact_type: Some(ArtifactType::Rule),
                scope: Some(Scope::Global),
                content_hash: "hash2_old".to_string(),
            },
        );
        actual.found_paths.insert(
            "/unchanged/path.md".to_string(),
            FoundArtifact {
                path: PathBuf::from("/unchanged/path.md"),
                adapter: Some(AdapterType::ClaudeCode),
                artifact_type: Some(ArtifactType::Rule),
                scope: Some(Scope::Global),
                content_hash: "hash3".to_string(),
            },
        );
        actual.found_paths.insert(
            "/stale/path.md".to_string(),
            FoundArtifact {
                path: PathBuf::from("/stale/path.md"),
                adapter: Some(AdapterType::ClaudeCode),
                artifact_type: Some(ArtifactType::Rule),
                scope: Some(Scope::Global),
                content_hash: "stale_hash".to_string(),
            },
        );

        let plan = engine.plan(&desired, &actual);

        assert_eq!(plan.to_create.len(), 1);
        assert_eq!(plan.to_update.len(), 1);
        assert_eq!(plan.to_remove.len(), 1);
        assert_eq!(plan.unchanged.len(), 1);
    }

    #[test]
    fn test_found_artifact_scope_preserved() {
        let artifact = FoundArtifact {
            path: PathBuf::from("/local/path.md"),
            adapter: Some(AdapterType::ClaudeCode),
            artifact_type: Some(ArtifactType::Rule),
            scope: Some(Scope::Local),
            content_hash: "hash".to_string(),
        };

        assert_eq!(artifact.scope, Some(Scope::Local));
    }

    #[tokio::test]
    async fn test_execute_dry_run_no_changes() {
        let db = crate::database::Database::new_in_memory().await.unwrap();
        let engine = ReconciliationEngine::new(std::sync::Arc::new(db)).unwrap();

        let mut plan = ReconcilePlan::default();
        plan.to_create.push(ResolvedArtifact {
            path: PathBuf::from("/nonexistent/path.md"),
            adapter: AdapterType::ClaudeCode,
            artifact_type: ArtifactType::Rule,
            scope: Scope::Global,
            repo_root: None,
            content_hash: "hash".to_string(),
            content: Some("content".to_string()),
        });

        let result = engine.execute(&plan, true).await.unwrap();

        assert!(result.success);
        assert_eq!(result.created, 1);
        assert!(!PathBuf::from("/nonexistent/path.md").exists());
    }

    #[test]
    fn test_reconciliation_log_entry_serialization() {
        let entry = ReconciliationLogEntry {
            id: "test-id".to_string(),
            timestamp: chrono::Utc::now(),
            operation: ReconcileOperation::Create,
            artifact_type: Some("rule".to_string()),
            adapter: Some(AdapterType::ClaudeCode),
            scope: Some(Scope::Global),
            path: "/test/path.md".to_string(),
            result: ReconcileResultType::Success,
            error_message: None,
        };

        let json = serde_json::to_string(&entry).unwrap();
        assert!(json.contains("create"));
        assert!(json.contains("rule"));
        assert!(json.contains("claudecode"));
    }

    #[tokio::test]
    async fn test_compute_desired_state_includes_command_stubs() {
        let db = std::sync::Arc::new(crate::database::Database::new_in_memory().await.unwrap());

        db.create_command(crate::models::CreateCommandInput {
            id: None,
            name: "Test Command".to_string(),
            description: "A test command".to_string(),
            script: "echo test".to_string(),
            arguments: vec![],
            expose_via_mcp: true,
            is_placeholder: false,
            generate_slash_commands: false,
            slash_command_adapters: vec![],
            target_paths: vec![],
            timeout_ms: None,
            max_retries: None,
        })
        .await
        .unwrap();

        let engine = ReconciliationEngine::new(db).unwrap();
        let desired = engine.compute_desired_state().await.unwrap();

        let has_command_stub = desired
            .expected_paths
            .values()
            .any(|a| a.artifact_type == ArtifactType::CommandStub);
        assert!(
            has_command_stub,
            "Desired state should include command stub artifacts"
        );
    }

    #[tokio::test]
    async fn test_compute_desired_state_includes_slash_commands() {
        let db = std::sync::Arc::new(crate::database::Database::new_in_memory().await.unwrap());

        db.create_command(crate::models::CreateCommandInput {
            id: None,
            name: "Test Slash Command".to_string(),
            description: "A test slash command".to_string(),
            script: "echo test".to_string(),
            arguments: vec![],
            expose_via_mcp: false,
            is_placeholder: false,
            generate_slash_commands: true,
            slash_command_adapters: vec!["claude-code".to_string()],
            target_paths: vec![],
            timeout_ms: None,
            max_retries: None,
        })
        .await
        .unwrap();

        let engine = ReconciliationEngine::new(db).unwrap();
        let desired = engine.compute_desired_state().await.unwrap();

        let has_slash_command = desired
            .expected_paths
            .values()
            .any(|a| a.artifact_type == ArtifactType::SlashCommand);
        assert!(
            has_slash_command,
            "Desired state should include slash command artifacts"
        );
    }

    #[tokio::test]
    async fn test_compute_desired_state_includes_skills() {
        let db = std::sync::Arc::new(crate::database::Database::new_in_memory().await.unwrap());

        db.create_skill(crate::models::CreateSkillInput {
            id: None,
            name: "Test Skill".to_string(),
            description: "A test skill".to_string(),
            instructions: "echo test".to_string(),
            scope: crate::models::Scope::Global,
            input_schema: vec![],
            directory_path: "/test/skills".to_string(),
            entry_point: "main.sh".to_string(),
            enabled: true,
            ..Default::default()
        })
        .await
        .unwrap();

        let engine = ReconciliationEngine::new(db).unwrap();
        let desired = engine.compute_desired_state().await.unwrap();

        let has_skill = desired
            .expected_paths
            .values()
            .any(|a| a.artifact_type == ArtifactType::Skill);
        assert!(has_skill, "Desired state should include skill artifacts");
    }

    #[tokio::test]
    async fn test_reconcile_all_artifact_types() {
        let db = std::sync::Arc::new(crate::database::Database::new_in_memory().await.unwrap());
        let engine = ReconciliationEngine::new(db).unwrap();

        let result = engine.reconcile(true, None).await.unwrap();

        assert!(result.success, "Dry-run reconciliation should succeed");
    }

    #[tokio::test]
    async fn test_reconcile_is_idempotent() {
        let db = std::sync::Arc::new(crate::database::Database::new_in_memory().await.unwrap());
        let engine = ReconciliationEngine::new(db.clone()).unwrap();

        // First run on empty database
        let r1 = engine.reconcile(false, None).await.unwrap();
        assert!(r1.success);

        // Second run should be a no-op (no changes)
        let engine2 = ReconciliationEngine::new(db).unwrap();
        let r2 = engine2.reconcile(false, None).await.unwrap();
        assert!(r2.success);
        assert_eq!(r2.created, 0, "Second run should not create anything");
        assert_eq!(r2.updated, 0, "Second run should not update anything");
        assert_eq!(r2.removed, 0, "Second run should not remove anything");
    }

    #[tokio::test]
    async fn test_needs_reconciliation_empty_db() {
        let db = std::sync::Arc::new(crate::database::Database::new_in_memory().await.unwrap());
        let engine = ReconciliationEngine::new(db).unwrap();

        // An empty database may still need reconciliation if there are stale files on disk
        // This is expected behavior - we check that the method works without error
        let _needs = engine.needs_reconciliation().await.unwrap();
    }

    #[tokio::test]
    async fn test_get_stale_paths_returns_vec() {
        let db = std::sync::Arc::new(crate::database::Database::new_in_memory().await.unwrap());
        let engine = ReconciliationEngine::new(db).unwrap();

        // Verify the method returns successfully (no panic/error)
        let stale = engine.get_stale_paths().await.unwrap();
        // The result depends on what files exist on disk, we just verify the method works
        println!("Found {} stale paths", stale.len());
    }

    #[tokio::test]
    async fn test_repair_dry_run_safe() {
        let db = std::sync::Arc::new(crate::database::Database::new_in_memory().await.unwrap());
        let engine = ReconciliationEngine::new(db).unwrap();

        // Dry-run should succeed regardless of filesystem state
        let result = engine.repair(true).await.unwrap();
        assert!(result.success, "Dry-run repair should succeed");
    }

    #[test]
    fn test_reconcile_result_has_warnings() {
        let mut result = ReconcileResult::default();
        result.warnings.push("Test warning".to_string());
        assert_eq!(result.warnings.len(), 1);
    }

    #[test]
    fn test_scan_skips_non_ruleweaver_files() {
        use tempfile::TempDir;

        let temp_dir = TempDir::new().unwrap();
        let ruleweaver_file = temp_dir.path().join("managed.md");
        let user_file = temp_dir.path().join("custom.md");

        // File managed by RuleWeaver (has marker)
        fs::write(
            &ruleweaver_file,
            "# Generated by RuleWeaver\n\nSome content",
        )
        .unwrap();

        // User-created file (no marker)
        fs::write(&user_file, "# My Custom Command\n\nCustom content").unwrap();

        // Create a runtime for async database creation
        let rt = tokio::runtime::Runtime::new().unwrap();
        let db = rt.block_on(async {
            std::sync::Arc::new(crate::database::Database::new_in_memory().await.unwrap())
        });
        let engine = ReconciliationEngine::new(db).unwrap();

        // Scan the RuleWeaver-managed file
        let result = engine
            .scan_artifact_file(
                &ruleweaver_file,
                Some(AdapterType::ClaudeCode),
                Some(ArtifactType::Rule),
                Scope::Global,
            )
            .unwrap();
        assert!(result.is_some(), "Should include RuleWeaver-managed file");

        // Scan the user-created file
        let result = engine
            .scan_artifact_file(
                &user_file,
                Some(AdapterType::ClaudeCode),
                Some(ArtifactType::Rule),
                Scope::Global,
            )
            .unwrap();
        assert!(result.is_none(), "Should NOT include user-created file");
    }

    #[test]
    fn test_reconciliation_never_removes_user_files() {
        use tempfile::TempDir;

        let temp_dir = TempDir::new().unwrap();
        let user_file = temp_dir.path().join("my-custom-command.md");

        // User-created slash command (no RuleWeaver marker)
        fs::write(
            &user_file,
            "# My Custom Command\n\nThis is my custom workflow.",
        )
        .unwrap();

        let rt = tokio::runtime::Runtime::new().unwrap();
        let db = rt.block_on(async {
            std::sync::Arc::new(crate::database::Database::new_in_memory().await.unwrap())
        });
        let engine = ReconciliationEngine::new(db).unwrap();

        // Create a desired state with NO artifacts (empty database)
        let desired = DesiredState::default();

        // Create actual state by scanning - user file should be SKIPPED
        let actual = ActualState::default();

        // Directly scan the user file
        let scanned = engine
            .scan_artifact_file(
                &user_file,
                Some(AdapterType::ClaudeCode),
                Some(ArtifactType::SlashCommand),
                Scope::Global,
            )
            .unwrap();

        // User file should NOT be in the scanned results
        assert!(
            scanned.is_none(),
            "User files must never be scanned as RuleWeaver artifacts"
        );

        // Since actual is empty, the plan should have nothing to remove
        let plan = engine.plan(&desired, &actual);
        assert!(
            plan.to_remove.is_empty(),
            "Plan should not have user files to remove"
        );

        // Verify the user file still exists
        assert!(user_file.exists(), "User file should never be touched");
    }

    #[test]
    fn test_marker_detection_happy_paths() {
        use tempfile::TempDir;

        let temp_dir = TempDir::new().unwrap();
        let rt = tokio::runtime::Runtime::new().unwrap();
        let db = rt.block_on(async {
            std::sync::Arc::new(crate::database::Database::new_in_memory().await.unwrap())
        });
        let engine = ReconciliationEngine::new(db).unwrap();

        // Test 1: Marker at start of file (standard format)
        let file1 = temp_dir.path().join("standard.md");
        fs::write(
            &file1,
            "# Generated by RuleWeaver - Do not edit manually\n\nContent here",
        )
        .unwrap();
        assert!(engine
            .scan_artifact_file(&file1, None, None, Scope::Global)
            .unwrap()
            .is_some());

        // Test 2: Marker in comment block
        let file2 = temp_dir.path().join("commented.md");
        fs::write(&file2, "<!-- Generated by RuleWeaver -->\n# Title\nContent").unwrap();
        assert!(engine
            .scan_artifact_file(&file2, None, None, Scope::Global)
            .unwrap()
            .is_some());

        // Test 3: Marker in middle of file (still valid)
        let file3 = temp_dir.path().join("middle.md");
        fs::write(&file3, "# Title\n\nGenerated by RuleWeaver\n\nMore content").unwrap();
        assert!(engine
            .scan_artifact_file(&file3, None, None, Scope::Global)
            .unwrap()
            .is_some());

        // Test 4: Marker at end of file
        let file4 = temp_dir.path().join("end.md");
        fs::write(&file4, "# Title\n\nContent\n\nGenerated by RuleWeaver").unwrap();
        assert!(engine
            .scan_artifact_file(&file4, None, None, Scope::Global)
            .unwrap()
            .is_some());
    }

    #[test]
    fn test_marker_detection_error_paths() {
        use tempfile::TempDir;

        let temp_dir = TempDir::new().unwrap();
        let rt = tokio::runtime::Runtime::new().unwrap();
        let db = rt.block_on(async {
            std::sync::Arc::new(crate::database::Database::new_in_memory().await.unwrap())
        });
        let engine = ReconciliationEngine::new(db).unwrap();

        // Test 1: Empty file - should skip
        let file1 = temp_dir.path().join("empty.md");
        fs::write(&file1, "").unwrap();
        assert!(engine
            .scan_artifact_file(&file1, None, None, Scope::Global)
            .unwrap()
            .is_none());

        // Test 2: User file with similar but not exact marker
        let file2 = temp_dir.path().join("similar.md");
        fs::write(&file2, "# Generated by MyTool\n\nContent").unwrap();
        assert!(engine
            .scan_artifact_file(&file2, None, None, Scope::Global)
            .unwrap()
            .is_none());

        // Test 3: User file mentioning RuleWeaver but not as generator
        let file3 = temp_dir.path().join("mention.md");
        fs::write(
            &file3,
            "# My Workflow\n\nInspired by RuleWeaver docs\n\nContent",
        )
        .unwrap();
        assert!(engine
            .scan_artifact_file(&file3, None, None, Scope::Global)
            .unwrap()
            .is_none());

        // Test 4: Partial marker (typo)
        let file4 = temp_dir.path().join("partial.md");
        fs::write(&file4, "# Generated by RuleWeavr\n\nContent").unwrap();
        assert!(engine
            .scan_artifact_file(&file4, None, None, Scope::Global)
            .unwrap()
            .is_none());

        // Test 5: Only whitespace
        let file5 = temp_dir.path().join("whitespace.md");
        fs::write(&file5, "   \n\t\n   ").unwrap();
        assert!(engine
            .scan_artifact_file(&file5, None, None, Scope::Global)
            .unwrap()
            .is_none());
    }

    #[test]
    fn test_scan_nonexistent_file() {
        let rt = tokio::runtime::Runtime::new().unwrap();
        let db = rt.block_on(async {
            std::sync::Arc::new(crate::database::Database::new_in_memory().await.unwrap())
        });
        let engine = ReconciliationEngine::new(db).unwrap();

        // Scanning a file that doesn't exist should return None without error
        let result = engine.scan_artifact_file(
            Path::new("/nonexistent/path/file.md"),
            None,
            None,
            Scope::Global,
        );
        assert!(result.is_ok(), "Should not error on nonexistent file");
        assert!(
            result.unwrap().is_none(),
            "Should return None for nonexistent file"
        );
    }

    #[test]
    fn test_plan_with_mixed_ruleweaver_and_user_files() {
        use tempfile::TempDir;

        let temp_dir = TempDir::new().unwrap();
        let rw_file = temp_dir.path().join("ruleweaver-managed.md");
        let user_file = temp_dir.path().join("user-custom.md");

        fs::write(&rw_file, "# Generated by RuleWeaver\n\nManaged content").unwrap();
        fs::write(&user_file, "# My Custom Workflow\n\nCustom content").unwrap();

        let rt = tokio::runtime::Runtime::new().unwrap();
        let db = rt.block_on(async {
            std::sync::Arc::new(crate::database::Database::new_in_memory().await.unwrap())
        });
        let engine = ReconciliationEngine::new(db).unwrap();

        // Scan both files - only RuleWeaver file should be included
        let mut actual = ActualState::default();

        let rw_result = engine
            .scan_artifact_file(
                &rw_file,
                Some(AdapterType::ClaudeCode),
                Some(ArtifactType::SlashCommand),
                Scope::Global,
            )
            .unwrap();

        let user_result = engine
            .scan_artifact_file(
                &user_file,
                Some(AdapterType::ClaudeCode),
                Some(ArtifactType::SlashCommand),
                Scope::Global,
            )
            .unwrap();

        assert!(rw_result.is_some(), "RuleWeaver file should be scanned");
        assert!(user_result.is_none(), "User file should NOT be scanned");

        // If we add the RuleWeaver file to actual and have empty desired,
        // it should appear in to_remove (correct behavior - it's stale)
        if let Some(found) = rw_result {
            actual
                .found_paths
                .insert(rw_file.to_string_lossy().to_string(), found);
        }

        let desired = DesiredState::default();
        let plan = engine.plan(&desired, &actual);

        // RuleWeaver file should be in to_remove (stale managed file)
        assert_eq!(plan.to_remove.len(), 1);

        // User file is never in actual, so never in to_remove
        let user_file_in_remove = plan.to_remove.iter().any(|f| f.path == user_file);
        assert!(
            !user_file_in_remove,
            "User file should never appear in to_remove"
        );
    }

    // =====================================
    // RULE ARTIFACT TESTS (Global/Local)
    // =====================================

    #[test]
    fn test_rule_global_happy_path() {
        let rt = tokio::runtime::Runtime::new().unwrap();
        let db = rt.block_on(async {
            let db = std::sync::Arc::new(crate::database::Database::new_in_memory().await.unwrap());

            db.create_rule(crate::models::CreateRuleInput {
                id: None,
                name: "Test Global Rule".to_string(),
                description: "A test rule".to_string(),
                content: "# Test Rule\n\nThis is a global test rule.".to_string(),
                scope: Scope::Global,
                enabled_adapters: vec![AdapterType::ClaudeCode, AdapterType::OpenCode],
                target_paths: None,
                enabled: true,
            })
            .await
            .unwrap();

            db
        });

        let engine = ReconciliationEngine::new(db).unwrap();
        let desired = rt.block_on(async { engine.compute_desired_state().await.unwrap() });

        // Should have entries for both adapters
        let rule_entries: Vec<_> = desired
            .expected_paths
            .values()
            .filter(|a| a.artifact_type == ArtifactType::Rule)
            .collect();

        assert!(!rule_entries.is_empty(), "Should have rule entries");

        for entry in &rule_entries {
            assert_eq!(entry.scope, Scope::Global);
        }
    }

    #[test]
    fn test_rule_local_happy_path() {
        let rt = tokio::runtime::Runtime::new().unwrap();
        let db = rt.block_on(async {
            let db = std::sync::Arc::new(crate::database::Database::new_in_memory().await.unwrap());

            db.create_rule(crate::models::CreateRuleInput {
                id: None,
                name: "Test Local Rule".to_string(),
                description: "A local test rule".to_string(),
                content: "# Local Rule\n\nThis is a local test rule.".to_string(),
                scope: Scope::Local,
                enabled_adapters: vec![AdapterType::ClaudeCode],
                target_paths: Some(vec!["/test/repo".to_string()]),
                enabled: true,
            })
            .await
            .unwrap();

            db
        });

        let engine = ReconciliationEngine::new(db).unwrap();
        let desired = rt.block_on(async { engine.compute_desired_state().await.unwrap() });

        let rule_entries: Vec<_> = desired
            .expected_paths
            .values()
            .filter(|a| a.artifact_type == ArtifactType::Rule)
            .collect();

        assert!(!rule_entries.is_empty(), "Should have local rule entries");

        for entry in &rule_entries {
            assert_eq!(entry.scope, Scope::Local);
            assert!(entry.repo_root.is_some());
        }
    }

    #[test]
    fn test_rule_disabled_not_in_desired_state() {
        let rt = tokio::runtime::Runtime::new().unwrap();
        let db = rt.block_on(async {
            let db = std::sync::Arc::new(crate::database::Database::new_in_memory().await.unwrap());

            // Create disabled rule
            let rule = db
                .create_rule(crate::models::CreateRuleInput {
                    id: None,
                    name: "Disabled Rule".to_string(),
                    description: "A disabled rule".to_string(),
                    content: "# Disabled\n\nContent".to_string(),
                    scope: Scope::Global,
                    enabled_adapters: vec![AdapterType::ClaudeCode],
                    target_paths: None,
                    enabled: true,
                })
                .await
                .unwrap();

            db.toggle_rule(&rule.id, false).await.unwrap();

            db
        });

        let engine = ReconciliationEngine::new(db).unwrap();
        let desired = rt.block_on(async { engine.compute_desired_state().await.unwrap() });

        let rule_entries: Vec<_> = desired
            .expected_paths
            .values()
            .filter(|a| a.artifact_type == ArtifactType::Rule)
            .collect();

        assert!(
            rule_entries.is_empty(),
            "Disabled rules should not be in desired state"
        );
    }

    // =====================================
    // SLASH COMMAND ARTIFACT TESTS
    // =====================================

    #[test]
    fn test_slash_command_global_happy_path() {
        let rt = tokio::runtime::Runtime::new().unwrap();
        let db = rt.block_on(async {
            let db = std::sync::Arc::new(crate::database::Database::new_in_memory().await.unwrap());

            db.create_command(crate::models::CreateCommandInput {
                id: None,
                name: "Test Command".to_string(),
                description: "A test command".to_string(),
                script: "echo 'test'".to_string(),
                arguments: vec![],
                expose_via_mcp: false,
                is_placeholder: false,
                generate_slash_commands: true,
                slash_command_adapters: vec!["claude-code".to_string(), "opencode".to_string()],
                target_paths: vec![],
                timeout_ms: None,
                max_retries: None,
            })
            .await
            .unwrap();

            db
        });

        let engine = ReconciliationEngine::new(db).unwrap();
        let desired = rt.block_on(async { engine.compute_desired_state().await.unwrap() });

        let slash_entries: Vec<_> = desired
            .expected_paths
            .values()
            .filter(|a| a.artifact_type == ArtifactType::SlashCommand)
            .collect();

        assert!(
            !slash_entries.is_empty(),
            "Should have slash command entries"
        );

        for entry in &slash_entries {
            assert_eq!(entry.scope, Scope::Global);
        }
    }

    #[test]
    fn test_slash_command_local_happy_path() {
        let rt = tokio::runtime::Runtime::new().unwrap();
        let db = rt.block_on(async {
            let db = std::sync::Arc::new(crate::database::Database::new_in_memory().await.unwrap());

            db.create_command(crate::models::CreateCommandInput {
                id: None,
                name: "Local Command".to_string(),
                description: "A local command".to_string(),
                script: "echo 'local'".to_string(),
                arguments: vec![],
                expose_via_mcp: false,
                is_placeholder: false,
                generate_slash_commands: true,
                slash_command_adapters: vec!["claude-code".to_string()],
                target_paths: vec!["/test/repo".to_string()],
                timeout_ms: None,
                max_retries: None,
            })
            .await
            .unwrap();

            db
        });

        let engine = ReconciliationEngine::new(db).unwrap();
        let desired = rt.block_on(async { engine.compute_desired_state().await.unwrap() });

        let slash_entries: Vec<_> = desired
            .expected_paths
            .values()
            .filter(|a| a.artifact_type == ArtifactType::SlashCommand)
            .collect();

        assert!(
            !slash_entries.is_empty(),
            "Should have local slash command entries"
        );

        let local_entries: Vec<_> = slash_entries
            .iter()
            .filter(|e| e.scope == Scope::Local)
            .collect();
        assert!(!local_entries.is_empty(), "Should have local scope entries");
    }

    #[test]
    fn test_slash_command_not_generated_when_disabled() {
        let rt = tokio::runtime::Runtime::new().unwrap();
        let db = rt.block_on(async {
            let db = std::sync::Arc::new(crate::database::Database::new_in_memory().await.unwrap());

            // Command with generate_slash_commands = false
            db.create_command(crate::models::CreateCommandInput {
                id: None,
                name: "No Slash Command".to_string(),
                description: "A command without slash commands".to_string(),
                script: "echo 'no slash'".to_string(),
                arguments: vec![],
                expose_via_mcp: true,
                is_placeholder: false,
                generate_slash_commands: false,
                slash_command_adapters: vec![],
                target_paths: vec![],
                timeout_ms: None,
                max_retries: None,
            })
            .await
            .unwrap();

            db
        });

        let engine = ReconciliationEngine::new(db).unwrap();
        let desired = rt.block_on(async { engine.compute_desired_state().await.unwrap() });

        let slash_entries: Vec<_> = desired
            .expected_paths
            .values()
            .filter(|a| a.artifact_type == ArtifactType::SlashCommand)
            .collect();

        assert!(
            slash_entries.is_empty(),
            "Should not have slash command entries when disabled"
        );
    }

    // =====================================
    // COMMAND STUB ARTIFACT TESTS
    // =====================================

    #[test]
    fn test_command_stub_global_happy_path() {
        let rt = tokio::runtime::Runtime::new().unwrap();
        let db = rt.block_on(async {
            let db = std::sync::Arc::new(crate::database::Database::new_in_memory().await.unwrap());

            db.create_command(crate::models::CreateCommandInput {
                id: None,
                name: "MCP Command".to_string(),
                description: "A command exposed via MCP".to_string(),
                script: "echo 'mcp'".to_string(),
                arguments: vec![],
                expose_via_mcp: true,
                is_placeholder: false,
                generate_slash_commands: false,
                slash_command_adapters: vec![],
                target_paths: vec![],
                timeout_ms: None,
                max_retries: None,
            })
            .await
            .unwrap();

            db
        });

        let engine = ReconciliationEngine::new(db).unwrap();
        let desired = rt.block_on(async { engine.compute_desired_state().await.unwrap() });

        let stub_entries: Vec<_> = desired
            .expected_paths
            .values()
            .filter(|a| a.artifact_type == ArtifactType::CommandStub)
            .collect();

        assert!(
            !stub_entries.is_empty(),
            "Should have command stub entries when expose_via_mcp is true"
        );
    }

    #[test]
    fn test_command_stub_not_created_when_mcp_disabled() {
        let rt = tokio::runtime::Runtime::new().unwrap();
        let db = rt.block_on(async {
            let db = std::sync::Arc::new(crate::database::Database::new_in_memory().await.unwrap());

            db.create_command(crate::models::CreateCommandInput {
                id: None,
                name: "Non-MCP Command".to_string(),
                description: "A command not exposed via MCP".to_string(),
                script: "echo 'not mcp'".to_string(),
                arguments: vec![],
                expose_via_mcp: false,
                is_placeholder: false,
                generate_slash_commands: false,
                slash_command_adapters: vec![],
                target_paths: vec![],
                timeout_ms: None,
                max_retries: None,
            })
            .await
            .unwrap();

            db
        });

        let engine = ReconciliationEngine::new(db).unwrap();
        let desired = rt.block_on(async { engine.compute_desired_state().await.unwrap() });

        let stub_entries: Vec<_> = desired
            .expected_paths
            .values()
            .filter(|a| a.artifact_type == ArtifactType::CommandStub)
            .collect();

        assert!(
            stub_entries.is_empty(),
            "Should not have command stub when expose_via_mcp is false"
        );
    }

    // =====================================
    // SKILL ARTIFACT TESTS
    // =====================================

    #[test]
    fn test_skill_global_happy_path() {
        let rt = tokio::runtime::Runtime::new().unwrap();
        let db = rt.block_on(async {
            let db = std::sync::Arc::new(crate::database::Database::new_in_memory().await.unwrap());

            db.create_skill(crate::models::CreateSkillInput {
                id: None,
                name: "Test Skill".to_string(),
                description: "A test skill".to_string(),
                instructions: "echo 'skill'".to_string(),
                scope: Scope::Global,
                input_schema: vec![],
                directory_path: "/test/skills".to_string(),
                entry_point: "main.sh".to_string(),
                enabled: true,
                ..Default::default()
            })
            .await
            .unwrap();

            db
        });

        let engine = ReconciliationEngine::new(db).unwrap();
        let desired = rt.block_on(async { engine.compute_desired_state().await.unwrap() });

        let skill_entries: Vec<_> = desired
            .expected_paths
            .values()
            .filter(|a| a.artifact_type == ArtifactType::Skill)
            .collect();

        assert!(
            !skill_entries.is_empty(),
            "Should have skill entries when enabled"
        );
    }

    #[test]
    fn test_skill_local_happy_path() {
        let rt = tokio::runtime::Runtime::new().unwrap();
        let db = rt.block_on(async {
            let db = std::sync::Arc::new(crate::database::Database::new_in_memory().await.unwrap());

            db.create_skill(crate::models::CreateSkillInput {
                id: None,
                name: "Local Skill".to_string(),
                description: "A local skill".to_string(),
                instructions: "echo 'local skill'".to_string(),
                scope: Scope::Local,
                input_schema: vec![],
                directory_path: "/repo/.skills/test-skill".to_string(),
                entry_point: "main.sh".to_string(),
                enabled: true,
                ..Default::default()
            })
            .await
            .unwrap();

            db
        });

        let mut path_resolver = crate::path_resolver::PathResolver::new().unwrap();
        path_resolver.add_repository_root(std::path::PathBuf::from("/repo"));
        let engine = ReconciliationEngine { db, path_resolver };
        let desired = rt.block_on(async { engine.compute_desired_state().await.unwrap() });

        let skill_entries: Vec<_> = desired
            .expected_paths
            .values()
            .filter(|a| a.artifact_type == ArtifactType::Skill)
            .collect();

        // Local skills require registered repository roots
        // Since we don't have any registered, the count depends on the engine's behavior
        assert!(
            !skill_entries.is_empty(),
            "Should handle local skills gracefully"
        );

        // Any entries we do get should be local scope
        for entry in &skill_entries {
            assert_eq!(entry.scope, Scope::Local);
        }
    }

    #[test]
    fn test_skill_disabled_not_in_desired_state() {
        let rt = tokio::runtime::Runtime::new().unwrap();
        let db = rt.block_on(async {
            let db = std::sync::Arc::new(crate::database::Database::new_in_memory().await.unwrap());

            db.create_skill(crate::models::CreateSkillInput {
                id: None,
                name: "Disabled Skill".to_string(),
                description: "A disabled skill".to_string(),
                instructions: "echo 'disabled'".to_string(),
                scope: Scope::Global,
                input_schema: vec![],
                directory_path: "/test/skills".to_string(),
                entry_point: "main.sh".to_string(),
                enabled: false,
                ..Default::default()
            })
            .await
            .unwrap();

            db
        });

        let engine = ReconciliationEngine::new(db).unwrap();
        let desired = rt.block_on(async { engine.compute_desired_state().await.unwrap() });

        let skill_entries: Vec<_> = desired
            .expected_paths
            .values()
            .filter(|a| a.artifact_type == ArtifactType::Skill)
            .collect();

        assert!(
            skill_entries.is_empty(),
            "Disabled skills should not be in desired state"
        );
    }

    // =====================================
    // SKILL ADAPTER TARGETING TESTS (#45)
    // =====================================

    #[test]
    fn test_skill_target_adapters_filters_to_listed_adapters() {
        let rt = tokio::runtime::Runtime::new().unwrap();
        let db = rt.block_on(async {
            let db = std::sync::Arc::new(crate::database::Database::new_in_memory().await.unwrap());
            // Create a skill targeting only ClaudeCode
            db.create_skill(crate::models::CreateSkillInput {
                id: None,
                name: "Targeted Skill".to_string(),
                description: "Only for Claude Code".to_string(),
                instructions: "echo 'targeted'".to_string(),
                scope: Scope::Global,
                input_schema: vec![],
                directory_path: "/test/skills".to_string(),
                entry_point: "main.sh".to_string(),
                enabled: true,
                target_adapters: vec!["claude-code".to_string()],
                ..Default::default()
            })
            .await
            .unwrap();
            db
        });

        let engine = ReconciliationEngine::new(db).unwrap();
        let desired = rt.block_on(async { engine.compute_desired_state().await.unwrap() });

        let skill_entries: Vec<_> = desired
            .expected_paths
            .iter()
            .filter(|(_, a)| a.artifact_type == ArtifactType::Skill)
            .collect();

        // All entries must be for the claude-code adapter only
        assert!(
            !skill_entries.is_empty(),
            "Should have skill entries for targeted adapter"
        );
        for (_, artifact) in &skill_entries {
            assert_eq!(
                artifact.adapter,
                crate::models::AdapterType::ClaudeCode,
                "Skill should only appear for claude-code adapter"
            );
        }
    }

    #[test]
    fn test_skill_empty_target_adapters_uses_all_supported() {
        let rt = tokio::runtime::Runtime::new().unwrap();
        let db = rt.block_on(async {
            let db = std::sync::Arc::new(crate::database::Database::new_in_memory().await.unwrap());
            // Empty target_adapters = all supported
            db.create_skill(crate::models::CreateSkillInput {
                id: None,
                name: "All Adapters Skill".to_string(),
                description: "Syncs to all".to_string(),
                instructions: "echo 'all'".to_string(),
                scope: Scope::Global,
                input_schema: vec![],
                directory_path: "/test/skills".to_string(),
                entry_point: "main.sh".to_string(),
                enabled: true,
                target_adapters: vec![], // empty = all
                ..Default::default()
            })
            .await
            .unwrap();
            db
        });

        let engine = ReconciliationEngine::new(db).unwrap();
        let desired = rt.block_on(async { engine.compute_desired_state().await.unwrap() });

        let skill_entries: Vec<_> = desired
            .expected_paths
            .values()
            .filter(|a| a.artifact_type == ArtifactType::Skill)
            .collect();

        // Should have entries for multiple adapters (at least 2 support skills)
        let adapters: std::collections::HashSet<_> =
            skill_entries.iter().map(|a| a.adapter).collect();
        assert!(
            adapters.len() >= 2,
            "Empty target_adapters should produce entries for all supported adapters, got: {:?}",
            adapters
        );
    }

    #[test]
    fn test_skill_unsupported_adapter_in_target_is_silently_skipped() {
        let rt = tokio::runtime::Runtime::new().unwrap();
        let db = rt.block_on(async {
            let db = std::sync::Arc::new(crate::database::Database::new_in_memory().await.unwrap());
            // Cursor does not support skills  it should be silently skipped without panic
            db.create_skill(crate::models::CreateSkillInput {
                id: None,
                name: "Skip Unsupported".to_string(),
                description: "Cursor does not support skills".to_string(),
                instructions: "echo 'skip'".to_string(),
                scope: Scope::Global,
                input_schema: vec![],
                directory_path: "/test/skills".to_string(),
                entry_point: "main.sh".to_string(),
                enabled: true,
                target_adapters: vec!["cursor".to_string()],
                ..Default::default()
            })
            .await
            .unwrap();
            db
        });

        let engine = ReconciliationEngine::new(db).unwrap();
        let desired = rt.block_on(async { engine.compute_desired_state().await.unwrap() });

        // No skill artifacts should be generated (Cursor doesn't support skills)
        let skill_entries: Vec<_> = desired
            .expected_paths
            .values()
            .filter(|a| a.artifact_type == ArtifactType::Skill)
            .collect();

        assert!(
            skill_entries.is_empty(),
            "Unsupported adapter (Cursor) should produce no skill artifacts"
        );
    }

    #[test]
    fn test_validate_skill_target_adapters_rejects_unknown_id() {
        let result =
            crate::models::validate_skill_target_adapters(&["not-a-real-adapter".to_string()]);
        assert!(result.is_err(), "Unknown adapter should fail validation");
    }

    #[test]
    fn test_validate_skill_target_adapters_rejects_unsupported() {
        // Cursor does not support skills
        let result = crate::models::validate_skill_target_adapters(&["cursor".to_string()]);
        assert!(
            result.is_err(),
            "Adapter that doesn't support skills should fail validation"
        );
    }

    #[test]
    fn test_validate_skill_target_adapters_accepts_valid() {
        let result = crate::models::validate_skill_target_adapters(&[
            "claude-code".to_string(),
            "cline".to_string(),
        ]);
        assert!(
            result.is_ok(),
            "Valid skill-supporting adapters should pass"
        );
    }

    #[test]
    fn test_validate_skill_target_adapters_accepts_empty() {
        let result = crate::models::validate_skill_target_adapters(&[]);
        assert!(result.is_ok(), "Empty list (all adapters) should pass");
    }

    // =====================================
    // WRITE FAILURE TESTS
    // =====================================

    #[test]
    fn test_write_atomic_requires_parent_directory() {
        use tempfile::TempDir;

        let temp_dir = TempDir::new().unwrap();
        // Try to write to a nested path that doesn't exist
        let nested_path = temp_dir
            .path()
            .join("a")
            .join("b")
            .join("c")
            .join("test.md");

        let result = write_atomic(&nested_path, "test content");

        // Should fail because parent directory doesn't exist
        assert!(
            result.is_err(),
            "Should fail when parent directories don't exist"
        );
    }

    #[test]
    fn test_write_atomic_succeeds_with_existing_parent() {
        use tempfile::TempDir;

        let temp_dir = TempDir::new().unwrap();
        let file_path = temp_dir.path().join("test.md");

        let result = write_atomic(&file_path, "test content");

        assert!(
            result.is_ok(),
            "Should succeed when parent directory exists"
        );
        assert!(file_path.exists(), "File should exist");
        assert_eq!(fs::read_to_string(&file_path).unwrap(), "test content");
    }

    #[test]
    fn test_write_atomic_overwrites_existing() {
        use tempfile::TempDir;

        let temp_dir = TempDir::new().unwrap();
        let file_path = temp_dir.path().join("existing.md");

        fs::write(&file_path, "old content").unwrap();

        let result = write_atomic(&file_path, "new content");

        assert!(result.is_ok());
        assert_eq!(fs::read_to_string(&file_path).unwrap(), "new content");
    }

    #[test]
    fn test_write_atomic_no_temp_file_left() {
        use tempfile::TempDir;

        let temp_dir = TempDir::new().unwrap();
        let file_path = temp_dir.path().join("test.md");
        let temp_path = temp_dir.path().join("test.tmp");

        let _ = write_atomic(&file_path, "content");

        assert!(!temp_path.exists(), "Temp file should be cleaned up");
        assert!(file_path.exists(), "Target file should exist");
    }
}
