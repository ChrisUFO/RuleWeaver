use crate::models::{registry::REGISTRY, AdapterType, Command, Skill, SkillParameterType};
use std::collections::HashMap;

#[derive(serde::Serialize)]
struct CommandStubArg {
    arg_type: String,
    required: bool,
}

#[derive(serde::Serialize)]
struct CommandStub {
    description: String,
    script: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    arguments: Option<HashMap<String, CommandStubArg>>,
}

#[derive(serde::Serialize)]
struct CommandsFile {
    command: Vec<CommandStub>,
}

pub fn format_command_stub_content(adapter: &AdapterType, commands: &[Command]) -> String {
    // Get adapter entry from registry to determine format
    let entry = REGISTRY.get(adapter);
    let format = entry.map(|e| e.file_format).unwrap_or("markdown");

    let stubs: Vec<CommandStub> = commands
        .iter()
        .map(|cmd| {
            let mut args = HashMap::new();
            for arg in &cmd.arguments {
                args.insert(
                    arg.name.clone(),
                    CommandStubArg {
                        arg_type: match arg.arg_type {
                            crate::models::ArgumentType::String => "string".to_string(),
                            crate::models::ArgumentType::Number => "number".to_string(),
                            crate::models::ArgumentType::Boolean => "boolean".to_string(),
                            crate::models::ArgumentType::Enum => "enum".to_string(),
                        },
                        required: arg.required,
                    },
                );
            }

            CommandStub {
                description: cmd.description.clone(),
                script: cmd.script.clone(),
                arguments: if args.is_empty() { None } else { Some(args) },
            }
        })
        .collect();

    if format == "toml" {
        let file = CommandsFile { command: stubs };
        let toml_content = toml::to_string(&file).unwrap_or_default();

        format!(
            "# Generated by RuleWeaver - Do not edit manually\n# Last synced: {}\n\n{}",
            chrono::Utc::now().format("%Y-%m-%dT%H:%M:%SZ"),
            toml_content
        )
    } else {
        // Default to markdown stub (common for most adapters)
        let mut md = format!(
            "# Command Stubs\n\nGenerated by RuleWeaver - Do not edit manually\nLast synced: {}\n\n",
            chrono::Utc::now().format("%Y-%m-%dT%H:%M:%SZ")
        );

        for stub in stubs {
            md.push_str(&format!(
                "## {}\n\n{}\n\n**Script**: `{}`\n",
                stub.description, stub.description, stub.script
            ));
            if let Some(args) = stub.arguments {
                md.push_str("\n**Arguments**:\n\n");
                for (name, arg) in args {
                    md.push_str(&format!(
                        "- `{}` ({}): {}\n",
                        name,
                        arg.arg_type,
                        if arg.required { "required" } else { "optional" }
                    ));
                }
            }
            md.push_str("\n---\n\n");
        }
        md
    }
}

/// Format skill content for writing to SKILL.md files.
pub fn format_skill_content(skill: &Skill) -> String {
    let mut content = format!(
        "# {}\n\n{}\n\n## Instructions\n\n{}\n",
        skill.name, skill.description, skill.instructions
    );

    if !skill.input_schema.is_empty() {
        content.push_str("\n## Parameters\n\n");
        for param in &skill.input_schema {
            content.push_str(&format!(
                "- **{}** ({}{}): {}\n",
                param.name,
                match param.param_type {
                    SkillParameterType::String => "string",
                    SkillParameterType::Number => "number",
                    SkillParameterType::Boolean => "boolean",
                    SkillParameterType::Enum => "enum",
                    SkillParameterType::Array => "array",
                    SkillParameterType::Object => "object",
                },
                if param.required { ", required" } else { "" },
                param.description
            ));
        }
    }

    content.push_str(&format!("\n## Entry Point\n\n`{}`\n", skill.entry_point));

    content
}
