diff --git a/package.json b/package.json
index 3ec627c..685dc03 100644
--- a/package.json
+++ b/package.json
@@ -1,7 +1,7 @@
 {
   "name": "ruleweaver",
   "private": true,
-  "version": "0.0.30-2502",
+  "version": "0.0.31-2602",
   "type": "module",
   "scripts": {
     "dev": "vite",
@@ -34,47 +34,47 @@
   "dependencies": {
     "@hookform/resolvers": "^3.10.0",
     "@radix-ui/react-slot": "^1.2.4",
-    "@tauri-apps/api": "^2",
+    "@tauri-apps/api": "^2.10.1",
     "@tauri-apps/plugin-autostart": "^2.5.1",
     "@tauri-apps/plugin-dialog": "^2.6.0",
     "@tauri-apps/plugin-notification": "^2.3.3",
-    "@tauri-apps/plugin-opener": "^2",
+    "@tauri-apps/plugin-opener": "^2.5.3",
     "@tauri-apps/plugin-updater": "^2.10.0",
-    "@uiw/react-md-editor": "^4.0.5",
+    "@uiw/react-md-editor": "^4.0.11",
     "class-variance-authority": "^0.7.1",
     "clsx": "^2.1.1",
     "framer-motion": "^12.34.3",
     "lucide-react": "^0.475.0",
-    "react": "^19.1.0",
-    "react-dom": "^19.1.6",
-    "react-hook-form": "^7.54.2",
-    "tailwind-merge": "^3.0.2",
-    "zod": "^3.24.2",
-    "zustand": "^5.0.3"
+    "react": "^19.2.4",
+    "react-dom": "^19.2.4",
+    "react-hook-form": "^7.71.2",
+    "tailwind-merge": "^3.5.0",
+    "zod": "^3.25.76",
+    "zustand": "^5.0.11"
   },
   "devDependencies": {
-    "@eslint/js": "^9.21.0",
-    "@tailwindcss/vite": "^4.0.9",
-    "@tauri-apps/cli": "^2",
-    "@testing-library/jest-dom": "^6.6.3",
-    "@testing-library/react": "^16.2.0",
+    "@eslint/js": "^9.39.3",
+    "@tailwindcss/vite": "^4.2.1",
+    "@tauri-apps/cli": "^2.10.0",
+    "@testing-library/jest-dom": "^6.9.1",
+    "@testing-library/react": "^16.3.2",
     "@testing-library/user-event": "^14.6.1",
-    "@types/node": "^22.13.5",
-    "@types/react": "^19.1.8",
-    "@types/react-dom": "^19.1.6",
-    "@vitejs/plugin-react": "^4.6.0",
-    "@vitest/coverage-v8": "^3.0.7",
-    "eslint": "^9.21.0",
-    "eslint-plugin-react-hooks": "^5.1.0",
-    "eslint-plugin-react-refresh": "^0.4.19",
+    "@types/node": "^22.19.12",
+    "@types/react": "^19.2.14",
+    "@types/react-dom": "^19.2.3",
+    "@vitejs/plugin-react": "^4.7.0",
+    "@vitest/coverage-v8": "^3.2.4",
+    "eslint": "^9.39.3",
+    "eslint-plugin-react-hooks": "^5.2.0",
+    "eslint-plugin-react-refresh": "^0.4.26",
     "husky": "^9.1.7",
-    "jsdom": "^26.0.0",
+    "jsdom": "^26.1.0",
     "lint-staged": "^16.2.7",
-    "prettier": "^3.5.2",
-    "tailwindcss": "^4.0.9",
+    "prettier": "^3.8.1",
+    "tailwindcss": "^4.2.1",
     "typescript": "~5.8.3",
-    "typescript-eslint": "^8.25.0",
-    "vite": "^7.0.4",
-    "vitest": "^3.0.7"
+    "typescript-eslint": "^8.56.1",
+    "vite": "^7.3.1",
+    "vitest": "^3.2.4"
   }
 }
diff --git a/plans/issue-41-39-path-resolution-reconciliation.md b/plans/issue-41-39-path-resolution-reconciliation.md
deleted file mode 100644
index a8e2a45..0000000
--- a/plans/issue-41-39-path-resolution-reconciliation.md
+++ /dev/null
@@ -1,451 +0,0 @@
-# Project Strategy: Path Resolution Invariants (#41) & Reconciliation Engine (#39)
-
-## Executive Summary
-
-This plan addresses two interconnected issues that are foundational to RuleWeaver's reliability:
-
-1. **Issue #41 - Path Resolution Invariants**: Standardize path resolution across all artifact types (rules, command stubs, slash commands, skills) so that preview, sync, cleanup, and reconciliation flows produce identical paths.
-
-2. **Issue #39 - Reconciliation Engine**: Build a desired-state reconciliation system that automatically cleans up stale artifacts when rules/commands/skills are renamed, deleted, or retargeted.
-
-These issues are tightly coupled because reliable reconciliation depends on consistent path resolution.
-
----
-
-## 1. High-Level Strategy
-
-### Current State Analysis
-
-The codebase already has a partial canonical registry in [`src-tauri/src/models/registry.rs`](src-tauri/src/models/registry.rs:1) that defines:
-
-- Tool capabilities (rules, command stubs, slash commands, skills support)
-- Path templates for global/local targets
-- File format metadata
-
-However, path resolution logic is **scattered across multiple modules**:
-
-| Module                                                                      | Current Responsibility                                        |
-| --------------------------------------------------------------------------- | ------------------------------------------------------------- |
-| [`sync/mod.rs`](src-tauri/src/sync/mod.rs:29)                               | `resolve_registry_path()`, `validate_target_path()` for rules |
-| [`slash_commands/mod.rs`](src-tauri/src/slash_commands/mod.rs:27)           | `get_command_path()`, `get_command_path_for_root()`           |
-| [`slash_commands/adapters.rs`](src-tauri/src/slash_commands/adapters.rs:70) | `global_dir()`, `local_dir()` per adapter                     |
-| [`commands/adapters.rs`](src-tauri/src/commands/adapters.rs:1)              | Command stub formatting (no path resolution)                  |
-
-This fragmentation causes:
-
-- **Preview vs write path mismatches**
-- **Inconsistent local target validation**
-- **Stale artifacts after mutations**
-- **Duplicated logic that drifts over time**
-
-### Target Architecture
-
-```mermaid
-flowchart TB
-    subgraph Registry[Canonical Registry - REGISTRY]
-        TE[ToolEntry]
-        PT[PathTemplates]
-        TC[ToolCapabilities]
-    end
-
-    subgraph Resolver[Shared Path Resolver Service]
-        GP[global_path_for_artifact]
-        LP[local_path_for_artifact]
-        VP[validate_target_path]
-        CP[canonicalize_path]
-    end
-
-    subgraph Consumers
-        RS[Rule Sync Engine]
-        CS[Command Stub Sync]
-        SC[Slash Command Sync]
-        SK[Skill Sync]
-        RE[Reconciliation Engine]
-        PV[Preview/Diagnostic UI]
-    end
-
-    Registry --> Resolver
-    Resolver --> RS
-    Resolver --> CS
-    Resolver --> SC
-    Resolver --> SK
-    Resolver --> RE
-    Resolver --> PV
-```
-
-### Key Design Principles
-
-1. **Single Source of Truth**: All path templates live in `REGISTRY`. No hardcoded paths elsewhere.
-2. **Pure Functions**: Path resolution functions are deterministic and testable with fixture-based matrix tests.
-3. **Artifact-Agnostic**: The resolver handles all artifact types uniformly via `ArtifactType` enum.
-4. **Idempotent Reconciliation**: Safe to run multiple times; produces same result.
-5. **Dry-Run First**: All reconciliation operations support preview mode.
-
----
-
-## 2. Implementation Plan
-
-### Phase 1: Shared Path Resolver Service
-
-**Goal**: Create a unified path resolution module that all sync engines consume.
-
-#### 1.1 Create `path_resolver` Module
-
-Create [`src-tauri/src/path_resolver/mod.rs`](src-tauri/src/path_resolver/mod.rs:1) with:
-
-```rust
-/// Resolved path information for an artifact
-pub struct ResolvedPath {
-    pub path: PathBuf,
-    pub adapter: AdapterType,
-    pub artifact: ArtifactType,
-    pub scope: Scope,
-    pub exists: bool,
-}
-
-/// Shared path resolver service
-pub struct PathResolver {
-    home_dir: PathBuf,
-    repository_roots: Vec<PathBuf>,
-}
-
-impl PathResolver {
-    /// Resolve global path for artifact+adapter combination
-    pub fn global_path(&self, adapter: AdapterType, artifact: ArtifactType) -> Result<ResolvedPath>;
-
-    /// Resolve local path for artifact+adapter+repository_root combination
-    pub fn local_path(&self, adapter: AdapterType, artifact: ArtifactType, repo_root: &Path) -> Result<ResolvedPath>;
-
-    /// Validate a user-provided target path
-    pub fn validate_target_path(&self, path: &Path) -> Result<()>;
-
-    /// Canonicalize path with platform-specific normalization
-    pub fn canonicalize(&self, path: &Path) -> Result<PathBuf>;
-
-    /// List all paths that would be written for given artifacts
-    pub fn preview_paths(&self, artifacts: &[ArtifactSpec]) -> Result<Vec<ResolvedPath>>;
-}
-```
-
-#### 1.2 Path Template Resolution Logic
-
-The resolver must handle path templates from the registry:
-
-| Artifact Type | Global Path Template             | Local Path Template                   |
-| ------------- | -------------------------------- | ------------------------------------- |
-| Rule          | `~/.claude/CLAUDE.md`            | `{repo}/.claude/CLAUDE.md`            |
-| CommandStub   | `~/.claude/commands/COMMANDS.md` | `{repo}/.claude/commands/COMMANDS.md` |
-| SlashCommand  | `~/.claude/commands/{name}.md`   | `{repo}/.claude/commands/{name}.md`   |
-| Skill         | TBD (Phase 3)                    | TBD (Phase 3)                         |
-
-#### 1.3 Migrate Existing Call Sites
-
-Replace scattered path resolution with `PathResolver` calls:
-
-- [`sync/mod.rs:resolve_registry_path()`](src-tauri/src/sync/mod.rs:29) → `PathResolver::global_path()`
-- [`sync/mod.rs:validate_target_path()`](src-tauri/src/sync/mod.rs:40) → `PathResolver::validate_target_path()`
-- [`slash_commands/mod.rs:get_command_path()`](src-tauri/src/slash_commands/mod.rs:27) → `PathResolver::global_path()` / `local_path()`
-
-#### 1.4 Test Matrix
-
-Create comprehensive tests in [`src-tauri/src/path_resolver/tests.rs`](src-tauri/src/path_resolver/tests.rs:1):
-
-```
-Test Matrix: adapter × artifact × scope × platform
-- 10 adapters × 4 artifacts × 2 scopes × 2 platforms = 160 test cases
-- Plus edge cases: Unicode paths, symlinks, missing directories
-```
-
----
-
-### Phase 2: Reconciliation Engine
-
-**Goal**: Build desired-state reconciliation that runs after CRUD mutations.
-
-#### 2.1 Desired State Model
-
-Create [`src-tauri/src/reconciliation/mod.rs`](src-tauri/src/reconciliation/mod.rs:1):
-
-```rust
-/// Represents the desired state of generated artifacts
-pub struct DesiredState {
-    /// All paths that should exist with their expected content hashes
-    expected_paths: HashMap<PathBuf, ExpectedArtifact>,
-}
-
-/// An artifact that should exist
-pub struct ExpectedArtifact {
-    pub adapter: AdapterType,
-    pub artifact: ArtifactType,
-    pub scope: Scope,
-    pub repo_root: Option<PathBuf>,
-    pub content_hash: String,
-}
-
-/// Represents actual filesystem state
-pub struct ActualState {
-    /// All generated artifacts currently on disk
-    found_paths: HashMap<PathBuf, FoundArtifact>,
-}
-
-/// Reconciliation plan
-pub struct ReconcilePlan {
-    pub to_create: Vec<ResolvedPath>,
-    pub to_update: Vec<ResolvedPath>,
-    pub to_remove: Vec<PathBuf>,
-    pub unchanged: Vec<PathBuf>,
-}
-```
-
-#### 2.2 Reconciliation Operations
-
-```rust
-pub struct ReconciliationEngine {
-    db: Arc<Database>,
-    path_resolver: Arc<PathResolver>,
-}
-
-impl ReconciliationEngine {
-    /// Compute desired state from database artifacts
-    pub async fn compute_desired_state(&self) -> Result<DesiredState>;
-
-    /// Scan filesystem for actual state
-    pub async fn scan_actual_state(&self) -> Result<ActualState>;
-
-    /// Compare desired vs actual to produce plan
-    pub fn plan(&self, desired: &DesiredState, actual: &ActualState) -> ReconcilePlan;
-
-    /// Execute reconciliation plan (dry-run or real)
-    pub async fn execute(&self, plan: &ReconcilePlan, dry_run: bool) -> Result<ReconcileResult>;
-
-    /// Full reconciliation in one call
-    pub async fn reconcile(&self, dry_run: bool) -> Result<ReconcileResult>;
-}
-```
-
-#### 2.3 Reconciliation Triggers
-
-Wire reconciliation into mutation handlers:
-
-| Trigger                      | When to Reconcile      |
-| ---------------------------- | ---------------------- |
-| Rule Create/Update/Delete    | After database commit  |
-| Rule Adapter Toggle          | After database commit  |
-| Rule Scope Change            | After database commit  |
-| Command Create/Update/Delete | After database commit  |
-| Command Target Path Change   | After database commit  |
-| Import Operation             | After import completes |
-| Adapter Enable/Disable       | After settings change  |
-
-#### 2.4 Stale Artifact Detection
-
-The engine must detect artifacts that are:
-
-1. **Orphaned**: Generated file exists but no artifact references it
-2. **Outdated**: Content hash mismatch between expected and actual
-3. **Wrong Location**: File exists at old path after rename/retarget
-
-#### 2.5 Audit Logging
-
-All reconciliation operations must log:
-
-```rust
-pub struct ReconcileLogEntry {
-    pub timestamp: DateTime<Utc>,
-    pub operation: ReconcileOperation,
-    pub artifact_type: ArtifactType,
-    pub adapter: AdapterType,
-    pub scope: Scope,
-    pub path: PathBuf,
-    pub result: ReconcileResult,
-}
-```
-
----
-
-### Phase 3: Integration & Migration
-
-**Goal**: Integrate resolver and reconciliation into existing flows.
-
-#### 3.1 Update Sync Engines
-
-Replace direct path manipulation in:
-
-- [`SyncEngine`](src-tauri/src/sync/mod.rs:532) - Use `PathResolver`
-- [`SlashCommandSyncEngine`](src-tauri/src/slash_commands/sync.rs:137) - Use `PathResolver`
-- Command stub sync (where applicable)
-
-#### 3.2 Add Reconciliation to CRUD Handlers
-
-Update Tauri command handlers:
-
-- [`rule_commands.rs`](src-tauri/src/commands/rule_commands.rs:1) - Trigger reconciliation after mutations
-- [`command_commands.rs`](src-tauri/src/commands/command_commands.rs:1) - Trigger reconciliation after mutations
-- [`skill_commands.rs`](src-tauri/src/commands/skill_commands.rs:1) - Trigger reconciliation after mutations
-
-#### 3.3 Frontend Integration
-
-Expose reconciliation endpoints to frontend:
-
-```typescript
-// New Tauri commands
-invoke('preview_reconciliation'): Promise<ReconcilePlan>
-invoke('execute_reconciliation', { dryRun: boolean }): Promise<ReconcileResult>
-invoke('get_artifact_status'): Promise<ArtifactStatus[]>
-```
-
-#### 3.4 Migration Path
-
-For existing installations:
-
-1. Run reconciliation on first launch after upgrade
-2. Log any stale artifacts found
-3. Offer "Repair All" action in settings
-
----
-
-### Phase 4: Testing & Documentation
-
-**Goal**: Comprehensive test coverage and updated documentation.
-
-#### 4.1 Unit Tests
-
-- `path_resolver` tests: Full adapter × artifact × scope matrix
-- `reconciliation` tests: Desired state computation, plan generation, execution
-
-#### 4.2 Integration Tests
-
-- End-to-end reconciliation after rule mutations
-- Cross-platform path handling (Windows/Unix)
-- Idempotency verification
-
-#### 4.3 Documentation Updates
-
-- Update [`architecture.md`](architecture.md:1) with new modules
-- Update [`docs/ai-tools-commands-reference.md`](docs/ai-tools-commands-reference.md:1) if needed
-- Add troubleshooting guide for reconciliation issues
-
----
-
-## 3. Execution Checklist
-
-### Phase 1: Shared Path Resolver Service
-
-- [ ] Create feature branch `feature/path-resolution-reconciliation`
-- [ ] Create `src-tauri/src/path_resolver/mod.rs` with `PathResolver` struct
-- [ ] Implement `global_path()` using registry templates
-- [ ] Implement `local_path()` with repository root substitution
-- [ ] Implement `validate_target_path()` with home directory constraint
-- [ ] Implement `canonicalize()` with platform normalization
-- [ ] Implement `preview_paths()` for UI consumption
-- [ ] Create `src-tauri/src/path_resolver/tests.rs` with matrix tests
-- [ ] Migrate `sync/mod.rs` to use `PathResolver`
-- [ ] Migrate `slash_commands/mod.rs` to use `PathResolver`
-- [ ] Migrate `slash_commands/adapters.rs` to use `PathResolver`
-- [ ] Remove deprecated path functions from sync module
-- [ ] Run full test suite and fix regressions
-
-### Phase 2: Reconciliation Engine
-
-- [ ] Create `src-tauri/src/reconciliation/mod.rs`
-- [ ] Define `DesiredState`, `ActualState`, `ReconcilePlan` structs
-- [ ] Implement `compute_desired_state()` from database
-- [ ] Implement `scan_actual_state()` filesystem scanner
-- [ ] Implement `plan()` comparison logic
-- [ ] Implement `execute()` with dry-run support
-- [ ] Create `src-tauri/src/reconciliation/tests.rs`
-- [ ] Add audit logging for all operations
-- [ ] Create `ReconcileLogEntry` database table
-
-### Phase 3: Integration & Migration
-
-- [ ] Wire `PathResolver` into `SyncEngine`
-- [ ] Wire `PathResolver` into `SlashCommandSyncEngine`
-- [ ] Add reconciliation triggers to rule CRUD handlers
-- [ ] Add reconciliation triggers to command CRUD handlers
-- [ ] Add reconciliation triggers to skill CRUD handlers
-- [ ] Add reconciliation after import operations
-- [ ] Create `preview_reconciliation` Tauri command
-- [ ] Create `execute_reconciliation` Tauri command
-- [ ] Create `get_artifact_status` Tauri command
-- [ ] Add frontend UI for reconciliation status/repair
-
-### Phase 4: Testing & Documentation
-
-- [ ] Add unit tests for path resolver matrix (160+ cases)
-- [ ] Add unit tests for reconciliation engine
-- [ ] Add integration tests for mutation-triggered reconciliation
-- [ ] Add cross-platform path tests (Windows/Unix)
-- [ ] Verify idempotency with repeated reconciliation runs
-- [ ] Update `architecture.md` with new modules
-- [ ] Update developer documentation
-- [ ] Create user-facing troubleshooting guide
-- [ ] Run full regression test suite
-- [ ] Create PR with linked issues #41 and #39
-
----
-
-## 4. Dependency Graph
-
-```mermaid
-flowchart LR
-    subgraph Phase1[Phase 1: Path Resolver]
-        PR[PathResolver Module]
-        PM[Path Migration]
-        PT[Path Tests]
-    end
-
-    subgraph Phase2[Phase 2: Reconciliation]
-        RE[Reconciliation Engine]
-        RL[Reconciliation Logging]
-        RT[Reconciliation Tests]
-    end
-
-    subgraph Phase3[Phase 3: Integration]
-        SI[Sync Integration]
-        CH[CRUD Handlers]
-        FE[Frontend UI]
-    end
-
-    subgraph Phase4[Phase 4: Testing & Docs]
-        IT[Integration Tests]
-        DC[Documentation]
-    end
-
-    PR --> PM --> PT
-    PT --> RE
-    RE --> RL --> RT
-    RT --> SI
-    SI --> CH --> FE
-    FE --> IT --> DC
-```
-
----
-
-## 5. Risk Mitigation
-
-| Risk                                        | Mitigation                                             |
-| ------------------------------------------- | ------------------------------------------------------ |
-| Path resolution changes break existing sync | Comprehensive test matrix before migration             |
-| Reconciliation deletes wrong files          | Dry-run by default; require explicit confirmation      |
-| Performance impact of filesystem scanning   | Incremental reconciliation; cache actual state         |
-| Cross-platform path issues                  | Platform-specific test fixtures; CI on Windows + Linux |
-| Migration leaves stale files                | One-time repair action in settings                     |
-
----
-
-## 6. Success Criteria
-
-### Issue #41 Acceptance Criteria
-
-- [x] Preview and actual write paths always match for rules/commands/slash/skills
-- [x] Local target validation is consistent across all artifact editors and APIs
-- [x] Tests cover full adapter × artifact × scope matrix with platform-specific path cases
-- [x] No stale files remain from resolver mismatch after migration
-
-### Issue #39 Acceptance Criteria
-
-- [x] Rename/delete/deselect operations remove stale generated artifacts deterministically
-- [x] Reconciliation runs after artifact mutations and import/export flows
-- [x] Dry-run output is available and matches actual reconcile execution
-- [x] Audit logs capture created/updated/removed artifacts with adapter/scope context
diff --git a/public/version.json b/public/version.json
index 7cf341d..5cc15f9 100644
--- a/public/version.json
+++ b/public/version.json
@@ -1 +1 @@
-{ "version": "0.0.30-2502", "timestamp": "2026-02-25 14:39:45" }
+{ "version": "0.0.31-2602", "timestamp": "2026-02-26 07:00:49" }
diff --git a/src-tauri/Cargo.toml b/src-tauri/Cargo.toml
index b620801..e8b2a5c 100644
--- a/src-tauri/Cargo.toml
+++ b/src-tauri/Cargo.toml
@@ -1,6 +1,6 @@
 [package]
 name = "ruleweaver"
-version = "0.0.30-2502"
+version = "0.0.31-2602"
 description = "A unified desktop app for managing AI coding assistant rules and configurations"
 authors = ["ChrisUFO"]
 edition = "2021"
diff --git a/src-tauri/src/commands/import_commands.rs b/src-tauri/src/commands/import_commands.rs
index 80d6828..e10ded3 100644
--- a/src-tauri/src/commands/import_commands.rs
+++ b/src-tauri/src/commands/import_commands.rs
@@ -17,7 +17,7 @@ pub async fn scan_ai_tool_import_candidates(
 ) -> Result<ImportScanResult> {
     let opts = options.unwrap_or_default();
     let max_size = rule_import::resolve_max_size(&opts);
-    rule_import::scan_ai_tool_candidates(&db, max_size).await
+    rule_import::scan_ai_tool_candidates(db.inner().clone(), max_size).await
 }
 
 #[tauri::command]
@@ -27,8 +27,42 @@ pub async fn import_ai_tool_rules(
 ) -> Result<ImportExecutionResult> {
     let opts = options.unwrap_or_default();
     let max_size = rule_import::resolve_max_size(&opts);
-    let scan = rule_import::scan_ai_tool_candidates(&db, max_size).await?;
-    rule_import::execute_import(&db, scan, opts).await
+    let scan = rule_import::scan_ai_tool_candidates(db.inner().clone(), max_size).await?;
+    let mut filtered_scan = scan.clone();
+    filtered_scan
+        .candidates
+        .retain(|c| c.artifact_type == crate::models::ImportArtifactType::Rule);
+    rule_import::execute_import(db.inner().clone(), filtered_scan, opts).await
+}
+
+#[tauri::command]
+pub async fn import_ai_tool_commands(
+    options: Option<ImportExecutionOptions>,
+    db: State<'_, Arc<Database>>,
+) -> Result<ImportExecutionResult> {
+    let opts = options.unwrap_or_default();
+    let max_size = rule_import::resolve_max_size(&opts);
+    let scan = rule_import::scan_ai_tool_candidates(db.inner().clone(), max_size).await?;
+    let mut filtered_scan = scan.clone();
+    filtered_scan
+        .candidates
+        .retain(|c| c.artifact_type == crate::models::ImportArtifactType::SlashCommand);
+    rule_import::execute_import(db.inner().clone(), filtered_scan, opts).await
+}
+
+#[tauri::command]
+pub async fn import_ai_tool_skills(
+    options: Option<ImportExecutionOptions>,
+    db: State<'_, Arc<Database>>,
+) -> Result<ImportExecutionResult> {
+    let opts = options.unwrap_or_default();
+    let max_size = rule_import::resolve_max_size(&opts);
+    let scan = rule_import::scan_ai_tool_candidates(db.inner().clone(), max_size).await?;
+    let mut filtered_scan = scan.clone();
+    filtered_scan
+        .candidates
+        .retain(|c| c.artifact_type == crate::models::ImportArtifactType::Skill);
+    rule_import::execute_import(db.inner().clone(), filtered_scan, opts).await
 }
 
 #[tauri::command]
@@ -40,7 +74,7 @@ pub async fn import_rule_from_file(
     let opts = options.unwrap_or_default();
     let max_size = rule_import::resolve_max_size(&opts);
     let scan = rule_import::scan_file_to_candidates(&PathBuf::from(path), max_size);
-    rule_import::execute_import(&db, scan, opts).await
+    rule_import::execute_import(db.inner().clone(), scan, opts).await
 }
 
 #[tauri::command]
@@ -61,8 +95,8 @@ pub async fn import_rules_from_directory(
 ) -> Result<ImportExecutionResult> {
     let opts = options.unwrap_or_default();
     let max_size = rule_import::resolve_max_size(&opts);
-    let scan = rule_import::scan_directory_to_candidates(&PathBuf::from(path), max_size);
-    rule_import::execute_import(&db, scan, opts).await
+    let scan = rule_import::scan_directory_to_candidates(&PathBuf::from(path), max_size, None);
+    rule_import::execute_import(db.inner().clone(), scan, opts).await
 }
 
 #[tauri::command]
@@ -72,7 +106,7 @@ pub fn scan_rule_directory_import(
 ) -> ImportScanResult {
     let opts = options.unwrap_or_default();
     let max_size = rule_import::resolve_max_size(&opts);
-    rule_import::scan_directory_to_candidates(&PathBuf::from(path), max_size)
+    rule_import::scan_directory_to_candidates(&PathBuf::from(path), max_size, None)
 }
 
 #[tauri::command]
@@ -84,7 +118,7 @@ pub async fn import_rule_from_url(
     let opts = options.unwrap_or_default();
     let max_size = rule_import::resolve_max_size(&opts);
     let scan = rule_import::scan_url_to_candidates(&url, max_size).await?;
-    rule_import::execute_import(&db, scan, opts).await
+    rule_import::execute_import(db.inner().clone(), scan, opts).await
 }
 
 #[tauri::command]
@@ -107,7 +141,7 @@ pub async fn import_rule_from_clipboard(
     let opts = options.unwrap_or_default();
     let max_size = rule_import::resolve_max_size(&opts);
     let scan = rule_import::scan_clipboard_to_candidates(&content, name.as_deref(), max_size)?;
-    rule_import::execute_import(&db, scan, opts).await
+    rule_import::execute_import(db.inner().clone(), scan, opts).await
 }
 
 #[tauri::command]
@@ -122,8 +156,70 @@ pub fn scan_rule_clipboard_import(
 }
 
 #[tauri::command]
-pub async fn get_rule_import_history(db: State<'_, Arc<Database>>) -> Result<Vec<ImportHistoryEntry>> {
-    Ok(rule_import::read_import_history(&db).await)
+pub async fn get_rule_import_history(
+    db: State<'_, Arc<Database>>,
+) -> Result<Vec<ImportHistoryEntry>> {
+    Ok(rule_import::read_import_history(db.inner().clone()).await)
+}
+
+#[tauri::command]
+pub async fn import_commands_from_directory(
+    path: String,
+    options: Option<ImportExecutionOptions>,
+    db: State<'_, Arc<Database>>,
+) -> Result<ImportExecutionResult> {
+    let opts = options.unwrap_or_default();
+    let max_size = rule_import::resolve_max_size(&opts);
+    let scan = rule_import::scan_directory_to_candidates(
+        &PathBuf::from(path),
+        max_size,
+        Some(crate::models::ImportArtifactType::SlashCommand),
+    );
+    rule_import::execute_import(db.inner().clone(), scan, opts).await
+}
+
+#[tauri::command]
+pub fn scan_command_directory_import(
+    path: String,
+    options: Option<ImportExecutionOptions>,
+) -> ImportScanResult {
+    let opts = options.unwrap_or_default();
+    let max_size = rule_import::resolve_max_size(&opts);
+    rule_import::scan_directory_to_candidates(
+        &PathBuf::from(path),
+        max_size,
+        Some(crate::models::ImportArtifactType::SlashCommand),
+    )
+}
+
+#[tauri::command]
+pub async fn import_skills_from_directory(
+    path: String,
+    options: Option<ImportExecutionOptions>,
+    db: State<'_, Arc<Database>>,
+) -> Result<ImportExecutionResult> {
+    let opts = options.unwrap_or_default();
+    let max_size = rule_import::resolve_max_size(&opts);
+    let scan = rule_import::scan_directory_to_candidates(
+        &PathBuf::from(path),
+        max_size,
+        Some(crate::models::ImportArtifactType::Skill),
+    );
+    rule_import::execute_import(db.inner().clone(), scan, opts).await
+}
+
+#[tauri::command]
+pub fn scan_skill_directory_import(
+    path: String,
+    options: Option<ImportExecutionOptions>,
+) -> ImportScanResult {
+    let opts = options.unwrap_or_default();
+    let max_size = rule_import::resolve_max_size(&opts);
+    rule_import::scan_directory_to_candidates(
+        &PathBuf::from(path),
+        max_size,
+        Some(crate::models::ImportArtifactType::Skill),
+    )
 }
 
 #[cfg(test)]
diff --git a/src-tauri/src/lib.rs b/src-tauri/src/lib.rs
index 49f6c7c..f40911f 100644
--- a/src-tauri/src/lib.rs
+++ b/src-tauri/src/lib.rs
@@ -113,12 +113,12 @@ pub fn run() {
                         ..Default::default()
                     };
                     let max_size = crate::rule_import::resolve_max_size(&options);
-                    match crate::rule_import::scan_ai_tool_candidates(&db, max_size).await {
+                    match crate::rule_import::scan_ai_tool_candidates(db.clone(), max_size).await {
                         Ok(scan) => {
                             if scan.candidates.is_empty() {
                                 mark_bootstrap_done = true;
                             } else {
-                                match crate::rule_import::execute_import(&db, scan, options).await {
+                                match crate::rule_import::execute_import(db.clone(), scan, options).await {
                                     Ok(import_result) => {
                                         mark_bootstrap_done = true;
                                         log::info!(
@@ -418,6 +418,8 @@ pub fn run() {
             commands::get_storage_mode,
             commands::scan_ai_tool_import_candidates,
             commands::import_ai_tool_rules,
+            commands::import_ai_tool_commands,
+            commands::import_ai_tool_skills,
             commands::scan_rule_file_import,
             commands::import_rule_from_file,
             commands::scan_rule_directory_import,
@@ -427,6 +429,10 @@ pub fn run() {
             commands::scan_rule_clipboard_import,
             commands::import_rule_from_clipboard,
             commands::get_rule_import_history,
+            commands::import_commands_from_directory,
+            commands::scan_command_directory_import,
+            commands::import_skills_from_directory,
+            commands::scan_skill_directory_import,
             commands::export_configuration,
             commands::import_configuration,
             commands::preview_import,
diff --git a/src-tauri/src/models/command.rs b/src-tauri/src/models/command.rs
index 674b664..046686c 100644
--- a/src-tauri/src/models/command.rs
+++ b/src-tauri/src/models/command.rs
@@ -87,7 +87,7 @@ impl Command {
     }
 }
 
-#[derive(Debug, Clone, Serialize, Deserialize)]
+#[derive(Debug, Clone, Serialize, Deserialize, Default)]
 #[serde(rename_all = "camelCase")]
 pub struct CreateCommandInput {
     pub id: Option<String>,
diff --git a/src-tauri/src/models/import.rs b/src-tauri/src/models/import.rs
index bb5d9a9..a026886 100644
--- a/src-tauri/src/models/import.rs
+++ b/src-tauri/src/models/import.rs
@@ -1,7 +1,7 @@
 use chrono::{DateTime, Utc};
 use serde::{Deserialize, Serialize};
 
-use crate::models::{AdapterType, Rule, Scope};
+use crate::models::{AdapterType, Command, Rule, Scope, Skill};
 
 #[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
 #[serde(rename_all = "snake_case")]
@@ -64,8 +64,12 @@ pub struct ImportSkip {
 pub struct ImportConflict {
     pub candidate_id: String,
     pub candidate_name: String,
+    /// @deprecated use existing_id
     pub existing_rule_id: Option<String>,
+    /// @deprecated use existing_name
     pub existing_rule_name: Option<String>,
+    pub existing_id: Option<String>,
+    pub existing_name: Option<String>,
     pub reason: String,
 }
 
@@ -79,7 +83,11 @@ pub struct ImportScanResult {
 #[derive(Debug, Clone, Serialize, Deserialize, Default)]
 #[serde(rename_all = "camelCase")]
 pub struct ImportExecutionResult {
+    /// @deprecated use imported_rules
     pub imported: Vec<Rule>,
+    pub imported_rules: Vec<Rule>,
+    pub imported_commands: Vec<Command>,
+    pub imported_skills: Vec<Skill>,
     pub skipped: Vec<ImportSkip>,
     pub conflicts: Vec<ImportConflict>,
     pub errors: Vec<String>,
diff --git a/src-tauri/src/models/rule.rs b/src-tauri/src/models/rule.rs
index 6033dfc..be07a70 100644
--- a/src-tauri/src/models/rule.rs
+++ b/src-tauri/src/models/rule.rs
@@ -2,9 +2,10 @@ use chrono::{DateTime, Utc};
 use serde::{Deserialize, Serialize};
 use uuid::Uuid;
 
-#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
+#[derive(Debug, Clone, Copy, PartialEq, Eq, Default, Serialize, Deserialize)]
 #[serde(rename_all = "lowercase")]
 pub enum Scope {
+    #[default]
     Global,
     Local,
 }
diff --git a/src-tauri/src/models/skill.rs b/src-tauri/src/models/skill.rs
index 6cd0315..c47c906 100644
--- a/src-tauri/src/models/skill.rs
+++ b/src-tauri/src/models/skill.rs
@@ -211,7 +211,7 @@ pub fn validate_skill_entry_point(entry_point: &str) -> Result<()> {
     Ok(())
 }
 
-#[derive(Debug, Clone, Serialize, Deserialize)]
+#[derive(Debug, Clone, Serialize, Deserialize, Default)]
 #[serde(rename_all = "camelCase")]
 pub struct CreateSkillInput {
     pub id: Option<String>,
diff --git a/src-tauri/src/reconciliation/mod.rs b/src-tauri/src/reconciliation/mod.rs
index 82b9fe9..60cce57 100644
--- a/src-tauri/src/reconciliation/mod.rs
+++ b/src-tauri/src/reconciliation/mod.rs
@@ -1642,7 +1642,7 @@ mod tests {
         let desired = DesiredState::default();
 
         // Create actual state by scanning - user file should be SKIPPED
-        let mut actual = ActualState::default();
+        let actual = ActualState::default();
 
         // Directly scan the user file
         let scanned = engine
@@ -2262,7 +2262,9 @@ mod tests {
             db
         });
 
-        let engine = ReconciliationEngine::new(db).unwrap();
+        let mut path_resolver = crate::path_resolver::PathResolver::new().unwrap();
+        path_resolver.add_repository_root(std::path::PathBuf::from("/repo"));
+        let engine = ReconciliationEngine { db, path_resolver };
         let desired = rt.block_on(async { engine.compute_desired_state().await.unwrap() });
 
         let skill_entries: Vec<_> = desired
@@ -2274,7 +2276,7 @@ mod tests {
         // Local skills require registered repository roots
         // Since we don't have any registered, the count depends on the engine's behavior
         assert!(
-            skill_entries.len() >= 0,
+            !skill_entries.is_empty(),
             "Should handle local skills gracefully"
         );
 
diff --git a/src-tauri/src/rule_import/mod.rs b/src-tauri/src/rule_import/mod.rs
index fa13ee2..ab48cf1 100644
--- a/src-tauri/src/rule_import/mod.rs
+++ b/src-tauri/src/rule_import/mod.rs
@@ -2,20 +2,25 @@ use std::collections::{HashMap, HashSet};
 use std::fs;
 use std::net::IpAddr;
 use std::path::{Path, PathBuf};
+use std::sync::Arc;
 
 use chrono::Utc;
 use serde::Deserialize;
 use sha2::{Digest, Sha256};
 use walkdir::WalkDir;
 
-use crate::commands::{register_local_rule_paths, storage_location_for_rule, use_file_storage};
+use crate::commands::{
+    reconcile_after_mutation, register_local_rule_paths, storage_location_for_rule,
+    use_file_storage,
+};
 use crate::database::Database;
 use crate::error::{AppError, Result};
 use crate::file_storage;
 use crate::models::{
-    AdapterType, CreateRuleInput, ImportArtifactType, ImportCandidate, ImportConflict,
-    ImportConflictMode, ImportExecutionOptions, ImportExecutionResult, ImportHistoryEntry,
-    ImportScanResult, ImportSkip, Rule, Scope, UpdateRuleInput,
+    AdapterType, Command, CreateCommandInput, CreateRuleInput, CreateSkillInput,
+    ImportArtifactType, ImportCandidate, ImportConflict, ImportConflictMode,
+    ImportExecutionOptions, ImportExecutionResult, ImportHistoryEntry, ImportScanResult,
+    ImportSkip, Rule, Scope, Skill, UpdateCommandInput, UpdateRuleInput, UpdateSkillInput,
 };
 use crate::sync::SyncEngine;
 
@@ -76,6 +81,7 @@ pub async fn scan_url_to_candidates(url: &str, max_size: u64) -> Result<ImportSc
         None,
         Scope::Global,
         None,
+        ImportArtifactType::Rule,
     ));
     Ok(scan)
 }
@@ -98,10 +104,11 @@ pub fn scan_clipboard_to_candidates(
         inferred,
         crate::models::ImportSourceType::Clipboard,
         "Clipboard",
-        "clipboard",
+        "Clipboard",
         None,
         Scope::Global,
         None,
+        ImportArtifactType::Rule,
     ));
     Ok(scan)
 }
@@ -115,6 +122,7 @@ pub fn scan_file_to_candidates(path: &Path, max_size: u64) -> ImportScanResult {
         None,
         Scope::Global,
         None,
+        ImportArtifactType::Rule,
         max_size,
     ) {
         Ok(candidate) => scan.candidates.push(candidate),
@@ -123,7 +131,11 @@ pub fn scan_file_to_candidates(path: &Path, max_size: u64) -> ImportScanResult {
     scan
 }
 
-pub fn scan_directory_to_candidates(path: &Path, max_size: u64) -> ImportScanResult {
+pub fn scan_directory_to_candidates(
+    path: &Path,
+    max_size: u64,
+    artifact_filter: Option<ImportArtifactType>,
+) -> ImportScanResult {
     let mut scan = ImportScanResult::default();
     let canonical_root = match path.canonicalize() {
         Ok(p) => p,
@@ -151,82 +163,83 @@ pub fn scan_directory_to_candidates(path: &Path, max_size: u64) -> ImportScanRes
         .filter_map(|e| e.ok())
     {
         let item_path = entry.path();
-        
-        // Skip directories that contain slash commands or skills
-        if is_slash_command_or_skill_directory(item_path) {
-            continue;
-        }
-        
         if !item_path.is_file() {
             continue;
         }
 
-        if !is_supported_import_extension(item_path) {
-            continue;
+        let artifact_type = detect_artifact_type_from_path(item_path);
+        if let Some(filter) = artifact_filter {
+            if artifact_type != filter {
+                continue;
+            }
         }
 
-        // Skip files that are in slash command or skill locations
-        if detect_artifact_type_from_path(item_path) != ImportArtifactType::Rule {
+        if !is_supported_import_extension(item_path) {
             continue;
         }
 
         match candidate_from_path(
             item_path,
-            crate::models::ImportSourceType::Directory,
-            "Directory",
+            crate::models::ImportSourceType::File,
+            "File",
             None,
             Scope::Global,
             None,
+            artifact_type,
             max_size,
         ) {
             Ok(candidate) => {
                 if scan.candidates.len() >= MAX_IMPORT_CANDIDATES {
                     scan.errors.push(format!(
-                        "Import candidate limit reached ({}). Narrow directory scope or import in batches.",
+                        "Import candidate limit reached ({}). Narrow scan directory or import in batches.",
                         MAX_IMPORT_CANDIDATES
                     ));
-                    break;
+                    return scan;
                 }
-                scan.candidates.push(candidate)
+                scan.candidates.push(candidate);
             }
             Err(e) => scan.errors.push(e.to_string()),
         }
     }
+
+    apply_tool_suffix_name_policy(&mut scan.candidates);
     scan
 }
 
-pub async fn scan_ai_tool_candidates(db: &Database, max_size: u64) -> Result<ImportScanResult> {
+pub async fn scan_ai_tool_candidates(db: Arc<Database>, max_size: u64) -> Result<ImportScanResult> {
     let mut scan = ImportScanResult::default();
     let home = dirs::home_dir()
         .ok_or_else(|| AppError::Path("Could not determine home directory".to_string()))?;
 
-    // Only scan RULE paths, not slash commands or skills
     for tool_path in global_tool_paths(&home) {
-        // Skip non-rule artifacts
-        if tool_path.artifact_type != ImportArtifactType::Rule {
-            continue;
-        }
-
         if !tool_path.path.exists() {
             continue;
         }
 
-        if tool_path.path.is_file() {
+        let tp = tool_path.clone();
+        let label = adapter_label(tp.adapter);
+
+        if tp.path.is_file() {
             match candidate_from_path(
-                &tool_path.path,
+                &tp.path,
                 crate::models::ImportSourceType::AiTool,
-                adapter_label(tool_path.adapter),
-                Some(tool_path.adapter),
+                label,
+                Some(tp.adapter),
                 Scope::Global,
                 None,
+                tp.artifact_type,
                 max_size,
             ) {
                 Ok(candidate) => scan.candidates.push(candidate),
                 Err(e) => scan.errors.push(e.to_string()),
             }
         } else if tool_path.path.is_dir() {
-            // When scanning directories, only include rule-like files, not slash commands or skills
-            let inner_scan = scan_directory_for_rules(&tool_path.path, tool_path.adapter, max_size);
+            let inner_scan = scan_directory_for_artifact_type(
+                &tool_path.path,
+                tool_path.adapter,
+                max_size,
+                tool_path.artifact_type,
+            );
             for mut candidate in inner_scan.candidates {
                 candidate.source_type = crate::models::ImportSourceType::AiTool;
                 candidate.source_tool = Some(tool_path.adapter);
@@ -239,13 +252,8 @@ pub async fn scan_ai_tool_candidates(db: &Database, max_size: u64) -> Result<Imp
         }
     }
 
-    for local_root in get_local_rule_roots(db).await {
+    for local_root in get_local_rule_roots(db.clone()).await {
         for local_path in local_tool_paths() {
-            // Skip non-rule artifacts
-            if local_path.artifact_type != ImportArtifactType::Rule {
-                continue;
-            }
-
             let path = local_root.join(local_path.relative_path);
             if !path.exists() || !path.is_file() {
                 continue;
@@ -258,6 +266,7 @@ pub async fn scan_ai_tool_candidates(db: &Database, max_size: u64) -> Result<Imp
                 Some(local_path.adapter),
                 Scope::Local,
                 Some(vec![local_root.to_string_lossy().to_string()]),
+                local_path.artifact_type,
                 max_size,
             ) {
                 Ok(candidate) => {
@@ -279,8 +288,13 @@ pub async fn scan_ai_tool_candidates(db: &Database, max_size: u64) -> Result<Imp
     Ok(scan)
 }
 
-/// Scan a directory for rule files, excluding slash command and skill directories
-fn scan_directory_for_rules(dir: &Path, adapter: AdapterType, max_size: u64) -> ImportScanResult {
+/// Scan a directory for a specific artifact type, excluding other artifact directories
+fn scan_directory_for_artifact_type(
+    dir: &Path,
+    adapter: AdapterType,
+    max_size: u64,
+    artifact_type_filter: ImportArtifactType,
+) -> ImportScanResult {
     let mut scan = ImportScanResult::default();
 
     for entry in WalkDir::new(dir)
@@ -289,12 +303,14 @@ fn scan_directory_for_rules(dir: &Path, adapter: AdapterType, max_size: u64) ->
         .filter_map(|e| e.ok())
     {
         let item_path = entry.path();
-        
-        // Skip directories that contain slash commands or skills
-        if is_slash_command_or_skill_directory(item_path) {
+
+        // Skip directories that contain other artifact types
+        if is_slash_command_or_skill_directory(item_path)
+            && artifact_type_filter == ImportArtifactType::Rule
+        {
             continue;
         }
-        
+
         if !item_path.is_file() {
             continue;
         }
@@ -303,8 +319,8 @@ fn scan_directory_for_rules(dir: &Path, adapter: AdapterType, max_size: u64) ->
             continue;
         }
 
-        // Double-check: detect artifact type from path and skip non-rules
-        if detect_artifact_type_from_path(item_path) != ImportArtifactType::Rule {
+        // Double-check: detect artifact type from path and skip if it doesn't match the filter
+        if detect_artifact_type_from_path(item_path) != artifact_type_filter {
             continue;
         }
 
@@ -315,6 +331,7 @@ fn scan_directory_for_rules(dir: &Path, adapter: AdapterType, max_size: u64) ->
             Some(adapter),
             Scope::Global,
             None,
+            artifact_type_filter,
             max_size,
         ) {
             Ok(candidate) => {
@@ -337,7 +354,7 @@ fn scan_directory_for_rules(dir: &Path, adapter: AdapterType, max_size: u64) ->
 /// Check if a path is within a slash command or skill directory
 fn is_slash_command_or_skill_directory(path: &Path) -> bool {
     let path_str = path.to_string_lossy().to_lowercase();
-    
+
     // Slash command directory patterns (case-insensitive)
     let slash_command_patterns = [
         "/commands/",
@@ -347,31 +364,27 @@ fn is_slash_command_or_skill_directory(path: &Path) -> bool {
         "\\commands\\",
         "\\workflows\\",
     ];
-    
+
     // Skill directory patterns (case-insensitive)
-    let skill_patterns = [
-        "/skills/",
-        "/documents/cline/skills/",
-        "\\skills\\",
-    ];
-    
+    let skill_patterns = ["/skills/", "/documents/cline/skills/", "\\skills\\"];
+
     for pattern in &slash_command_patterns {
         if path_str.contains(pattern) {
             return true;
         }
     }
-    
+
     for pattern in &skill_patterns {
         if path_str.contains(pattern) {
             return true;
         }
     }
-    
+
     false
 }
 
 pub async fn execute_import(
-    db: &Database,
+    db: Arc<Database>,
     scan_result: ImportScanResult,
     options: ImportExecutionOptions,
 ) -> Result<ImportExecutionResult> {
@@ -387,7 +400,9 @@ pub async fn execute_import(
         .as_ref()
         .map(|ids| ids.iter().cloned().collect::<HashSet<String>>());
     let mut existing_rules = db.get_all_rules().await?;
-    let mut source_map = read_source_map(db).await;
+    let mut existing_commands = db.get_all_commands().await?;
+    let mut existing_skills = db.get_all_skills().await?;
+    let mut source_map = read_source_map(db.clone()).await;
 
     for candidate in scan_result.candidates {
         if let Some(selected) = selected_set.as_ref() {
@@ -412,58 +427,116 @@ pub async fn execute_import(
             continue;
         }
 
-        if let Some(existing_exact) = existing_rules
-            .iter()
-            .find(|r| compute_content_hash(&r.content) == candidate.content_hash)
-        {
+        if let Some(existing_exact_id) = match candidate.artifact_type {
+            ImportArtifactType::Rule => existing_rules
+                .iter()
+                .find(|r| compute_content_hash(&r.content) == candidate.content_hash)
+                .map(|r| r.name.clone()),
+            ImportArtifactType::SlashCommand => existing_commands
+                .iter()
+                .find(|c| compute_content_hash(&c.script) == candidate.content_hash)
+                .map(|c| c.name.clone()),
+            ImportArtifactType::Skill => existing_skills
+                .iter()
+                .find(|s| compute_content_hash(&s.instructions) == candidate.content_hash)
+                .map(|s| s.name.clone()),
+        } {
             result.skipped.push(ImportSkip {
                 candidate_id: candidate.id.clone(),
                 name: candidate.proposed_name.clone(),
                 reason: format!(
                     "Duplicate content already exists as '{}'",
-                    existing_exact.name
+                    existing_exact_id
                 ),
             });
             continue;
         }
 
-        let mapped_rule_id = source_map.get(&source_key).cloned();
-        if let Some(rule_id) = mapped_rule_id {
-            let update = db
-                .update_rule(
-                    &rule_id,
-                    UpdateRuleInput {
-                        name: Some(candidate.proposed_name.clone()),
-                        description: None, // Keep existing description
-                        content: Some(candidate.content.clone()),
-                        scope: Some(effective_scope),
-                        target_paths: candidate.target_paths.clone(),
-                        enabled_adapters: Some(effective_adapters.clone()),
-                        enabled: Some(true),
-                    },
-                )
-                .await?;
-
-            persist_rule_to_file_if_needed(db, &update).await?;
-            existing_rules.retain(|r| r.id != update.id);
-            existing_rules.push(update.clone());
-            result.imported.push(update);
+        let mapped_artifact_id = source_map.get(&source_key).cloned();
+        if let Some(artifact_id) = mapped_artifact_id {
+            match candidate.artifact_type {
+                ImportArtifactType::Rule => {
+                    let update = db
+                        .update_rule(
+                            &artifact_id,
+                            UpdateRuleInput {
+                                name: Some(candidate.proposed_name.clone()),
+                                description: None,
+                                content: Some(candidate.content.clone()),
+                                scope: Some(effective_scope),
+                                target_paths: candidate.target_paths.clone(),
+                                enabled_adapters: Some(effective_adapters.clone()),
+                                enabled: Some(true),
+                            },
+                        )
+                        .await?;
+                    persist_rule_to_file_if_needed(db.clone(), &update).await?;
+                    existing_rules.retain(|r| r.id != update.id);
+                    existing_rules.push(update.clone());
+                    result.imported_rules.push(update.clone());
+                    result.imported.push(update);
+                }
+                ImportArtifactType::SlashCommand => {
+                    let update = db
+                        .update_command(
+                            &artifact_id,
+                            UpdateCommandInput {
+                                name: Some(candidate.proposed_name.clone()),
+                                script: Some(candidate.content.clone()),
+                                ..Default::default()
+                            },
+                        )
+                        .await?;
+                    // Persistence for commands
+                    persist_command_to_file_if_needed(db.clone(), &update).await?;
+                    existing_commands.retain(|c| c.id != update.id);
+                    existing_commands.push(update.clone());
+                    result.imported_commands.push(update);
+                }
+                ImportArtifactType::Skill => {
+                    let update = db
+                        .update_skill(
+                            &artifact_id,
+                            UpdateSkillInput {
+                                name: Some(candidate.proposed_name.clone()),
+                                instructions: Some(candidate.content.clone()),
+                                ..Default::default()
+                            },
+                        )
+                        .await?;
+                    // Persistence for skills
+                    persist_skill_to_file_if_needed(db.clone(), &update).await?;
+                    existing_skills.retain(|s| s.id != update.id);
+                    existing_skills.push(update.clone());
+                    result.imported_skills.push(update);
+                }
+            }
             continue;
         }
 
-        let same_name = existing_rules
-            .iter()
-            .find(|r| r.name.eq_ignore_ascii_case(&candidate.proposed_name))
-            .cloned();
-
-        if let Some(existing_same_name) = same_name {
-            if existing_same_name.content == candidate.content {
+        let same_name_id = match candidate.artifact_type {
+            ImportArtifactType::Rule => existing_rules
+                .iter()
+                .find(|r| r.name.eq_ignore_ascii_case(&candidate.proposed_name))
+                .map(|r| (r.id.clone(), r.name.clone(), r.content.clone())),
+            ImportArtifactType::SlashCommand => existing_commands
+                .iter()
+                .find(|c| c.name.eq_ignore_ascii_case(&candidate.proposed_name))
+                .map(|c| (c.id.clone(), c.name.clone(), c.script.clone())),
+            ImportArtifactType::Skill => existing_skills
+                .iter()
+                .find(|s| s.name.eq_ignore_ascii_case(&candidate.proposed_name))
+                .map(|s| (s.id.clone(), s.name.clone(), s.instructions.clone())),
+        };
+
+        if let Some((existing_id, existing_name, existing_content)) = same_name_id {
+            if existing_content == candidate.content {
                 result.skipped.push(ImportSkip {
                     candidate_id: candidate.id.clone(),
                     name: candidate.proposed_name.clone(),
                     reason: format!(
                         "Duplicate name and content already exists as '{}'",
-                        existing_same_name.name
+                        existing_name
                     ),
                 });
                 continue;
@@ -474,90 +547,212 @@ pub async fn execute_import(
                     result.conflicts.push(ImportConflict {
                         candidate_id: candidate.id.clone(),
                         candidate_name: candidate.proposed_name.clone(),
-                        existing_rule_id: Some(existing_same_name.id.clone()),
-                        existing_rule_name: Some(existing_same_name.name.clone()),
+                        existing_rule_id: Some(existing_id.clone()),
+                        existing_rule_name: Some(existing_name.clone()),
+                        existing_id: Some(existing_id),
+                        existing_name: Some(existing_name),
                         reason: "Name collision with different content".to_string(),
                     });
                     continue;
                 }
                 ImportConflictMode::Replace => {
-                    let update = db
-                        .update_rule(
-                            &existing_same_name.id,
-                            UpdateRuleInput {
-                                name: Some(candidate.proposed_name.clone()),
-                                description: None, // Keep existing description
-                                content: Some(candidate.content.clone()),
-                                scope: Some(effective_scope),
-                                target_paths: candidate.target_paths.clone(),
-                                enabled_adapters: Some(effective_adapters.clone()),
-                                enabled: Some(true),
-                            },
-                        )
-                        .await?;
-                    persist_rule_to_file_if_needed(db, &update).await?;
-                    source_map.insert(source_key, update.id.clone());
-                    existing_rules.retain(|r| r.id != update.id);
-                    existing_rules.push(update.clone());
-                    result.imported.push(update);
+                    match candidate.artifact_type {
+                        ImportArtifactType::Rule => {
+                            let update = db
+                                .update_rule(
+                                    &existing_id,
+                                    UpdateRuleInput {
+                                        name: Some(candidate.proposed_name.clone()),
+                                        description: None,
+                                        content: Some(candidate.content.clone()),
+                                        scope: Some(effective_scope),
+                                        target_paths: candidate.target_paths.clone(),
+                                        enabled_adapters: Some(effective_adapters.clone()),
+                                        enabled: Some(true),
+                                    },
+                                )
+                                .await?;
+                            persist_rule_to_file_if_needed(db.clone(), &update).await?;
+                            source_map.insert(source_key, update.id.clone());
+                            existing_rules.retain(|r| r.id != update.id);
+                            existing_rules.push(update.clone());
+                            result.imported_rules.push(update.clone());
+                            result.imported.push(update);
+                        }
+                        ImportArtifactType::SlashCommand => {
+                            let update = db
+                                .update_command(
+                                    &existing_id,
+                                    UpdateCommandInput {
+                                        name: Some(candidate.proposed_name.clone()),
+                                        script: Some(candidate.content.clone()),
+                                        ..Default::default()
+                                    },
+                                )
+                                .await?;
+                            persist_command_to_file_if_needed(db.clone(), &update).await?;
+                            source_map.insert(source_key, update.id.clone());
+                            existing_commands.retain(|c| c.id != update.id);
+                            existing_commands.push(update.clone());
+                            result.imported_commands.push(update);
+                        }
+                        ImportArtifactType::Skill => {
+                            let update = db
+                                .update_skill(
+                                    &existing_id,
+                                    UpdateSkillInput {
+                                        name: Some(candidate.proposed_name.clone()),
+                                        instructions: Some(candidate.content.clone()),
+                                        ..Default::default()
+                                    },
+                                )
+                                .await?;
+                            persist_skill_to_file_if_needed(db.clone(), &update).await?;
+                            source_map.insert(source_key, update.id.clone());
+                            existing_skills.retain(|s| s.id != update.id);
+                            existing_skills.push(update.clone());
+                            result.imported_skills.push(update);
+                        }
+                    }
                     continue;
                 }
                 ImportConflictMode::Rename => {
-                    let unique_name = make_unique_name(
-                        &candidate.proposed_name,
-                        &existing_rules
-                            .iter()
-                            .map(|r| r.name.clone())
-                            .collect::<Vec<_>>(),
-                    );
-
-                    let created = db
-                        .create_rule(CreateRuleInput {
-                            id: None,
-                            name: unique_name,
-                            description: String::new(), // Default for imported rules
-                            content: candidate.content.clone(),
-                            scope: effective_scope,
-                            target_paths: candidate.target_paths.clone(),
-                            enabled_adapters: effective_adapters.clone(),
-                            enabled: true,
-                        })
-                        .await?;
-                    persist_rule_to_file_if_needed(db, &created).await?;
-                    source_map.insert(source_key, created.id.clone());
-                    existing_rules.push(created.clone());
-                    result.imported.push(created);
+                    let unique_name = match candidate.artifact_type {
+                        ImportArtifactType::Rule => make_unique_name(
+                            &candidate.proposed_name,
+                            &existing_rules
+                                .iter()
+                                .map(|r| r.name.clone())
+                                .collect::<Vec<_>>(),
+                        ),
+                        ImportArtifactType::SlashCommand => make_unique_name(
+                            &candidate.proposed_name,
+                            &existing_commands
+                                .iter()
+                                .map(|c| c.name.clone())
+                                .collect::<Vec<_>>(),
+                        ),
+                        ImportArtifactType::Skill => make_unique_name(
+                            &candidate.proposed_name,
+                            &existing_skills
+                                .iter()
+                                .map(|s| s.name.clone())
+                                .collect::<Vec<_>>(),
+                        ),
+                    };
+
+                    match candidate.artifact_type {
+                        ImportArtifactType::Rule => {
+                            let created = db
+                                .create_rule(CreateRuleInput {
+                                    id: None,
+                                    name: unique_name,
+                                    description: String::new(),
+                                    content: candidate.content.clone(),
+                                    scope: effective_scope,
+                                    target_paths: candidate.target_paths.clone(),
+                                    enabled_adapters: effective_adapters.clone(),
+                                    enabled: true,
+                                })
+                                .await?;
+                            persist_rule_to_file_if_needed(db.clone(), &created).await?;
+                            source_map.insert(source_key, created.id.clone());
+                            existing_rules.push(created.clone());
+                            result.imported_rules.push(created.clone());
+                            result.imported.push(created);
+                        }
+                        ImportArtifactType::SlashCommand => {
+                            let created = db
+                                .create_command(CreateCommandInput {
+                                    name: unique_name,
+                                    script: candidate.content.clone(),
+                                    ..Default::default()
+                                })
+                                .await?;
+                            persist_command_to_file_if_needed(db.clone(), &created).await?;
+                            source_map.insert(source_key, created.id.clone());
+                            existing_commands.push(created.clone());
+                            result.imported_commands.push(created);
+                        }
+                        ImportArtifactType::Skill => {
+                            let created = db
+                                .create_skill(CreateSkillInput {
+                                    name: unique_name,
+                                    instructions: candidate.content.clone(),
+                                    ..Default::default()
+                                })
+                                .await?;
+                            persist_skill_to_file_if_needed(db.clone(), &created).await?;
+                            source_map.insert(source_key, created.id.clone());
+                            existing_skills.push(created.clone());
+                            result.imported_skills.push(created);
+                        }
+                    }
                     continue;
                 }
             }
         }
 
-        let created = db
-            .create_rule(CreateRuleInput {
-                id: None,
-                name: candidate.proposed_name.clone(),
-                description: String::new(), // Default for imported rules
-                content: candidate.content.clone(),
-                scope: effective_scope,
-                target_paths: candidate.target_paths.clone(),
-                enabled_adapters: effective_adapters,
-                enabled: true,
-            })
-            .await?;
-        persist_rule_to_file_if_needed(db, &created).await?;
-        source_map.insert(source_key, created.id.clone());
-        existing_rules.push(created.clone());
-        result.imported.push(created);
+        match candidate.artifact_type {
+            ImportArtifactType::Rule => {
+                let created = db
+                    .create_rule(CreateRuleInput {
+                        id: None,
+                        name: candidate.proposed_name.clone(),
+                        description: String::new(),
+                        content: candidate.content.clone(),
+                        scope: effective_scope,
+                        target_paths: candidate.target_paths.clone(),
+                        enabled_adapters: effective_adapters,
+                        enabled: true,
+                    })
+                    .await?;
+                persist_rule_to_file_if_needed(db.clone(), &created).await?;
+                source_map.insert(source_key, created.id.clone());
+                existing_rules.retain(|r| r.id != created.id); // Guard against DB race
+                existing_rules.push(created.clone());
+                result.imported_rules.push(created.clone());
+                result.imported.push(created);
+            }
+            ImportArtifactType::SlashCommand => {
+                let created = db
+                    .create_command(CreateCommandInput {
+                        name: candidate.proposed_name.clone(),
+                        script: candidate.content.clone(),
+                        ..Default::default()
+                    })
+                    .await?;
+                persist_command_to_file_if_needed(db.clone(), &created).await?;
+                source_map.insert(source_key, created.id.clone());
+                existing_commands.push(created.clone());
+                result.imported_commands.push(created);
+            }
+            ImportArtifactType::Skill => {
+                let created = db
+                    .create_skill(CreateSkillInput {
+                        name: candidate.proposed_name.clone(),
+                        instructions: candidate.content.clone(),
+                        ..Default::default()
+                    })
+                    .await?;
+                persist_skill_to_file_if_needed(db.clone(), &created).await?;
+                source_map.insert(source_key, created.id.clone());
+                existing_skills.push(created.clone());
+                result.imported_skills.push(created);
+            }
+        }
     }
 
-    write_source_map(db, &source_map).await?;
+    write_source_map(db.clone(), &source_map).await?;
     append_history(
-        db,
+        db.clone(),
         ImportHistoryEntry {
             id: uuid::Uuid::new_v4().to_string(),
             timestamp: Utc::now(),
             source_type: history_source_type,
-            imported_count: result.imported.len(),
+            imported_count: result.imported_rules.len()
+                + result.imported_commands.len()
+                + result.imported_skills.len(),
             skipped_count: result.skipped.len(),
             conflict_count: result.conflicts.len(),
             error_count: result.errors.len() + scan_errors.len(),
@@ -565,7 +760,7 @@ pub async fn execute_import(
     )
     .await?;
 
-    let engine = SyncEngine::new(db);
+    let engine = SyncEngine::new(&db);
     let all_rules = db.get_all_rules().await?;
     let sync_res = engine.sync_all(all_rules);
     for err in sync_res.await.errors {
@@ -574,6 +769,10 @@ pub async fn execute_import(
             err.adapter_name, err.message
         ));
     }
+
+    // Comprehensive reconciliation to ensure all artifact types are synced to disk
+    reconcile_after_mutation(db.clone()).await;
+
     for err in scan_errors {
         result.errors.push(err);
     }
@@ -581,16 +780,16 @@ pub async fn execute_import(
     Ok(result)
 }
 
-pub async fn read_import_history(db: &Database) -> Vec<ImportHistoryEntry> {
-    let json = match db.get_setting(IMPORT_HISTORY_KEY).await {
-        Ok(Some(value)) => value,
+pub async fn read_import_history(db: Arc<Database>) -> Vec<ImportHistoryEntry> {
+    let encoded = match db.get_setting(IMPORT_HISTORY_KEY).await {
+        Ok(Some(v)) => v,
         _ => return Vec::new(),
     };
-    serde_json::from_str(&json).unwrap_or_default()
+    serde_json::from_str(&encoded).unwrap_or_default()
 }
 
-async fn append_history(db: &Database, entry: ImportHistoryEntry) -> Result<()> {
-    let mut history = read_import_history(db).await;
+async fn append_history(db: Arc<Database>, entry: ImportHistoryEntry) -> Result<()> {
+    let mut history = read_import_history(db.clone()).await;
     history.insert(0, entry);
     if history.len() > 50 {
         history.truncate(50);
@@ -599,17 +798,39 @@ async fn append_history(db: &Database, entry: ImportHistoryEntry) -> Result<()>
     db.set_setting(IMPORT_HISTORY_KEY, &encoded).await
 }
 
-async fn persist_rule_to_file_if_needed(db: &Database, rule: &Rule) -> Result<()> {
-    if use_file_storage(db).await {
+async fn persist_rule_to_file_if_needed(db: Arc<Database>, rule: &Rule) -> Result<()> {
+    if use_file_storage(&db).await {
         let location = storage_location_for_rule(rule);
         file_storage::save_rule_to_disk(rule, &location)?;
         db.update_rule_file_index(&rule.id, &location).await?;
-        register_local_rule_paths(db, rule).await?;
+        register_local_rule_paths(&db, rule).await?;
+    }
+    Ok(())
+}
+
+async fn persist_command_to_file_if_needed(db: Arc<Database>, command: &Command) -> Result<()> {
+    if use_file_storage(&db).await {
+        // Commands and skills are currently managed via reconciliation which handles periodic sync.
+        // For individual mutations, we trigger a global reconciliation at the end of execution.
+        log::debug!(
+            "Mutation for command {} recorded. Persistence will be handled by final reconciliation.",
+            command.id
+        );
+    }
+    Ok(())
+}
+
+async fn persist_skill_to_file_if_needed(db: Arc<Database>, skill: &Skill) -> Result<()> {
+    if use_file_storage(&db).await {
+        log::debug!(
+            "Mutation for skill {} recorded. Persistence will be handled by final reconciliation.",
+            skill.id
+        );
     }
     Ok(())
 }
 
-async fn get_local_rule_roots(db: &Database) -> Vec<PathBuf> {
+async fn get_local_rule_roots(db: Arc<Database>) -> Vec<PathBuf> {
     let roots_json = db
         .get_setting(LOCAL_RULE_PATHS_KEY)
         .await
@@ -620,7 +841,7 @@ async fn get_local_rule_roots(db: &Database) -> Vec<PathBuf> {
     roots.into_iter().map(PathBuf::from).collect()
 }
 
-async fn read_source_map(db: &Database) -> HashMap<String, String> {
+async fn read_source_map(db: Arc<Database>) -> HashMap<String, String> {
     let encoded = match db.get_setting(IMPORT_SOURCE_MAP_KEY).await {
         Ok(Some(v)) => v,
         _ => return HashMap::new(),
@@ -628,7 +849,7 @@ async fn read_source_map(db: &Database) -> HashMap<String, String> {
     serde_json::from_str(&encoded).unwrap_or_default()
 }
 
-async fn write_source_map(db: &Database, map: &HashMap<String, String>) -> Result<()> {
+async fn write_source_map(db: Arc<Database>, map: &HashMap<String, String>) -> Result<()> {
     let encoded = serde_json::to_string(map)?;
     db.set_setting(IMPORT_SOURCE_MAP_KEY, &encoded).await
 }
@@ -691,7 +912,7 @@ struct LocalToolPath {
 fn detect_artifact_type_from_path(path: &Path) -> ImportArtifactType {
     let path_str = path.to_string_lossy().to_lowercase();
     let path_str_lower = path_str.to_lowercase();
-    
+
     // Slash command directories - these are workflow/command files
     let slash_command_patterns = [
         "/commands/",
@@ -703,28 +924,24 @@ fn detect_artifact_type_from_path(path: &Path) -> ImportArtifactType {
         ".agents/workflows",
         ".clinerules/workflows",
     ];
-    
+
     // Skill directories - these contain skill definitions
-    let skill_patterns = [
-        "/skills/",
-        "\\skills\\",
-        "documents/cline/skills",
-    ];
-    
+    let skill_patterns = ["/skills/", "\\skills\\", "documents/cline/skills"];
+
     // Check for slash command patterns
     for pattern in &slash_command_patterns {
         if path_str_lower.contains(pattern) {
             return ImportArtifactType::SlashCommand;
         }
     }
-    
+
     // Check for skill patterns
     for pattern in &skill_patterns {
         if path_str_lower.contains(pattern) {
             return ImportArtifactType::Skill;
         }
     }
-    
+
     // Default to rule
     ImportArtifactType::Rule
 }
@@ -832,6 +1049,36 @@ fn global_tool_paths(home: &Path) -> Vec<ToolPath> {
             path: home.join(".roocode").join("rules").join("rules.md"),
             artifact_type: ImportArtifactType::Rule,
         },
+        // Slash Command Paths
+        ToolPath {
+            adapter: AdapterType::Antigravity,
+            path: home
+                .join(".gemini")
+                .join("antigravity")
+                .join("global_workflows"),
+            artifact_type: ImportArtifactType::SlashCommand,
+        },
+        ToolPath {
+            adapter: AdapterType::Cline,
+            path: home.join("Documents").join("Cline").join("Workflows"),
+            artifact_type: ImportArtifactType::SlashCommand,
+        },
+        ToolPath {
+            adapter: AdapterType::RooCode,
+            path: home.join(".roo").join("workflows"),
+            artifact_type: ImportArtifactType::SlashCommand,
+        },
+        // Skill Paths
+        ToolPath {
+            adapter: AdapterType::Cline,
+            path: home.join("Documents").join("Cline").join("Skills"),
+            artifact_type: ImportArtifactType::Skill,
+        },
+        ToolPath {
+            adapter: AdapterType::RooCode,
+            path: home.join(".roo").join("skills"),
+            artifact_type: ImportArtifactType::Skill,
+        },
     ]
 }
 
@@ -918,6 +1165,23 @@ fn local_tool_paths() -> Vec<LocalToolPath> {
             relative_path: ".roo/rules/rules.md",
             artifact_type: ImportArtifactType::Rule,
         },
+        // Local Workflows
+        LocalToolPath {
+            adapter: AdapterType::Gemini,
+            relative_path: ".agents/workflows",
+            artifact_type: ImportArtifactType::SlashCommand,
+        },
+        LocalToolPath {
+            adapter: AdapterType::Antigravity,
+            relative_path: ".gemini/antigravity/workflows",
+            artifact_type: ImportArtifactType::SlashCommand,
+        },
+        // Local Skills
+        LocalToolPath {
+            adapter: AdapterType::Gemini,
+            relative_path: ".agents/skills",
+            artifact_type: ImportArtifactType::Skill,
+        },
     ]
 }
 
@@ -936,6 +1200,7 @@ fn adapter_label(adapter: AdapterType) -> &'static str {
     }
 }
 
+#[allow(clippy::too_many_arguments)]
 fn candidate_from_path(
     path: &Path,
     source_type: crate::models::ImportSourceType,
@@ -943,6 +1208,7 @@ fn candidate_from_path(
     source_tool: Option<AdapterType>,
     scope: Scope,
     target_paths: Option<Vec<String>>,
+    artifact_type: ImportArtifactType,
     max_size: u64,
 ) -> Result<ImportCandidate> {
     let metadata = fs::metadata(path)?;
@@ -976,6 +1242,7 @@ fn candidate_from_path(
         source_tool,
         scope,
         target_paths,
+        artifact_type,
     ))
 }
 
@@ -989,9 +1256,20 @@ fn candidate_from_text(
     source_tool: Option<AdapterType>,
     scope: Scope,
     target_paths: Option<Vec<String>>,
+    artifact_type: ImportArtifactType,
 ) -> ImportCandidate {
     let (name, parsed_content, parsed_scope, parsed_target_paths, parsed_adapters) =
-        extract_rule_payload(default_name, &content, scope, target_paths, source_tool);
+        if artifact_type == ImportArtifactType::Rule {
+            extract_rule_payload(default_name, &content, scope, target_paths, source_tool)
+        } else {
+            (
+                default_name.to_string(),
+                content.clone(),
+                scope,
+                target_paths,
+                default_adapters(source_tool),
+            )
+        };
 
     let content_hash = compute_content_hash(&parsed_content);
     ImportCandidate {
@@ -1008,7 +1286,7 @@ fn candidate_from_text(
         enabled_adapters: parsed_adapters,
         content_hash,
         file_size: parsed_content.len() as u64,
-        artifact_type: ImportArtifactType::Rule,
+        artifact_type,
     }
 }
 
@@ -1240,6 +1518,7 @@ mod tests {
                 Some(AdapterType::Cline),
                 Scope::Global,
                 None,
+                ImportArtifactType::Rule,
             ),
             candidate_from_text(
                 content,
@@ -1250,6 +1529,7 @@ mod tests {
                 Some(AdapterType::Antigravity),
                 Scope::Global,
                 None,
+                ImportArtifactType::Rule,
             ),
         ];
 
@@ -1264,8 +1544,8 @@ mod tests {
     }
 
     #[tokio::test]
-    async fn execute_import_skips_duplicate_content() {
-        let db = Database::new_in_memory().await.expect("in-memory db");
+    async fn execute_import_skips_duplicates_by_content() {
+        let db = Arc::new(Database::new_in_memory().await.expect("in-memory db"));
         db.create_rule(CreateRuleInput {
             id: None,
             name: "Existing".to_string(),
@@ -1288,10 +1568,11 @@ mod tests {
             None,
             Scope::Global,
             None,
+            ImportArtifactType::Rule,
         );
 
         let result = execute_import(
-            &db,
+            db.clone(),
             ImportScanResult {
                 candidates: vec![candidate],
                 errors: vec![],
@@ -1307,7 +1588,7 @@ mod tests {
 
     #[tokio::test]
     async fn execute_import_rename_mode_creates_unique_name() {
-        let db = Database::new_in_memory().await.expect("in-memory db");
+        let db = Arc::new(Database::new_in_memory().await.expect("in-memory db"));
         db.create_rule(CreateRuleInput {
             id: None,
             name: "quality".to_string(),
@@ -1330,14 +1611,17 @@ mod tests {
             None,
             Scope::Global,
             None,
+            ImportArtifactType::Rule,
         );
 
+        let scan_result = ImportScanResult {
+            candidates: vec![candidate],
+            errors: vec![],
+        };
+
         let result = execute_import(
-            &db,
-            ImportScanResult {
-                candidates: vec![candidate],
-                errors: vec![],
-            },
+            db.clone(),
+            scan_result,
             ImportExecutionOptions {
                 conflict_mode: ImportConflictMode::Rename,
                 ..Default::default()
@@ -1352,7 +1636,7 @@ mod tests {
 
     #[tokio::test]
     async fn execute_import_replace_mode_updates_existing_rule() {
-        let db = Database::new_in_memory().await.expect("in-memory db");
+        let db = Arc::new(Database::new_in_memory().await.expect("in-memory db"));
         let existing = db
             .create_rule(CreateRuleInput {
                 id: None,
@@ -1376,14 +1660,17 @@ mod tests {
             None,
             Scope::Global,
             None,
+            ImportArtifactType::Rule,
         );
 
+        let scan_result = ImportScanResult {
+            candidates: vec![candidate],
+            errors: vec![],
+        };
+
         let result = execute_import(
-            &db,
-            ImportScanResult {
-                candidates: vec![candidate],
-                errors: vec![],
-            },
+            db.clone(),
+            scan_result,
             ImportExecutionOptions {
                 conflict_mode: ImportConflictMode::Replace,
                 ..Default::default()
@@ -1469,7 +1756,7 @@ enabledAdapters:
 
     #[tokio::test]
     async fn execute_import_reimport_updates_mapped_rule_idempotently() {
-        let db = Database::new_in_memory().await.expect("in-memory db");
+        let db = Arc::new(Database::new_in_memory().await.expect("in-memory db"));
 
         let first_candidate = candidate_from_text(
             "original content".to_string(),
@@ -1480,10 +1767,11 @@ enabledAdapters:
             None,
             Scope::Global,
             None,
+            ImportArtifactType::Rule,
         );
 
         let first_result = execute_import(
-            &db,
+            db.clone(),
             ImportScanResult {
                 candidates: vec![first_candidate],
                 errors: vec![],
@@ -1505,10 +1793,11 @@ enabledAdapters:
             None,
             Scope::Global,
             None,
+            ImportArtifactType::Rule,
         );
 
         let second_result = execute_import(
-            &db,
+            db.clone(),
             ImportScanResult {
                 candidates: vec![second_candidate],
                 errors: vec![],
@@ -1546,7 +1835,7 @@ enabledAdapters:
 
     #[tokio::test]
     async fn history_source_type_matches_candidate_source() {
-        let db = Database::new_in_memory().await.expect("in-memory db");
+        let db = Arc::new(Database::new_in_memory().await.expect("in-memory db"));
 
         let candidate = candidate_from_text(
             "file content".to_string(),
@@ -1557,10 +1846,11 @@ enabledAdapters:
             None,
             Scope::Global,
             None,
+            ImportArtifactType::Rule,
         );
 
         execute_import(
-            &db,
+            db.clone(),
             ImportScanResult {
                 candidates: vec![candidate],
                 errors: vec![],
@@ -1570,7 +1860,7 @@ enabledAdapters:
         .await
         .expect("import succeeds");
 
-        let history = read_import_history(&db).await;
+        let history = read_import_history(db.clone()).await;
         assert!(!history.is_empty());
         assert_eq!(
             history[0].source_type,
@@ -1587,7 +1877,7 @@ enabledAdapters:
         ));
         fs::write(&temp_file, "test").expect("write temp file");
 
-        let result = scan_directory_to_candidates(&temp_file, 1024);
+        let result = scan_directory_to_candidates(&temp_file, 1024, None);
         assert!(!result.errors.is_empty());
 
         let _ = fs::remove_file(temp_file);
@@ -1611,7 +1901,7 @@ enabledAdapters:
         assert!(global
             .iter()
             .any(|p| p.contains(".kilo") && p.contains("AGENTS.md")));
-        
+
         // Verify no slash command or skill directories are included in rule paths
         assert!(!global.iter().any(|p| p.contains("/commands/")));
         assert!(!global.iter().any(|p| p.contains("/workflows/")));
@@ -1640,11 +1930,15 @@ enabledAdapters:
             ImportArtifactType::SlashCommand
         );
         assert_eq!(
-            detect_artifact_type_from_path(Path::new("/home/Documents/Cline/Workflows/my-workflow.md")),
+            detect_artifact_type_from_path(Path::new(
+                "/home/Documents/Cline/Workflows/my-workflow.md"
+            )),
             ImportArtifactType::SlashCommand
         );
         assert_eq!(
-            detect_artifact_type_from_path(Path::new("C:/Users/test/.gemini/antigravity/global_workflows/workflow.md")),
+            detect_artifact_type_from_path(Path::new(
+                "C:/Users/test/.gemini/antigravity/global_workflows/workflow.md"
+            )),
             ImportArtifactType::SlashCommand
         );
 
@@ -1654,7 +1948,9 @@ enabledAdapters:
             ImportArtifactType::Skill
         );
         assert_eq!(
-            detect_artifact_type_from_path(Path::new("/home/Documents/Cline/Skills/test-skill/skill.md")),
+            detect_artifact_type_from_path(Path::new(
+                "/home/Documents/Cline/Skills/test-skill/skill.md"
+            )),
             ImportArtifactType::Skill
         );
     }
@@ -1662,42 +1958,61 @@ enabledAdapters:
     #[test]
     fn scan_directory_excludes_slash_commands_and_skills() {
         let temp_dir = tempfile::TempDir::new().unwrap();
-        
+
         // Create rule file
         let rule_file = temp_dir.path().join("GEMINI.md");
         fs::write(&rule_file, "# Rule content\n\nSome rule text").unwrap();
-        
+
         // Create slash command file
         let commands_dir = temp_dir.path().join("commands");
         fs::create_dir_all(&commands_dir).unwrap();
         let command_file = commands_dir.join("my-command.md");
         fs::write(&command_file, "# My Command\n\nCommand content").unwrap();
-        
+
         // Create skill file
         let skills_dir = temp_dir.path().join("skills");
         fs::create_dir_all(&skills_dir).unwrap();
         let skill_file = skills_dir.join("my-skill.md");
         fs::write(&skill_file, "# My Skill\n\nSkill content").unwrap();
-        
+
         // Scan the directory
-        let result = scan_directory_to_candidates(temp_dir.path(), 1024 * 1024);
-        
-        // Should only have 1 candidate (the rule file)
-        assert_eq!(result.candidates.len(), 1, "Should only find rule files, not commands or skills");
-        assert!(result.candidates[0].name.to_lowercase().contains("gemini"));
+        let result = scan_directory_to_candidates(temp_dir.path(), 1024 * 1024, None);
+
+        // Should find 3 candidates (rule, command, skill)
+        assert_eq!(
+            result.candidates.len(),
+            3,
+            "Should find rule files, commands, and skills"
+        );
+        assert!(result
+            .candidates
+            .iter()
+            .any(|c| c.name.to_lowercase().contains("gemini")));
     }
 
     #[test]
     fn is_slash_command_or_skill_directory_detects_correctly() {
         // Should be detected as command/skill directories
-        assert!(is_slash_command_or_skill_directory(Path::new("/home/.claude/commands/test.md")));
-        assert!(is_slash_command_or_skill_directory(Path::new("C:/Users/test/Documents/Cline/Workflows/workflow.md")));
-        assert!(is_slash_command_or_skill_directory(Path::new("/home/.gemini/skills/my-skill/skill.md")));
-        
+        assert!(is_slash_command_or_skill_directory(Path::new(
+            "/home/.claude/commands/test.md"
+        )));
+        assert!(is_slash_command_or_skill_directory(Path::new(
+            "C:/Users/test/Documents/Cline/Workflows/workflow.md"
+        )));
+        assert!(is_slash_command_or_skill_directory(Path::new(
+            "/home/.gemini/skills/my-skill/skill.md"
+        )));
+
         // Should NOT be detected as command/skill directories (these are rule files)
-        assert!(!is_slash_command_or_skill_directory(Path::new("/home/.gemini/GEMINI.md")));
-        assert!(!is_slash_command_or_skill_directory(Path::new("/home/.clinerules")));
-        assert!(!is_slash_command_or_skill_directory(Path::new("/repo/.claude/CLAUDE.md")));
+        assert!(!is_slash_command_or_skill_directory(Path::new(
+            "/home/.gemini/GEMINI.md"
+        )));
+        assert!(!is_slash_command_or_skill_directory(Path::new(
+            "/home/.clinerules"
+        )));
+        assert!(!is_slash_command_or_skill_directory(Path::new(
+            "/repo/.claude/CLAUDE.md"
+        )));
     }
 
     // =====================================
@@ -1710,8 +2025,8 @@ enabledAdapters:
         let rule_file = temp_dir.path().join("GEMINI.md");
         fs::write(&rule_file, "# Test Rule\n\nThis is a test rule for import.").unwrap();
 
-        let result = scan_directory_to_candidates(temp_dir.path(), 1024 * 1024);
-        
+        let result = scan_directory_to_candidates(temp_dir.path(), 1024 * 1024, None);
+
         assert_eq!(result.candidates.len(), 1);
         assert_eq!(result.candidates[0].artifact_type, ImportArtifactType::Rule);
         assert!(result.errors.is_empty());
@@ -1725,8 +2040,8 @@ enabledAdapters:
         let rule_file = local_rules.join("GEMINI.md");
         fs::write(&rule_file, "# Local Rule\n\nThis is a local rule.").unwrap();
 
-        let result = scan_directory_to_candidates(temp_dir.path(), 1024 * 1024);
-        
+        let result = scan_directory_to_candidates(temp_dir.path(), 1024 * 1024, None);
+
         assert_eq!(result.candidates.len(), 1);
         assert_eq!(result.candidates[0].artifact_type, ImportArtifactType::Rule);
     }
@@ -1737,8 +2052,8 @@ enabledAdapters:
         let rule_file = temp_dir.path().join("empty.md");
         fs::write(&rule_file, "").unwrap();
 
-        let result = scan_directory_to_candidates(temp_dir.path(), 1024 * 1024);
-        
+        let result = scan_directory_to_candidates(temp_dir.path(), 1024 * 1024, None);
+
         // Empty files should be imported but with empty content
         assert_eq!(result.candidates.len(), 1);
         assert_eq!(result.candidates[0].content.trim(), "");
@@ -1751,8 +2066,8 @@ enabledAdapters:
         let large_content = "x".repeat(2000);
         fs::write(&rule_file, &large_content).unwrap();
 
-        let result = scan_directory_to_candidates(temp_dir.path(), 1000);
-        
+        let result = scan_directory_to_candidates(temp_dir.path(), 1000, None);
+
         assert!(!result.errors.is_empty());
         assert!(result.errors[0].contains("exceeds max import size"));
     }
@@ -1763,8 +2078,8 @@ enabledAdapters:
         let rule_file = temp_dir.path().join("binary.md");
         fs::write(&rule_file, &[0xFF, 0xFE, 0x00, 0x01]).unwrap();
 
-        let result = scan_directory_to_candidates(temp_dir.path(), 1024 * 1024);
-        
+        let result = scan_directory_to_candidates(temp_dir.path(), 1024 * 1024, None);
+
         assert!(!result.errors.is_empty());
         assert!(result.errors.iter().any(|e| e.contains("not valid UTF-8")));
     }
@@ -1787,8 +2102,8 @@ This is the rule content.
 "#;
         fs::write(&rule_file, content).unwrap();
 
-        let result = scan_directory_to_candidates(temp_dir.path(), 1024 * 1024);
-        
+        let result = scan_directory_to_candidates(temp_dir.path(), 1024 * 1024, None);
+
         assert_eq!(result.candidates.len(), 1);
         // The name is extracted from the frontmatter or filename
         assert!(!result.candidates[0].name.is_empty());
@@ -1801,59 +2116,89 @@ This is the rule content.
     #[test]
     fn import_excludes_global_slash_commands() {
         let temp_dir = tempfile::TempDir::new().unwrap();
-        
+
         // Create global slash command location
         let commands_dir = temp_dir.path().join(".claude").join("commands");
         fs::create_dir_all(&commands_dir).unwrap();
-        fs::write(commands_dir.join("my-command.md"), "# My Command\n\nCommand content").unwrap();
-        
+        fs::write(
+            commands_dir.join("my-command.md"),
+            "# My Command\n\nCommand content",
+        )
+        .unwrap();
+
         // Also create a rule
         fs::write(temp_dir.path().join("CLAUDE.md"), "# Rule\n\nRule content").unwrap();
 
-        let result = scan_directory_to_candidates(temp_dir.path(), 1024 * 1024);
-        
-        // Only rule should be found
-        assert_eq!(result.candidates.len(), 1);
-        assert!(result.candidates[0].name.to_lowercase().contains("claude"));
+        let result = scan_directory_to_candidates(temp_dir.path(), 1024 * 1024, None);
+
+        // Both rule and command should be found
+        assert_eq!(result.candidates.len(), 2);
+        assert!(result
+            .candidates
+            .iter()
+            .any(|c| c.name.to_lowercase().contains("claude")));
+        assert!(result
+            .candidates
+            .iter()
+            .any(|c| c.name.to_lowercase().contains("my-command")));
     }
 
     #[test]
     fn import_excludes_local_slash_commands() {
         let temp_dir = tempfile::TempDir::new().unwrap();
-        
+
         // Create local slash command location
         let commands_dir = temp_dir.path().join("commands");
         fs::create_dir_all(&commands_dir).unwrap();
-        fs::write(commands_dir.join("workflow.md"), "# Workflow\n\nWorkflow content").unwrap();
-        
+        fs::write(
+            commands_dir.join("workflow.md"),
+            "# Workflow\n\nWorkflow content",
+        )
+        .unwrap();
+
         // Also create a rule
         fs::write(temp_dir.path().join("AGENTS.md"), "# Rule\n\nRule content").unwrap();
 
-        let result = scan_directory_to_candidates(temp_dir.path(), 1024 * 1024);
-        
-        // Only rule should be found
-        assert_eq!(result.candidates.len(), 1);
-        assert!(result.candidates[0].name.to_lowercase().contains("agents"));
+        let result = scan_directory_to_candidates(temp_dir.path(), 1024 * 1024, None);
+
+        // Both rule and command should be found
+        assert_eq!(result.candidates.len(), 2);
+        assert!(result
+            .candidates
+            .iter()
+            .any(|c| c.name.to_lowercase().contains("agents")));
     }
 
     #[test]
     fn import_excludes_cline_workflows() {
         let temp_dir = tempfile::TempDir::new().unwrap();
-        
+
         // Cline Workflows directory
-        let workflows_dir = temp_dir.path().join("Documents").join("Cline").join("Workflows");
+        let workflows_dir = temp_dir
+            .path()
+            .join("Documents")
+            .join("Cline")
+            .join("Workflows");
         fs::create_dir_all(&workflows_dir).unwrap();
-        fs::write(workflows_dir.join("my-workflow.md"), "# Workflow\n\nContent").unwrap();
-        
+        fs::write(
+            workflows_dir.join("my-workflow.md"),
+            "# Workflow\n\nContent",
+        )
+        .unwrap();
+
         // Rules directory
-        let rules_dir = temp_dir.path().join("Documents").join("Cline").join("Rules");
+        let rules_dir = temp_dir
+            .path()
+            .join("Documents")
+            .join("Cline")
+            .join("Rules");
         fs::create_dir_all(&rules_dir).unwrap();
         fs::write(rules_dir.join("my-rule.md"), "# Rule\n\nContent").unwrap();
 
-        let result = scan_directory_to_candidates(temp_dir.path(), 1024 * 1024);
-        
-        // Only rule should be found
-        assert_eq!(result.candidates.len(), 1);
+        let result = scan_directory_to_candidates(temp_dir.path(), 1024 * 1024, None);
+
+        // Both rule and command should be found
+        assert_eq!(result.candidates.len(), 2);
         assert!(result.candidates[0].name.to_lowercase().contains("rule"));
     }
 
@@ -1864,60 +2209,94 @@ This is the rule content.
     #[test]
     fn import_excludes_global_skills() {
         let temp_dir = tempfile::TempDir::new().unwrap();
-        
+
         // Create global skill location
-        let skills_dir = temp_dir.path().join(".claude").join("skills").join("my-skill");
+        let skills_dir = temp_dir
+            .path()
+            .join(".claude")
+            .join("skills")
+            .join("my-skill");
         fs::create_dir_all(&skills_dir).unwrap();
         fs::write(skills_dir.join("SKILL.md"), "# My Skill\n\nSkill content").unwrap();
-        
+
         // Also create a rule
         fs::write(temp_dir.path().join("CLAUDE.md"), "# Rule\n\nRule content").unwrap();
 
-        let result = scan_directory_to_candidates(temp_dir.path(), 1024 * 1024);
-        
-        // Only rule should be found
-        assert_eq!(result.candidates.len(), 1);
-        assert!(result.candidates[0].name.to_lowercase().contains("claude"));
+        let result = scan_directory_to_candidates(temp_dir.path(), 1024 * 1024, None);
+
+        // Both rule and skill should be found
+        assert_eq!(result.candidates.len(), 2);
+        assert!(result
+            .candidates
+            .iter()
+            .any(|c| c.name.to_lowercase().contains("claude")));
+        assert!(result
+            .candidates
+            .iter()
+            .any(|c| c.name.to_lowercase().contains("skill")));
     }
 
     #[test]
     fn import_excludes_local_skills() {
         let temp_dir = tempfile::TempDir::new().unwrap();
-        
+
         // Create local skill location
         let skills_dir = temp_dir.path().join("skills");
         fs::create_dir_all(&skills_dir).unwrap();
         fs::write(skills_dir.join("my-skill.md"), "# Skill\n\nSkill content").unwrap();
-        
+
         // Also create a rule
         fs::write(temp_dir.path().join("GEMINI.md"), "# Rule\n\nRule content").unwrap();
 
-        let result = scan_directory_to_candidates(temp_dir.path(), 1024 * 1024);
-        
-        // Only rule should be found
-        assert_eq!(result.candidates.len(), 1);
-        assert!(result.candidates[0].name.to_lowercase().contains("gemini"));
+        let result = scan_directory_to_candidates(temp_dir.path(), 1024 * 1024, None);
+
+        // Both rule and command should be found
+        assert_eq!(result.candidates.len(), 2);
+        assert!(result
+            .candidates
+            .iter()
+            .any(|c| c.name.to_lowercase().contains("gemini")));
+        assert!(result
+            .candidates
+            .iter()
+            .any(|c| c.name.to_lowercase().contains("skill")));
     }
 
     #[test]
     fn import_excludes_cline_skills() {
         let temp_dir = tempfile::TempDir::new().unwrap();
-        
+
         // Cline Skills directory
-        let skills_dir = temp_dir.path().join("Documents").join("Cline").join("Skills").join("test");
+        let skills_dir = temp_dir
+            .path()
+            .join("Documents")
+            .join("Cline")
+            .join("Skills")
+            .join("test");
         fs::create_dir_all(&skills_dir).unwrap();
         fs::write(skills_dir.join("skill.md"), "# Skill\n\nContent").unwrap();
-        
+
         // Rules directory
-        let rules_dir = temp_dir.path().join("Documents").join("Cline").join("Rules");
+        let rules_dir = temp_dir
+            .path()
+            .join("Documents")
+            .join("Cline")
+            .join("Rules");
         fs::create_dir_all(&rules_dir).unwrap();
         fs::write(rules_dir.join("rule.md"), "# Rule\n\nContent").unwrap();
 
-        let result = scan_directory_to_candidates(temp_dir.path(), 1024 * 1024);
-        
-        // Only rule should be found
-        assert_eq!(result.candidates.len(), 1);
-        assert!(result.candidates[0].name.to_lowercase().contains("rule"));
+        let result = scan_directory_to_candidates(temp_dir.path(), 1024 * 1024, None);
+
+        // Both rule and skill should be found
+        assert_eq!(result.candidates.len(), 2);
+        assert!(result
+            .candidates
+            .iter()
+            .any(|c| c.name.to_lowercase().contains("rule")));
+        assert!(result
+            .candidates
+            .iter()
+            .any(|c| c.name.to_lowercase().contains("skill")));
     }
 
     // =====================================
@@ -1927,47 +2306,61 @@ This is the rule content.
     #[test]
     fn import_mixed_artifacts_only_includes_rules() {
         let temp_dir = tempfile::TempDir::new().unwrap();
-        
+
         // Create rule
         fs::write(temp_dir.path().join("GEMINI.md"), "# Rule\n\nRule content").unwrap();
-        
+
         // Create slash command
         let commands_dir = temp_dir.path().join("commands");
         fs::create_dir_all(&commands_dir).unwrap();
         fs::write(commands_dir.join("cmd.md"), "# Command\n\nCommand content").unwrap();
-        
+
         // Create skill
         let skills_dir = temp_dir.path().join("skills");
         fs::create_dir_all(&skills_dir).unwrap();
         fs::write(skills_dir.join("skill.md"), "# Skill\n\nSkill content").unwrap();
-        
+
         // Create workflow
         let workflows_dir = temp_dir.path().join("workflows");
         fs::create_dir_all(&workflows_dir).unwrap();
-        fs::write(workflows_dir.join("wf.md"), "# Workflow\n\nWorkflow content").unwrap();
+        fs::write(
+            workflows_dir.join("wf.md"),
+            "# Workflow\n\nWorkflow content",
+        )
+        .unwrap();
 
-        let result = scan_directory_to_candidates(temp_dir.path(), 1024 * 1024);
-        
-        // Only the rule should be found
-        assert_eq!(result.candidates.len(), 1);
-        assert_eq!(result.candidates[0].artifact_type, ImportArtifactType::Rule);
-        assert!(result.candidates[0].name.to_lowercase().contains("gemini"));
+        let result = scan_directory_to_candidates(temp_dir.path(), 1024 * 1024, None);
+
+        // All 4 artifacts should be found
+        assert_eq!(result.candidates.len(), 4);
+        assert!(result
+            .candidates
+            .iter()
+            .any(|c| c.artifact_type == ImportArtifactType::Rule));
+        assert!(result
+            .candidates
+            .iter()
+            .any(|c| c.artifact_type == ImportArtifactType::Skill));
+        assert!(result
+            .candidates
+            .iter()
+            .any(|c| c.artifact_type == ImportArtifactType::SlashCommand));
     }
 
     #[test]
     fn import_multiple_rules_happy_path() {
         let temp_dir = tempfile::TempDir::new().unwrap();
-        
+
         // Create multiple rule files
         fs::write(temp_dir.path().join("GEMINI.md"), "# Gemini Rule").unwrap();
         fs::write(temp_dir.path().join("AGENTS.md"), "# Agents Rule").unwrap();
         fs::write(temp_dir.path().join("CLAUDE.md"), "# Claude Rule").unwrap();
 
-        let result = scan_directory_to_candidates(temp_dir.path(), 1024 * 1024);
-        
+        let result = scan_directory_to_candidates(temp_dir.path(), 1024 * 1024, None);
+
         assert_eq!(result.candidates.len(), 3);
         assert!(result.errors.is_empty());
-        
+
         // All should be rules
         for candidate in &result.candidates {
             assert_eq!(candidate.artifact_type, ImportArtifactType::Rule);
@@ -1985,13 +2378,13 @@ This is the rule content.
             detect_artifact_type_from_path(Path::new("/home/.claude/COMMANDS/test.md")),
             ImportArtifactType::SlashCommand
         );
-        
+
         // Mixed case
         assert_eq!(
             detect_artifact_type_from_path(Path::new("/home/.claude/Commands/test.md")),
             ImportArtifactType::SlashCommand
         );
-        
+
         // Lowercase
         assert_eq!(
             detect_artifact_type_from_path(Path::new("/home/.claude/commands/test.md")),
@@ -2007,7 +2400,9 @@ This is the rule content.
             ImportArtifactType::SlashCommand
         );
         assert_eq!(
-            detect_artifact_type_from_path(Path::new("C:\\Users\\test\\.claude\\commands\\test.md")),
+            detect_artifact_type_from_path(Path::new(
+                "C:\\Users\\test\\.claude\\commands\\test.md"
+            )),
             ImportArtifactType::SlashCommand
         );
         assert_eq!(
@@ -2020,16 +2415,20 @@ This is the rule content.
     fn detect_artifact_type_nested_directories() {
         // Deeply nested slash command
         assert_eq!(
-            detect_artifact_type_from_path(Path::new("/home/user/repo/.claude/commands/subdir/nested/cmd.md")),
+            detect_artifact_type_from_path(Path::new(
+                "/home/user/repo/.claude/commands/subdir/nested/cmd.md"
+            )),
             ImportArtifactType::SlashCommand
         );
-        
+
         // Deeply nested skill
         assert_eq!(
-            detect_artifact_type_from_path(Path::new("/home/user/repo/skills/category/my-skill/skill.md")),
+            detect_artifact_type_from_path(Path::new(
+                "/home/user/repo/skills/category/my-skill/skill.md"
+            )),
             ImportArtifactType::Skill
         );
-        
+
         // Rule in subdirectory (should still be rule if no command/skill keywords)
         assert_eq!(
             detect_artifact_type_from_path(Path::new("/home/user/repo/docs/GEMINI.md")),
diff --git a/src-tauri/tauri.conf.json b/src-tauri/tauri.conf.json
index fd0fc09..c41e76f 100644
--- a/src-tauri/tauri.conf.json
+++ b/src-tauri/tauri.conf.json
@@ -1,7 +1,7 @@
 {
   "$schema": "https://schema.tauri.app/config/2",
   "productName": "RuleWeaver",
-  "version": "0.0.30-2502",
+  "version": "0.0.31-2602",
   "identifier": "com.ruleweaver.desktop",
   "build": {
     "beforeDevCommand": "npm run dev",
diff --git a/src/__tests__/components/pages/RulesList.test.tsx b/src/__tests__/components/pages/RulesList.test.tsx
index 8e10c13..2921911 100644
--- a/src/__tests__/components/pages/RulesList.test.tsx
+++ b/src/__tests__/components/pages/RulesList.test.tsx
@@ -100,6 +100,7 @@ describe("RulesList import workflow", () => {
           scope: "global",
           targetPaths: null,
           enabledAdapters: ["cline"],
+          artifactType: "rule",
           contentHash: "hash",
           fileSize: 12,
         },
@@ -135,6 +136,7 @@ describe("RulesList import workflow", () => {
           scope: "global",
           targetPaths: null,
           enabledAdapters: ["cline"],
+          artifactType: "rule",
           contentHash: "hash",
           fileSize: 12,
         },
@@ -143,6 +145,9 @@ describe("RulesList import workflow", () => {
     });
     vi.mocked(api.ruleImport.importAiToolRules).mockResolvedValue({
       imported: [],
+      importedRules: [],
+      importedCommands: [],
+      importedSkills: [],
       skipped: [],
       conflicts: [],
       errors: [],
@@ -153,7 +158,7 @@ describe("RulesList import workflow", () => {
     await userEvent.click(screen.getByRole("button", { name: /import ai/i }));
     await waitFor(() => expect(screen.getByText("quality-cline")).toBeInTheDocument());
 
-    await userEvent.click(screen.getByRole("button", { name: /import selected/i }));
+    await userEvent.click(screen.getByRole("button", { name: /process import/i }));
 
     await waitFor(() => {
       expect(api.ruleImport.importAiToolRules).toHaveBeenCalledWith(
@@ -181,6 +186,7 @@ describe("RulesList import workflow", () => {
           scope: "global",
           targetPaths: null,
           enabledAdapters: ["cline"],
+          artifactType: "rule",
           contentHash: "hash",
           fileSize: 12,
         },
@@ -189,6 +195,9 @@ describe("RulesList import workflow", () => {
     });
     vi.mocked(api.ruleImport.importAiToolRules).mockResolvedValue({
       imported: [],
+      importedRules: [],
+      importedCommands: [],
+      importedSkills: [],
       skipped: [],
       conflicts: [],
       errors: [],
@@ -200,7 +209,7 @@ describe("RulesList import workflow", () => {
     await waitFor(() => expect(screen.getByText("quality-cline")).toBeInTheDocument());
 
     await userEvent.selectOptions(screen.getByLabelText(/conflict mode/i), "replace");
-    await userEvent.click(screen.getByRole("button", { name: /import selected/i }));
+    await userEvent.click(screen.getByRole("button", { name: /process import/i }));
 
     await waitFor(() => {
       expect(api.ruleImport.importAiToolRules).toHaveBeenCalledWith(
@@ -230,6 +239,7 @@ describe("RulesList import workflow", () => {
           scope: "global",
           targetPaths: null,
           enabledAdapters: ["gemini"],
+          artifactType: "rule",
           contentHash: "hash",
           fileSize: 12,
         },
@@ -238,6 +248,9 @@ describe("RulesList import workflow", () => {
     });
     vi.mocked(api.ruleImport.importFromFile).mockResolvedValue({
       imported: [],
+      importedRules: [],
+      importedCommands: [],
+      importedSkills: [],
       skipped: [],
       conflicts: [],
       errors: [],
@@ -251,8 +264,8 @@ describe("RulesList import workflow", () => {
     });
 
     expect(screen.getByText("Import Rules From File")).toBeInTheDocument();
-    expect(screen.getByText(/Source: C:\/tmp\/rule\.md/i)).toBeInTheDocument();
-    await userEvent.click(screen.getByRole("button", { name: /import selected/i }));
+    expect(screen.getAllByText(/C:\/tmp\/rule\.md/i).length).toBeGreaterThan(0);
+    await userEvent.click(screen.getByRole("button", { name: /process import/i }));
 
     await waitFor(() => {
       expect(api.ruleImport.importFromFile).toHaveBeenCalledWith(
@@ -278,6 +291,7 @@ describe("RulesList import workflow", () => {
           scope: "global",
           targetPaths: null,
           enabledAdapters: ["cline"],
+          artifactType: "rule",
           contentHash: "hash",
           fileSize: 12,
         },
@@ -286,6 +300,9 @@ describe("RulesList import workflow", () => {
     });
     vi.mocked(api.ruleImport.importAiToolRules).mockResolvedValue({
       imported: [],
+      importedRules: [],
+      importedCommands: [],
+      importedSkills: [],
       skipped: [],
       conflicts: [],
       errors: [],
@@ -300,7 +317,7 @@ describe("RulesList import workflow", () => {
     await userEvent.click(screen.getByLabelText(/enable adapter override/i));
     await userEvent.click(screen.getByLabelText(/use adapter gemini/i));
 
-    await userEvent.click(screen.getByRole("button", { name: /import selected/i }));
+    await userEvent.click(screen.getByRole("button", { name: /process import/i }));
 
     await waitFor(() => {
       expect(api.ruleImport.importAiToolRules).toHaveBeenCalledWith(
@@ -317,7 +334,7 @@ describe("RulesList import workflow", () => {
     renderWithProviders(<RulesList onSelectRule={vi.fn()} onCreateRule={vi.fn()} />);
 
     await userEvent.click(screen.getByRole("button", { name: /import url/i }));
-    await userEvent.click(screen.getByRole("button", { name: /scan url/i }));
+    await userEvent.click(screen.getByRole("button", { name: /scan remote source/i }));
 
     expect(screen.getByText(/URL Required/i)).toBeInTheDocument();
   });
diff --git a/src/components/commands/CommandList.tsx b/src/components/commands/CommandList.tsx
index 200f89f..03ff2b6 100644
--- a/src/components/commands/CommandList.tsx
+++ b/src/components/commands/CommandList.tsx
@@ -1,4 +1,4 @@
-import { Plus, Search } from "lucide-react";
+import { Plus, Search, FolderUp } from "lucide-react";
 import { CommandTemplateBrowser } from "./CommandTemplateBrowser";
 import { cn } from "@/lib/utils";
 import { Button } from "@/components/ui/button";
@@ -17,6 +17,7 @@ interface CommandListProps {
   onQueryChange: (q: string) => void;
   onCreate: () => void;
   onSync: () => void;
+  onImport: () => void;
 }
 
 export function CommandList({
@@ -29,6 +30,7 @@ export function CommandList({
   onQueryChange,
   onCreate,
   onSync,
+  onImport,
 }: CommandListProps) {
   return (
     <Card className="glass-card premium-shadow border-none overflow-hidden">
@@ -43,6 +45,10 @@ export function CommandList({
               <Plus className="mr-1.5 h-3.5 w-3.5" />
               New
             </Button>
+            <Button size="sm" variant="outline" onClick={onImport} className="glass h-8">
+              <FolderUp className="mr-1.5 h-3.5 w-3.5" />
+              Import
+            </Button>
           </div>
         </div>
         <Button
diff --git a/src/components/import/ImportDialog.tsx b/src/components/import/ImportDialog.tsx
new file mode 100644
index 0000000..910ebe2
--- /dev/null
+++ b/src/components/import/ImportDialog.tsx
@@ -0,0 +1,706 @@
+import { useState, useCallback, useEffect } from "react";
+import { motion, AnimatePresence } from "framer-motion";
+import { open } from "@tauri-apps/plugin-dialog";
+import {
+  Dialog,
+  DialogContent,
+  DialogHeader,
+  DialogTitle,
+  DialogDescription,
+  DialogFooter,
+} from "@/components/ui/dialog";
+import { Button } from "@/components/ui/button";
+import { Input } from "@/components/ui/input";
+import { Checkbox } from "@/components/ui/checkbox";
+import { Badge } from "@/components/ui/badge";
+import { Select } from "@/components/ui/select";
+import { useToast } from "@/components/ui/toast";
+import { api } from "@/lib/tauri";
+import { useRegistryStore } from "@/stores/registryStore";
+import { toast } from "@/lib/toast-helpers";
+import {
+  type Scope,
+  type AdapterType,
+  type ImportCandidate,
+  type ImportConflictMode,
+  type ImportExecutionOptions,
+  type ImportExecutionResult,
+  type ImportArtifactType,
+} from "@/types/rule";
+
+export type ImportSourceMode = "ai" | "file" | "directory" | "url" | "clipboard";
+
+export interface ImportDialogProps {
+  open: boolean;
+  onOpenChange: (open: boolean) => void;
+  onImportComplete: (result: ImportExecutionResult) => Promise<void>;
+  artifactType: ImportArtifactType;
+  title?: string;
+  initialSourceMode?: ImportSourceMode | null;
+}
+
+export function ImportDialog({
+  open: isOpen,
+  onOpenChange,
+  onImportComplete,
+  artifactType,
+  title: titleProp,
+  initialSourceMode,
+}: ImportDialogProps) {
+  const { tools } = useRegistryStore();
+  const { addToast } = useToast();
+  const [isImporting, setIsImporting] = useState(false);
+  const [isScanningImport, setIsScanningImport] = useState(false);
+  const [importCandidates, setImportCandidates] = useState<ImportCandidate[]>([]);
+  const [selectedImportIds, setSelectedImportIds] = useState<Set<string>>(new Set());
+  const [importScanErrors, setImportScanErrors] = useState<string[]>([]);
+  const [importConflictMode, setImportConflictMode] = useState<ImportConflictMode>("rename");
+  const [importResult, setImportResult] = useState<ImportExecutionResult | null>(null);
+  const [importSourceMode, setImportSourceMode] = useState<ImportSourceMode>("ai");
+
+  const [importSourceValue, setImportSourceValue] = useState("");
+  const [clipboardImportName, setClipboardImportName] = useState<string | undefined>(undefined);
+  const [urlImportDialogOpen, setUrlImportDialogOpen] = useState(false);
+  const [urlImportValue, setUrlImportValue] = useState("");
+  const [importScopeOverride, setImportScopeOverride] = useState<"source" | Scope>("source");
+  const [useAdapterOverride, setUseAdapterOverride] = useState(false);
+  const [adapterOverrideSet, setAdapterOverrideSet] = useState<Set<AdapterType>>(new Set());
+
+  const handleImportResult = useCallback(
+    async (title: string, result: ImportExecutionResult) => {
+      await onImportComplete(result);
+
+      const totalImported =
+        (result.importedRules?.length || 0) +
+          (result.importedCommands?.length || 0) +
+          (result.importedSkills?.length || 0) || result.imported.length;
+
+      addToast({
+        title,
+        description: `${totalImported} imported, ${result.skipped.length} skipped, ${result.conflicts.length} conflicts`,
+        variant: result.errors.length > 0 ? "error" : "success",
+      });
+      if (result.errors.length > 0) {
+        addToast({
+          title: "Import Warnings",
+          description: result.errors[0],
+          variant: "error",
+        });
+      }
+    },
+    [onImportComplete, addToast]
+  );
+
+  const openImportPreview = useCallback(
+    async (
+      mode: ImportSourceMode,
+      sourceValue: string,
+      candidates: ImportCandidate[],
+      errors: string[]
+    ) => {
+      setImportSourceMode(mode);
+      setImportSourceValue(sourceValue);
+      if (mode !== "clipboard") {
+        setClipboardImportName(undefined);
+      }
+      setImportResult(null);
+      setImportCandidates(candidates);
+      setImportScanErrors(errors);
+      setSelectedImportIds(new Set(candidates.map((c) => c.id)));
+      setImportScopeOverride("source");
+    },
+    []
+  );
+
+  const getImportExecutionOptions = (): ImportExecutionOptions => ({
+    conflictMode: importConflictMode,
+    selectedCandidateIds: Array.from(selectedImportIds),
+    defaultScope: importScopeOverride === "source" ? undefined : importScopeOverride,
+    defaultAdapters: useAdapterOverride ? Array.from(adapterOverrideSet) : undefined,
+  });
+
+  const toggleAdapterOverride = (adapter: AdapterType, checked: boolean) => {
+    setAdapterOverrideSet((prev) => {
+      const next = new Set(prev);
+      if (checked) {
+        next.add(adapter);
+      } else {
+        next.delete(adapter);
+      }
+      return next;
+    });
+  };
+
+  const scanAiToolArtifacts = useCallback(async () => {
+    setIsScanningImport(true);
+    try {
+      if (artifactType === "command") {
+        await api.ruleImport.importAiToolCommands({
+          conflictMode: "skip",
+          selectedCandidateIds: [],
+        });
+      } else if (artifactType === "skill") {
+        await api.ruleImport.importAiToolSkills({ conflictMode: "skip", selectedCandidateIds: [] });
+      }
+
+      // Backend scan_ai_tool_import_candidates now returns EVERYTHING.
+      // We should filter it here for the current artifactType.
+      const allScan = await api.ruleImport.scanAiToolCandidates();
+      const filteredCandidates = allScan.candidates.filter((c) => c.artifactType === artifactType);
+
+      await openImportPreview("ai", "", filteredCandidates, allScan.errors);
+    } catch (error) {
+      toast.error(addToast, { title: "Scan Failed", error });
+    } finally {
+      setIsScanningImport(false);
+    }
+  }, [artifactType, addToast, openImportPreview]);
+
+  const scanImportFromFile = useCallback(async () => {
+    const selected = await open({
+      multiple: false,
+      filters: [{ name: "Artifact Files", extensions: ["md", "txt", "json", "yaml", "yml"] }],
+    });
+    if (!selected || Array.isArray(selected)) return;
+
+    setIsScanningImport(true);
+    try {
+      const scan = await api.ruleImport.scanFromFile(selected);
+      await openImportPreview("file", selected, scan.candidates, scan.errors);
+    } catch (error) {
+      toast.error(addToast, { title: "Scan Failed", error });
+    } finally {
+      setIsScanningImport(false);
+    }
+  }, [addToast, openImportPreview]);
+
+  const scanImportFromDirectory = useCallback(async () => {
+    const selected = await open({ directory: true, multiple: false });
+    if (!selected || Array.isArray(selected)) return;
+
+    setIsScanningImport(true);
+    try {
+      let scan;
+      if (artifactType === "command") {
+        scan = await api.ruleImport.scanCommandDirectoryImport(selected);
+      } else if (artifactType === "skill") {
+        scan = await api.ruleImport.scanSkillDirectoryImport(selected);
+      } else {
+        scan = await api.ruleImport.scanFromDirectory(selected);
+      }
+      await openImportPreview("directory", selected, scan.candidates, scan.errors);
+    } catch (error) {
+      toast.error(addToast, { title: "Scan Failed", error });
+    } finally {
+      setIsScanningImport(false);
+    }
+  }, [artifactType, addToast, openImportPreview]);
+
+  const scanImportFromUrl = useCallback(
+    async (url: string) => {
+      if (!url.trim()) return;
+
+      setIsScanningImport(true);
+      try {
+        const scan = await api.ruleImport.scanFromUrl(url);
+        await openImportPreview("url", url, scan.candidates, scan.errors);
+      } catch (error) {
+        toast.error(addToast, { title: "Scan Failed", error });
+      } finally {
+        setIsScanningImport(false);
+      }
+    },
+    [addToast, openImportPreview]
+  );
+
+  const submitUrlImportScan = async () => {
+    const value = urlImportValue.trim();
+    if (!value) {
+      toast.error(addToast, {
+        title: "URL Required",
+        description: "Enter a URL to scan for import",
+      });
+      return;
+    }
+
+    setUrlImportDialogOpen(false);
+    await scanImportFromUrl(value);
+  };
+
+  const scanImportFromClipboard = useCallback(async () => {
+    try {
+      const text = await navigator.clipboard.readText();
+      if (!text.trim()) {
+        toast.error(addToast, {
+          title: "Clipboard Empty",
+          description: "No text found in clipboard",
+        });
+        return;
+      }
+
+      setIsScanningImport(true);
+      try {
+        const scan = await api.ruleImport.scanFromClipboard(text);
+        await openImportPreview("clipboard", text, scan.candidates, scan.errors);
+      } catch (error) {
+        toast.error(addToast, { title: "Scan Failed", error });
+      } finally {
+        setIsScanningImport(false);
+      }
+    } catch {
+      toast.error(addToast, {
+        title: "Clipboard Access Denied",
+        description: "Please allow clipboard permissions",
+      });
+    }
+  }, [addToast, openImportPreview]);
+
+  useEffect(() => {
+    if (initialSourceMode && isOpen) {
+      setImportSourceMode(initialSourceMode);
+      // Trigger auto-scan for AI, File, or Directory if they are initial
+      if (initialSourceMode === "ai") {
+        void scanAiToolArtifacts();
+      } else if (initialSourceMode === "file") {
+        void scanImportFromFile();
+      } else if (initialSourceMode === "directory") {
+        void scanImportFromDirectory();
+      } else if (initialSourceMode === "url") {
+        setUrlImportDialogOpen(true);
+      }
+    }
+  }, [initialSourceMode, isOpen, scanAiToolArtifacts, scanImportFromFile, scanImportFromDirectory]);
+
+  const toggleImportCandidate = (id: string, checked: boolean) => {
+    setSelectedImportIds((prev) => {
+      const next = new Set(prev);
+      if (checked) {
+        next.add(id);
+      } else {
+        next.delete(id);
+      }
+      return next;
+    });
+  };
+
+  const toggleSelectAllImportCandidates = (checked: boolean) => {
+    if (checked) {
+      setSelectedImportIds(new Set(importCandidates.map((c) => c.id)));
+    } else {
+      setSelectedImportIds(new Set());
+    }
+  };
+
+  const executeImport = async () => {
+    if (selectedImportIds.size === 0) {
+      toast.error(addToast, {
+        title: "No Candidates Selected",
+        description: "Select at least one candidate to import",
+      });
+      return;
+    }
+
+    setIsImporting(true);
+    try {
+      const options = getImportExecutionOptions();
+
+      let result: ImportExecutionResult;
+
+      if (importSourceMode === "directory") {
+        if (artifactType === "command") {
+          result = await api.ruleImport.importCommandsFromDirectory(importSourceValue, options);
+        } else if (artifactType === "skill") {
+          result = await api.ruleImport.importSkillsFromDirectory(importSourceValue, options);
+        } else {
+          result = await api.ruleImport.importFromDirectory(importSourceValue, options);
+        }
+      } else {
+        // Fallback to legacy single-artifact paths which backend handles correctly now for Rules
+        // Backend generalized execute_import handles all types if candidates are passed correctly.
+        // However, scanFromFile/scanFromUrl currently defaults to Rule in legacy paths.
+        if (importSourceMode === "ai") {
+          result = await api.ruleImport.importAiToolRules(options);
+        } else if (importSourceMode === "file") {
+          result = await api.ruleImport.importFromFile(importSourceValue, options);
+        } else if (importSourceMode === "url") {
+          result = await api.ruleImport.importFromUrl(importSourceValue, options);
+        } else {
+          result = await api.ruleImport.importFromClipboard(
+            importSourceValue,
+            clipboardImportName,
+            options
+          );
+        }
+      }
+
+      setImportResult(result);
+      await handleImportResult("Import Complete", result);
+      if (importSourceMode === "clipboard") {
+        setClipboardImportName(undefined);
+      }
+    } catch (error) {
+      toast.error(addToast, { title: "Import Failed", error });
+    } finally {
+      setIsImporting(false);
+    }
+  };
+
+  const retryConflictsAsRename = async () => {
+    if (!importResult || importResult.conflicts.length === 0) {
+      return;
+    }
+    setSelectedImportIds(new Set(importResult.conflicts.map((c) => c.candidateId)));
+    setImportConflictMode("rename");
+    await executeImport();
+  };
+
+  const handleRescan = () => {
+    if (importSourceMode === "ai") {
+      void scanAiToolArtifacts();
+    } else if (importSourceMode === "file") {
+      void scanImportFromFile();
+    } else if (importSourceMode === "directory") {
+      void scanImportFromDirectory();
+    } else if (importSourceMode === "url") {
+      setUrlImportDialogOpen(true);
+    } else {
+      void scanImportFromClipboard();
+    }
+  };
+
+  const artifactLabelPlural =
+    artifactType === "rule" ? "Rules" : artifactType === "command" ? "Commands" : "Skills";
+
+  return (
+    <>
+      <Dialog open={isOpen} onOpenChange={onOpenChange}>
+        <DialogContent onClose={() => onOpenChange(false)} className="max-w-2xl">
+          <DialogHeader>
+            <DialogTitle>
+              {titleProp ||
+                (importSourceMode === "ai"
+                  ? `Import Existing AI Tool ${artifactLabelPlural}`
+                  : importSourceMode === "file"
+                    ? `Import ${artifactLabelPlural} From File`
+                    : importSourceMode === "directory"
+                      ? `Import ${artifactLabelPlural} From Folder`
+                      : importSourceMode === "url"
+                        ? `Import ${artifactLabelPlural} From URL`
+                        : `Import ${artifactLabelPlural} From Clipboard`)}
+            </DialogTitle>
+            <DialogDescription>
+              Review discovered candidates, choose conflict handling, and import selected{" "}
+              {artifactLabelPlural.toLowerCase()}.
+            </DialogDescription>
+          </DialogHeader>
+
+          <div className="space-y-4 max-h-[60vh] overflow-y-auto pr-2">
+            {importSourceMode !== "ai" && importSourceValue && (
+              <div className="rounded-md border p-3 text-xs font-mono text-muted-foreground break-all bg-black/10">
+                <span className="font-bold mr-1 uppercase">Source: </span>
+                {importSourceMode === "clipboard" ? "Clipboard CONTENT" : importSourceValue}
+              </div>
+            )}
+
+            <div className="flex items-center justify-between gap-2">
+              <div className="flex items-center gap-2">
+                <Checkbox
+                  checked={
+                    importCandidates.length > 0 &&
+                    selectedImportIds.size === importCandidates.length
+                  }
+                  indeterminate={
+                    selectedImportIds.size > 0 && selectedImportIds.size < importCandidates.length
+                  }
+                  onChange={toggleSelectAllImportCandidates}
+                  aria-label="Select all candidates"
+                />
+                <span className="text-sm text-muted-foreground font-medium">
+                  {selectedImportIds.size} of {importCandidates.length} selected
+                </span>
+              </div>
+
+              <div className="flex items-center gap-2">
+                <span className="text-xs font-bold uppercase text-muted-foreground/60">
+                  Conflicts:
+                </span>
+                <Select
+                  value={importConflictMode}
+                  onChange={(value) => setImportConflictMode(value as ImportConflictMode)}
+                  options={[
+                    { value: "rename", label: "Rename" },
+                    { value: "skip", label: "Skip" },
+                    { value: "replace", label: "Replace" },
+                  ]}
+                  className="w-32"
+                  aria-label="Conflict mode"
+                />
+              </div>
+            </div>
+
+            <div className="grid grid-cols-1 md:grid-cols-2 gap-3 rounded-xl border border-white/5 bg-white/5 p-4">
+              <div className="space-y-2">
+                <label className="text-[10px] font-bold uppercase tracking-widest text-muted-foreground/60">
+                  Scope Override
+                </label>
+                <Select
+                  value={importScopeOverride}
+                  onChange={(value) => setImportScopeOverride(value as "source" | Scope)}
+                  options={[
+                    { value: "source", label: "Use source preference" },
+                    { value: "global", label: "Force global" },
+                    { value: "local", label: "Force local" },
+                  ]}
+                  aria-label="Scope override"
+                />
+              </div>
+
+              <div className="space-y-2">
+                <label className="text-[10px] font-bold uppercase tracking-widest text-muted-foreground/60">
+                  Adapters Override
+                </label>
+                <div className="flex items-center gap-2 h-10 px-3 rounded-md border bg-black/20">
+                  <Checkbox
+                    checked={useAdapterOverride}
+                    onChange={setUseAdapterOverride}
+                    aria-label="Enable adapter override"
+                  />
+                  <span className="text-xs text-muted-foreground">Override tool adapters</span>
+                </div>
+              </div>
+
+              {useAdapterOverride && (
+                <div className="md:col-span-2 grid grid-cols-3 gap-2 p-3 rounded-lg border border-dashed border-white/10">
+                  {tools.map((adapter) => (
+                    <label key={adapter.id} className="flex items-center gap-2 text-xs truncate">
+                      <Checkbox
+                        checked={adapterOverrideSet.has(adapter.id)}
+                        onChange={(checked) => toggleAdapterOverride(adapter.id, checked)}
+                        aria-label={`Use adapter ${adapter.name}`}
+                      />
+                      <span>{adapter.name}</span>
+                    </label>
+                  ))}
+                </div>
+              )}
+            </div>
+
+            <div className="min-h-[200px]">
+              <AnimatePresence mode="wait">
+                {isScanningImport ? (
+                  <motion.div
+                    key="loading"
+                    initial={{ opacity: 0 }}
+                    animate={{ opacity: 1 }}
+                    exit={{ opacity: 0 }}
+                    className="space-y-2"
+                  >
+                    {[1, 2, 3].map((i) => (
+                      <div
+                        key={i}
+                        className="h-16 rounded-xl border border-white/5 bg-white/5 animate-pulse"
+                      />
+                    ))}
+                  </motion.div>
+                ) : importCandidates.length === 0 ? (
+                  <motion.div
+                    key="empty"
+                    initial={{ opacity: 0, y: 10 }}
+                    animate={{ opacity: 1, y: 0 }}
+                    className="rounded-xl border border-dashed p-12 text-center"
+                  >
+                    <p className="text-sm text-muted-foreground">
+                      No valid candidates found in this source.
+                    </p>
+                  </motion.div>
+                ) : (
+                  <motion.ul
+                    key="list"
+                    initial={{ opacity: 0 }}
+                    animate={{ opacity: 1 }}
+                    className="space-y-2"
+                  >
+                    {importCandidates.map((candidate) => (
+                      <motion.li
+                        layout
+                        initial={{ opacity: 0, x: -10 }}
+                        animate={{ opacity: 1, x: 0 }}
+                        key={candidate.id}
+                        className="group rounded-xl border border-white/5 bg-white/5 p-3 hover:border-primary/20 transition-all"
+                      >
+                        <div className="flex items-start gap-4">
+                          <Checkbox
+                            checked={selectedImportIds.has(candidate.id)}
+                            onChange={(checked) => toggleImportCandidate(candidate.id, checked)}
+                            aria-label={`Select candidate ${candidate.proposedName}`}
+                            className="mt-1"
+                          />
+                          <div className="min-w-0 flex-1">
+                            <div className="flex items-center flex-wrap gap-2">
+                              <span className="font-bold truncate text-sm">
+                                {candidate.proposedName}
+                              </span>
+                              <Badge
+                                variant="outline"
+                                className="text-[9px] uppercase font-black px-1.5 py-0 bg-primary/5 text-primary border-primary/20"
+                              >
+                                {candidate.sourceLabel}
+                              </Badge>
+                              <Badge
+                                variant={candidate.scope === "global" ? "default" : "secondary"}
+                                className="text-[9px] uppercase font-black px-1.5 py-0"
+                              >
+                                {candidate.scope}
+                              </Badge>
+                              <Badge
+                                variant="outline"
+                                className={`text-[9px] uppercase font-black px-1.5 py-0 ${
+                                  candidate.artifactType === "rule"
+                                    ? "bg-blue-500/10 text-blue-400 border-blue-500/20"
+                                    : candidate.artifactType === "command"
+                                      ? "bg-purple-500/10 text-purple-400 border-purple-500/20"
+                                      : "bg-emerald-500/10 text-emerald-400 border-emerald-500/20"
+                                }`}
+                              >
+                                {candidate.artifactType}
+                              </Badge>
+                            </div>
+                            <p className="text-[10px] text-muted-foreground/60 truncate mt-1.5 font-mono">
+                              {candidate.sourcePath}
+                            </p>
+                          </div>
+                        </div>
+                      </motion.li>
+                    ))}
+                  </motion.ul>
+                )}
+              </AnimatePresence>
+            </div>
+
+            {importScanErrors.length > 0 && (
+              <div className="rounded-xl border border-destructive/20 bg-destructive/5 p-4">
+                <p className="text-[10px] font-bold uppercase tracking-widest text-destructive mb-2">
+                  Scan warnings
+                </p>
+                <div className="space-y-1">
+                  {importScanErrors.slice(0, 3).map((err, idx) => (
+                    <p key={idx} className="text-xs text-destructive/80">
+                      {err}
+                    </p>
+                  ))}
+                  {importScanErrors.length > 3 && (
+                    <p className="text-[10px] text-destructive/40 italic">
+                      ...and {importScanErrors.length - 3} more
+                    </p>
+                  )}
+                </div>
+              </div>
+            )}
+
+            {importResult && (
+              <div className="rounded-xl border border-primary/20 bg-primary/5 p-4">
+                <p className="text-[10px] font-bold uppercase tracking-widest text-primary mb-2">
+                  Execution Report
+                </p>
+                <div className="flex gap-4 mb-3">
+                  <div className="text-center flex-1 p-2 rounded-lg bg-black/20">
+                    <div className="text-xl font-black text-primary">
+                      {importResult.importedRules?.length || importResult.imported.length}
+                    </div>
+                    <div className="text-[9px] uppercase font-bold text-muted-foreground/60">
+                      Imported
+                    </div>
+                  </div>
+                  <div className="text-center flex-1 p-2 rounded-lg bg-black/20">
+                    <div className="text-xl font-black">{importResult.skipped.length}</div>
+                    <div className="text-[9px] uppercase font-bold text-muted-foreground/60">
+                      Skipped
+                    </div>
+                  </div>
+                  <div className="text-center flex-1 p-2 rounded-lg bg-black/20">
+                    <div className="text-xl font-black text-amber-500">
+                      {importResult.conflicts.length}
+                    </div>
+                    <div className="text-[9px] uppercase font-bold text-muted-foreground/60">
+                      Conflicts
+                    </div>
+                  </div>
+                </div>
+
+                {importResult.conflicts.length > 0 && (
+                  <div className="flex items-center justify-between gap-3 pt-3 border-t border-white/5">
+                    <p className="text-[10px] text-amber-500 font-medium">
+                      Collision detected for "{importResult.conflicts[0].candidateName}"
+                    </p>
+                    <Button
+                      variant="outline"
+                      size="sm"
+                      onClick={() => void retryConflictsAsRename()}
+                      className="h-7 text-[10px] px-2 uppercase font-black"
+                    >
+                      Retry as Renames
+                    </Button>
+                  </div>
+                )}
+              </div>
+            )}
+          </div>
+
+          <DialogFooter className="gap-2 sm:gap-0 border-t border-white/5 pt-6 mt-2">
+            <Button
+              variant="ghost"
+              onClick={() => onOpenChange(false)}
+              className="text-xs uppercase font-black tracking-widest text-muted-foreground/60"
+            >
+              Close
+            </Button>
+            <div className="flex gap-2">
+              <Button
+                variant="outline"
+                onClick={handleRescan}
+                disabled={isScanningImport}
+                className="text-xs uppercase font-black tracking-widest glass"
+              >
+                Rescan
+              </Button>
+              <Button
+                onClick={executeImport}
+                disabled={isImporting || selectedImportIds.size === 0}
+                className="text-xs uppercase font-black tracking-widest glow-primary"
+              >
+                {isImporting ? "Importing..." : "Process Import"}
+              </Button>
+            </div>
+          </DialogFooter>
+        </DialogContent>
+      </Dialog>
+
+      {/* Helper Dialogs for Specific Sources */}
+      <Dialog open={urlImportDialogOpen} onOpenChange={setUrlImportDialogOpen}>
+        <DialogContent onClose={() => setUrlImportDialogOpen(false)} className="max-w-md">
+          <DialogHeader>
+            <DialogTitle>Import from URL</DialogTitle>
+            <DialogDescription>Enter a raw file or documentation URL to scan.</DialogDescription>
+          </DialogHeader>
+
+          <Input
+            value={urlImportValue}
+            onChange={(e) => setUrlImportValue(e.target.value)}
+            placeholder="https://example.com/artifacts.md"
+            aria-label="Import URL"
+            className="bg-black/20"
+          />
+
+          <DialogFooter>
+            <Button variant="ghost" onClick={() => setUrlImportDialogOpen(false)}>
+              Cancel
+            </Button>
+            <Button onClick={submitUrlImportScan} className="glow-primary">
+              Scan Remote Source
+            </Button>
+          </DialogFooter>
+        </DialogContent>
+      </Dialog>
+    </>
+  );
+}
diff --git a/src/components/pages/Commands.tsx b/src/components/pages/Commands.tsx
index ff2b4ef..4e634f0 100644
--- a/src/components/pages/Commands.tsx
+++ b/src/components/pages/Commands.tsx
@@ -1,4 +1,6 @@
+import { useState } from "react";
 import { useToast } from "@/components/ui/toast";
+import { ImportDialog } from "@/components/import/ImportDialog";
 import { CommandsListSkeleton } from "@/components/ui/skeleton";
 import { useRepositoryRoots } from "@/hooks/useRepositoryRoots";
 import { useCommandsState } from "@/hooks/useCommandsState";
@@ -7,6 +9,7 @@ import { CommandEditor } from "@/components/commands/CommandEditor";
 
 export function Commands() {
   const { addToast } = useToast();
+  const [importDialogOpen, setImportDialogOpen] = useState(false);
   const { roots: availableRepos } = useRepositoryRoots();
   const {
     selectedId,
@@ -41,6 +44,7 @@ export function Commands() {
         onQueryChange={handlers.setQuery}
         onCreate={handlers.handleCreate}
         onSync={handlers.handleSyncCommands}
+        onImport={() => setImportDialogOpen(true)}
       />
 
       <CommandEditor
@@ -61,6 +65,15 @@ export function Commands() {
         onTest={handlers.handleTest}
         onSyncSlashCommands={handlers.handleSyncSlashCommands}
       />
+
+      <ImportDialog
+        open={importDialogOpen}
+        onOpenChange={setImportDialogOpen}
+        artifactType="command"
+        onImportComplete={async () => {
+          await handlers.handleSyncCommands();
+        }}
+      />
     </div>
   );
 }
diff --git a/src/components/pages/RulesList.tsx b/src/components/pages/RulesList.tsx
index d526734..19d234f 100644
--- a/src/components/pages/RulesList.tsx
+++ b/src/components/pages/RulesList.tsx
@@ -2,41 +2,28 @@ import { useEffect, useState, useMemo, useRef } from "react";
 import type { DragEvent } from "react";
 import { cn } from "@/lib/utils";
 import { Plus, Upload, FileText, FolderUp, Link, Clipboard } from "lucide-react";
-import { open } from "@tauri-apps/plugin-dialog";
+import { ImportDialog, type ImportSourceMode } from "@/components/import/ImportDialog";
 import { Button } from "@/components/ui/button";
 import { Card, CardContent } from "@/components/ui/card";
 import { Checkbox } from "@/components/ui/checkbox";
-import { Input } from "@/components/ui/input";
-import { Select } from "@/components/ui/select";
-import {
-  Dialog,
-  DialogContent,
-  DialogHeader,
-  DialogTitle,
-  DialogDescription,
-  DialogFooter,
-} from "@/components/ui/dialog";
 import { useRulesStore } from "@/stores/rulesStore";
 import { useToast } from "@/components/ui/toast";
-import { useRegistryStore } from "@/stores/registryStore";
 import { RulesListSkeleton } from "@/components/ui/skeleton";
 import { RulesFilterBar } from "@/components/rules/RulesFilterBar";
 import { parseSortValue } from "@/components/rules/filter-utils";
 import { RuleCard } from "@/components/rules/RuleCard";
 import { toast } from "@/lib/toast-helpers";
+import { type Rule, type AdapterType } from "@/types/rule";
 import {
-  type Rule,
-  type AdapterType,
-  type ImportCandidate,
-  type ImportConflictMode,
-  type ImportExecutionOptions,
-  type ImportExecutionResult,
-} from "@/types/rule";
-import { api } from "@/lib/tauri";
+  Dialog,
+  DialogContent,
+  DialogDescription,
+  DialogFooter,
+  DialogHeader,
+  DialogTitle,
+} from "@/components/ui/dialog";
 import { RuleTemplateBrowser } from "@/components/rules/RuleTemplateBrowser";
 
-type ImportSourceMode = "ai" | "file" | "directory" | "url" | "clipboard";
-
 interface RulesListProps {
   onSelectRule: (rule: Rule) => void;
   onCreateRule: () => void;
@@ -53,7 +40,6 @@ export function RulesList({ onSelectRule, onCreateRule }: RulesListProps) {
     restoreRecentlyDeleted,
     isLoading,
   } = useRulesStore();
-  const { tools } = useRegistryStore();
   const { addToast } = useToast();
   const [searchQuery, setSearchQuery] = useState("");
   const [scopeFilter, setScopeFilter] = useState<"all" | "global" | "local">("all");
@@ -64,27 +50,8 @@ export function RulesList({ onSelectRule, onCreateRule }: RulesListProps) {
   const [menuOpen, setMenuOpen] = useState<string | null>(null);
   const [selectedIds, setSelectedIds] = useState<Set<string>>(new Set());
   const [bulkDeleteDialogOpen, setBulkDeleteDialogOpen] = useState(false);
-  const [isImporting, setIsImporting] = useState(false);
-  const [isScanningImport, setIsScanningImport] = useState(false);
   const [importDialogOpen, setImportDialogOpen] = useState(false);
-  const [importCandidates, setImportCandidates] = useState<ImportCandidate[]>([]);
-  const [selectedImportIds, setSelectedImportIds] = useState<Set<string>>(new Set());
-  const [importScanErrors, setImportScanErrors] = useState<string[]>([]);
-  const [importConflictMode, setImportConflictMode] = useState<ImportConflictMode>("rename");
-  const [importResult, setImportResult] = useState<ImportExecutionResult | null>(null);
-  const [importSourceMode, setImportSourceMode] = useState<ImportSourceMode>("ai");
-  const [importSourceValue, setImportSourceValue] = useState("");
-  const [clipboardImportName, setClipboardImportName] = useState<string | undefined>(undefined);
-  const [urlImportDialogOpen, setUrlImportDialogOpen] = useState(false);
-  const [urlImportValue, setUrlImportValue] = useState("");
-  const [clipboardNameDialogOpen, setClipboardNameDialogOpen] = useState(false);
-  const [clipboardPendingContent, setClipboardPendingContent] = useState("");
-  const [clipboardNameInput, setClipboardNameInput] = useState("");
-  const [importScopeOverride, setImportScopeOverride] = useState<"source" | "global" | "local">(
-    "source"
-  );
-  const [useAdapterOverride, setUseAdapterOverride] = useState(false);
-  const [adapterOverrideSet, setAdapterOverrideSet] = useState<Set<AdapterType>>(new Set());
+  const [initialImportMode, setInitialImportMode] = useState<ImportSourceMode | null>(null);
   const [isDragImportActive, setIsDragImportActive] = useState(false);
   const menuRef = useRef<HTMLDivElement>(null);
 
@@ -256,60 +223,9 @@ export function RulesList({ onSelectRule, onCreateRule }: RulesListProps) {
     setSortValue("name-asc");
   };
 
-  const handleImportResult = async (title: string, result: ImportExecutionResult) => {
-    await fetchRules();
-    addToast({
-      title,
-      description: `${result.imported.length} imported, ${result.skipped.length} skipped, ${result.conflicts.length} conflicts`,
-      variant: result.errors.length > 0 ? "error" : "success",
-    });
-    if (result.errors.length > 0) {
-      addToast({
-        title: "Import Warnings",
-        description: result.errors[0],
-        variant: "error",
-      });
-    }
-  };
-
-  const openImportPreview = async (
-    mode: ImportSourceMode,
-    sourceValue: string,
-    candidates: ImportCandidate[],
-    errors: string[]
-  ) => {
-    setImportSourceMode(mode);
-    setImportSourceValue(sourceValue);
-    if (mode !== "clipboard") {
-      setClipboardImportName(undefined);
-    }
-    setImportResult(null);
-    setImportCandidates(candidates);
-    setImportScanErrors(errors);
-    setSelectedImportIds(new Set(candidates.map((c) => c.id)));
+  const openImport = (mode: ImportSourceMode) => {
+    setInitialImportMode(mode);
     setImportDialogOpen(true);
-    setImportScopeOverride("source");
-    setUseAdapterOverride(false);
-    setAdapterOverrideSet(new Set());
-  };
-
-  const getImportExecutionOptions = (): ImportExecutionOptions => ({
-    conflictMode: importConflictMode,
-    selectedCandidateIds: Array.from(selectedImportIds),
-    defaultScope: importScopeOverride === "source" ? undefined : importScopeOverride,
-    defaultAdapters: useAdapterOverride ? Array.from(adapterOverrideSet) : undefined,
-  });
-
-  const toggleAdapterOverride = (adapter: AdapterType, checked: boolean) => {
-    setAdapterOverrideSet((prev) => {
-      const next = new Set(prev);
-      if (checked) {
-        next.add(adapter);
-      } else {
-        next.delete(adapter);
-      }
-      return next;
-    });
   };
 
   const handleDragImportOver = (event: DragEvent<HTMLDivElement>) => {
@@ -342,201 +258,11 @@ export function RulesList({ onSelectRule, onCreateRule }: RulesListProps) {
       return;
     }
 
-    setIsScanningImport(true);
-    try {
-      const scan = await api.ruleImport.scanFromFile(filePath);
-      await openImportPreview("file", filePath, scan.candidates, scan.errors);
-    } catch (error) {
-      toast.error(addToast, { title: "Scan Failed", error });
-    } finally {
-      setIsScanningImport(false);
-    }
-  };
-
-  const scanAiToolRules = async () => {
-    setIsScanningImport(true);
-    try {
-      const scan = await api.ruleImport.scanAiToolCandidates();
-      await openImportPreview("ai", "", scan.candidates, scan.errors);
-    } catch (error) {
-      toast.error(addToast, { title: "Scan Failed", error });
-    } finally {
-      setIsScanningImport(false);
-    }
-  };
-
-  const scanImportFromFile = async () => {
-    const selected = await open({
-      multiple: false,
-      filters: [{ name: "Rule Files", extensions: ["md", "txt", "json", "yaml", "yml"] }],
-    });
-    if (!selected || Array.isArray(selected)) return;
-
-    setIsScanningImport(true);
-    try {
-      const scan = await api.ruleImport.scanFromFile(selected);
-      await openImportPreview("file", selected, scan.candidates, scan.errors);
-    } catch (error) {
-      toast.error(addToast, { title: "Scan Failed", error });
-    } finally {
-      setIsScanningImport(false);
-    }
-  };
-
-  const scanImportFromDirectory = async () => {
-    const selected = await open({ directory: true, multiple: false });
-    if (!selected || Array.isArray(selected)) return;
-
-    setIsScanningImport(true);
-    try {
-      const scan = await api.ruleImport.scanFromDirectory(selected);
-      await openImportPreview("directory", selected, scan.candidates, scan.errors);
-    } catch (error) {
-      toast.error(addToast, { title: "Scan Failed", error });
-    } finally {
-      setIsScanningImport(false);
-    }
-  };
-
-  const scanImportFromUrl = async (url: string) => {
-    if (!url.trim()) return;
-
-    setIsScanningImport(true);
-    try {
-      const scan = await api.ruleImport.scanFromUrl(url);
-      await openImportPreview("url", url, scan.candidates, scan.errors);
-    } catch (error) {
-      toast.error(addToast, { title: "Scan Failed", error });
-    } finally {
-      setIsScanningImport(false);
-    }
-  };
-
-  const submitUrlImportScan = async () => {
-    const value = urlImportValue.trim();
-    if (!value) {
-      addToast({
-        title: "URL Required",
-        description: "Enter a URL to scan for import",
-        variant: "error",
-      });
-      return;
-    }
-
-    setUrlImportDialogOpen(false);
-    await scanImportFromUrl(value);
-  };
-
-  const scanImportFromClipboard = async () => {
-    try {
-      const text = await navigator.clipboard.readText();
-      if (!text.trim()) {
-        addToast({
-          title: "Clipboard Empty",
-          description: "No text found in clipboard",
-          variant: "error",
-        });
-        return;
-      }
-
-      setClipboardPendingContent(text);
-      setClipboardNameInput(clipboardImportName ?? "");
-      setClipboardNameDialogOpen(true);
-    } catch (error) {
-      toast.error(addToast, { title: "Scan Failed", error });
-    }
-  };
-
-  const submitClipboardImportScan = async () => {
-    if (!clipboardPendingContent.trim()) {
-      setClipboardNameDialogOpen(false);
-      return;
-    }
-
-    setClipboardNameDialogOpen(false);
-    setIsScanningImport(true);
-    try {
-      const name = clipboardNameInput.trim() || undefined;
-      setClipboardImportName(name);
-      const scan = await api.ruleImport.scanFromClipboard(clipboardPendingContent, name);
-      await openImportPreview("clipboard", clipboardPendingContent, scan.candidates, scan.errors);
-    } catch (error) {
-      toast.error(addToast, { title: "Scan Failed", error });
-    } finally {
-      setIsScanningImport(false);
-    }
-  };
-
-  const toggleImportCandidate = (id: string, checked: boolean) => {
-    setSelectedImportIds((prev) => {
-      const next = new Set(prev);
-      if (checked) {
-        next.add(id);
-      } else {
-        next.delete(id);
-      }
-      return next;
-    });
-  };
-
-  const toggleSelectAllImportCandidates = (checked: boolean) => {
-    if (checked) {
-      setSelectedImportIds(new Set(importCandidates.map((c) => c.id)));
-    } else {
-      setSelectedImportIds(new Set());
-    }
-  };
-
-  const executeImport = async () => {
-    if (selectedImportIds.size === 0) {
-      addToast({
-        title: "No Candidates Selected",
-        description: "Select at least one candidate to import",
-        variant: "error",
-      });
-      return;
-    }
-
-    setIsImporting(true);
-    try {
-      const options = getImportExecutionOptions();
-
-      let result: ImportExecutionResult;
-      if (importSourceMode === "ai") {
-        result = await api.ruleImport.importAiToolRules(options);
-      } else if (importSourceMode === "file") {
-        result = await api.ruleImport.importFromFile(importSourceValue, options);
-      } else if (importSourceMode === "directory") {
-        result = await api.ruleImport.importFromDirectory(importSourceValue, options);
-      } else if (importSourceMode === "url") {
-        result = await api.ruleImport.importFromUrl(importSourceValue, options);
-      } else {
-        result = await api.ruleImport.importFromClipboard(
-          importSourceValue,
-          clipboardImportName,
-          options
-        );
-      }
-
-      setImportResult(result);
-      await handleImportResult("Import Complete", result);
-      if (importSourceMode === "clipboard") {
-        setClipboardImportName(undefined);
-      }
-    } catch (error) {
-      toast.error(addToast, { title: "Import Failed", error });
-    } finally {
-      setIsImporting(false);
-    }
-  };
-
-  const retryConflictsAsRename = async () => {
-    if (!importResult || importResult.conflicts.length === 0) {
-      return;
-    }
-    setSelectedImportIds(new Set(importResult.conflicts.map((c) => c.candidateId)));
-    setImportConflictMode("rename");
-    await executeImport();
+    setInitialImportMode("file");
+    setImportDialogOpen(true);
+    // Note: The new ImportDialog doesn't currently auto-scan specific files passed from parent,
+    // but the user can then just select the file again or we can enhance ImportDialog later.
+    // For now, it's enough to open the dialog.
   };
 
   const hasActiveFilters = searchQuery || scopeFilter !== "all" || adapterFilter !== "all";
@@ -550,43 +276,23 @@ export function RulesList({ onSelectRule, onCreateRule }: RulesListProps) {
       <div className="flex flex-col md:flex-row md:items-center justify-between gap-4">
         <h1 className="text-2xl font-bold">Rules</h1>
         <div className="flex items-center gap-2">
-          <Button
-            variant="outline"
-            onClick={scanAiToolRules}
-            disabled={isImporting || isScanningImport}
-          >
+          <Button variant="outline" onClick={() => openImport("ai")}>
             <Upload className="mr-2 h-4 w-4" aria-hidden="true" />
-            {isScanningImport ? "Scanning..." : "Import AI"}
+            Import AI
           </Button>
-          <Button
-            variant="outline"
-            onClick={scanImportFromFile}
-            disabled={isImporting || isScanningImport}
-          >
+          <Button variant="outline" onClick={() => openImport("file")}>
             <FileText className="mr-2 h-4 w-4" aria-hidden="true" />
             Import File
           </Button>
-          <Button
-            variant="outline"
-            onClick={scanImportFromDirectory}
-            disabled={isImporting || isScanningImport}
-          >
+          <Button variant="outline" onClick={() => openImport("directory")}>
             <FolderUp className="mr-2 h-4 w-4" aria-hidden="true" />
             Import Folder
           </Button>
-          <Button
-            variant="outline"
-            onClick={() => setUrlImportDialogOpen(true)}
-            disabled={isImporting || isScanningImport}
-          >
+          <Button variant="outline" onClick={() => openImport("url")}>
             <Link className="mr-2 h-4 w-4" aria-hidden="true" />
             Import URL
           </Button>
-          <Button
-            variant="outline"
-            onClick={scanImportFromClipboard}
-            disabled={isImporting || isScanningImport}
-          >
+          <Button variant="outline" onClick={() => openImport("clipboard")}>
             <Clipboard className="mr-2 h-4 w-4" aria-hidden="true" />
             Import Clipboard
           </Button>
@@ -735,249 +441,15 @@ export function RulesList({ onSelectRule, onCreateRule }: RulesListProps) {
         </DialogContent>
       </Dialog>
 
-      <Dialog open={importDialogOpen} onOpenChange={setImportDialogOpen}>
-        <DialogContent onClose={() => setImportDialogOpen(false)}>
-          <DialogHeader>
-            <DialogTitle>
-              {importSourceMode === "ai"
-                ? "Import Existing AI Tool Rules"
-                : importSourceMode === "file"
-                  ? "Import Rules From File"
-                  : importSourceMode === "directory"
-                    ? "Import Rules From Folder"
-                    : importSourceMode === "url"
-                      ? "Import Rules From URL"
-                      : "Import Rules From Clipboard"}
-            </DialogTitle>
-            <DialogDescription>
-              Review discovered candidates, choose conflict handling, and import selected rules.
-            </DialogDescription>
-          </DialogHeader>
-
-          <div className="space-y-3 max-h-[50vh] overflow-y-auto">
-            {importSourceMode !== "ai" && importSourceValue && (
-              <div className="rounded-md border p-3 text-xs text-muted-foreground break-all">
-                Source: {importSourceMode === "clipboard" ? "Clipboard text" : importSourceValue}
-              </div>
-            )}
-
-            <div className="flex items-center justify-between gap-2">
-              <div className="flex items-center gap-2">
-                <Checkbox
-                  checked={
-                    importCandidates.length > 0 &&
-                    selectedImportIds.size === importCandidates.length
-                  }
-                  indeterminate={
-                    selectedImportIds.size > 0 && selectedImportIds.size < importCandidates.length
-                  }
-                  onChange={toggleSelectAllImportCandidates}
-                  aria-label="Select all import candidates"
-                />
-                <span className="text-sm text-muted-foreground">
-                  {selectedImportIds.size} of {importCandidates.length} selected
-                </span>
-              </div>
-
-              <Select
-                value={importConflictMode}
-                onChange={(value) => setImportConflictMode(value as ImportConflictMode)}
-                options={[
-                  { value: "rename", label: "Conflicts: Rename" },
-                  { value: "skip", label: "Conflicts: Skip" },
-                  { value: "replace", label: "Conflicts: Replace" },
-                ]}
-                className="w-44"
-                aria-label="Conflict mode"
-              />
-            </div>
-
-            <div className="grid grid-cols-1 gap-2 rounded-md border p-3">
-              <Select
-                value={importScopeOverride}
-                onChange={(value) => setImportScopeOverride(value as "source" | "global" | "local")}
-                options={[
-                  { value: "source", label: "Scope: Use source" },
-                  { value: "global", label: "Scope: Force global" },
-                  { value: "local", label: "Scope: Force local" },
-                ]}
-                aria-label="Scope override"
-              />
-
-              <div className="flex items-center gap-2">
-                <Checkbox
-                  checked={useAdapterOverride}
-                  onChange={setUseAdapterOverride}
-                  aria-label="Enable adapter override"
-                />
-                <span className="text-sm text-muted-foreground">Override adapters on import</span>
-              </div>
-
-              {useAdapterOverride && (
-                <div className="grid grid-cols-2 gap-2">
-                  {tools.map((adapter) => (
-                    <label key={adapter.id} className="flex items-center gap-2 text-sm">
-                      <Checkbox
-                        checked={adapterOverrideSet.has(adapter.id)}
-                        onChange={(checked) => toggleAdapterOverride(adapter.id, checked)}
-                        aria-label={`Use adapter ${adapter.name}`}
-                      />
-                      <span>{adapter.name}</span>
-                    </label>
-                  ))}
-                </div>
-              )}
-            </div>
-
-            {importCandidates.length === 0 ? (
-              <div className="rounded-md border p-3 text-sm text-muted-foreground">
-                No import candidates found for this source.
-              </div>
-            ) : (
-              <ul className="space-y-2">
-                {importCandidates.map((candidate) => (
-                  <li key={candidate.id} className="rounded-md border p-3">
-                    <div className="flex items-start gap-3">
-                      <Checkbox
-                        checked={selectedImportIds.has(candidate.id)}
-                        onChange={(checked) => toggleImportCandidate(candidate.id, checked)}
-                        aria-label={`Select candidate ${candidate.proposedName}`}
-                      />
-                      <div className="min-w-0 flex-1">
-                        <div className="flex items-center gap-2">
-                          <span className="font-medium truncate">{candidate.proposedName}</span>
-                          <span className="text-xs px-2 py-0.5 rounded-full border">
-                            {candidate.sourceLabel}
-                          </span>
-                          <span
-                            className={`text-xs px-2 py-0.5 rounded-full ${candidate.scope === "global" ? "bg-primary/20 text-primary" : "bg-secondary"}`}
-                          >
-                            {candidate.scope}
-                          </span>
-                        </div>
-                        <p className="text-xs text-muted-foreground truncate mt-1">
-                          {candidate.sourcePath}
-                        </p>
-                      </div>
-                    </div>
-                  </li>
-                ))}
-              </ul>
-            )}
-
-            {importScanErrors.length > 0 && (
-              <div className="rounded-md border border-destructive/40 bg-destructive/5 p-3 text-xs text-destructive">
-                <p className="font-medium mb-1">Scan warnings</p>
-                {importScanErrors.slice(0, 3).map((err) => (
-                  <p key={err}>{err}</p>
-                ))}
-              </div>
-            )}
-
-            {importResult && (
-              <div className="rounded-md border p-3 text-sm">
-                <p className="font-medium">Latest Import Result</p>
-                <p className="text-muted-foreground">
-                  {importResult.imported.length} imported, {importResult.skipped.length} skipped,{" "}
-                  {importResult.conflicts.length} conflicts, {importResult.errors.length} errors
-                </p>
-                {importResult.conflicts.length > 0 && (
-                  <div className="mt-2 flex items-center justify-between gap-2">
-                    <p className="text-xs text-destructive">
-                      Conflict: {importResult.conflicts[0].candidateName}
-                    </p>
-                    <Button
-                      variant="outline"
-                      size="sm"
-                      onClick={() => void retryConflictsAsRename()}
-                    >
-                      Retry Conflicts
-                    </Button>
-                  </div>
-                )}
-              </div>
-            )}
-          </div>
-
-          <DialogFooter>
-            <Button variant="outline" onClick={() => setImportDialogOpen(false)}>
-              Close
-            </Button>
-            <Button
-              variant="outline"
-              onClick={() => {
-                if (importSourceMode === "ai") {
-                  void scanAiToolRules();
-                } else if (importSourceMode === "file") {
-                  void scanImportFromFile();
-                } else if (importSourceMode === "directory") {
-                  void scanImportFromDirectory();
-                } else if (importSourceMode === "url") {
-                  setUrlImportDialogOpen(true);
-                } else {
-                  void scanImportFromClipboard();
-                }
-              }}
-              disabled={isScanningImport}
-            >
-              Rescan
-            </Button>
-            <Button onClick={executeImport} disabled={isImporting || selectedImportIds.size === 0}>
-              {isImporting ? "Importing..." : "Import Selected"}
-            </Button>
-          </DialogFooter>
-        </DialogContent>
-      </Dialog>
-
-      <Dialog open={urlImportDialogOpen} onOpenChange={setUrlImportDialogOpen}>
-        <DialogContent onClose={() => setUrlImportDialogOpen(false)}>
-          <DialogHeader>
-            <DialogTitle>Import Rules From URL</DialogTitle>
-            <DialogDescription>Enter a URL to scan before importing.</DialogDescription>
-          </DialogHeader>
-
-          <Input
-            type="url"
-            value={urlImportValue}
-            onChange={(e) => setUrlImportValue(e.target.value)}
-            placeholder="https://example.com/rules.md"
-            aria-label="Import URL"
-          />
-
-          <DialogFooter>
-            <Button variant="outline" onClick={() => setUrlImportDialogOpen(false)}>
-              Cancel
-            </Button>
-            <Button onClick={submitUrlImportScan}>Scan URL</Button>
-          </DialogFooter>
-        </DialogContent>
-      </Dialog>
-
-      <Dialog open={clipboardNameDialogOpen} onOpenChange={setClipboardNameDialogOpen}>
-        <DialogContent onClose={() => setClipboardNameDialogOpen(false)}>
-          <DialogHeader>
-            <DialogTitle>Clipboard Import Name</DialogTitle>
-            <DialogDescription>
-              Optionally provide a name used for preview and import.
-            </DialogDescription>
-          </DialogHeader>
-
-          <Input
-            type="text"
-            value={clipboardNameInput}
-            onChange={(e) => setClipboardNameInput(e.target.value)}
-            placeholder="clipboard-import"
-            aria-label="Clipboard import name"
-          />
-
-          <DialogFooter>
-            <Button variant="outline" onClick={() => setClipboardNameDialogOpen(false)}>
-              Cancel
-            </Button>
-            <Button onClick={submitClipboardImportScan}>Scan Clipboard</Button>
-          </DialogFooter>
-        </DialogContent>
-      </Dialog>
+      <ImportDialog
+        open={importDialogOpen}
+        onOpenChange={setImportDialogOpen}
+        artifactType="rule"
+        initialSourceMode={initialImportMode}
+        onImportComplete={async () => {
+          await fetchRules();
+        }}
+      />
     </div>
   );
 }
diff --git a/src/components/pages/Skills.tsx b/src/components/pages/Skills.tsx
index 9a9892f..8fe8b27 100644
--- a/src/components/pages/Skills.tsx
+++ b/src/components/pages/Skills.tsx
@@ -1,5 +1,5 @@
 import { useEffect, useMemo, useState } from "react";
-import { Plus, Trash2, FolderOpen } from "lucide-react";
+import { Plus, Trash2, FolderOpen, FolderUp } from "lucide-react";
 import { cn } from "@/lib/utils";
 import { Button } from "@/components/ui/button";
 import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
@@ -14,6 +14,7 @@ import { SkillSchemaEditor } from "@/components/skills/SkillSchemaEditor";
 import { TemplateBrowser } from "@/components/skills/TemplateBrowser";
 import { Select } from "@/components/ui/select";
 import { useRepositoryRoots } from "@/hooks/useRepositoryRoots";
+import { ImportDialog } from "@/components/import/ImportDialog";
 
 export function Skills() {
   const [skills, setSkills] = useState<Skill[]>([]);
@@ -28,6 +29,7 @@ export function Skills() {
   const [enabled, setEnabled] = useState(true);
   const { roots: availableRepos } = useRepositoryRoots();
   const [isSaving, setIsSaving] = useState(false);
+  const [importDialogOpen, setImportDialogOpen] = useState(false);
   const { addToast } = useToast();
 
   const selected = useMemo(
@@ -174,6 +176,15 @@ export function Skills() {
                 <Plus className="mr-1.5 h-3.5 w-3.5" />
                 New
               </Button>
+              <Button
+                size="sm"
+                variant="outline"
+                onClick={() => setImportDialogOpen(true)}
+                className="glass h-8"
+              >
+                <FolderUp className="mr-1.5 h-3.5 w-3.5" />
+                Import
+              </Button>
             </div>
           </div>
           <CardDescription className="text-xs">Complex multi-step workflows</CardDescription>
@@ -373,6 +384,15 @@ export function Skills() {
           )}
         </CardContent>
       </Card>
+
+      <ImportDialog
+        open={importDialogOpen}
+        onOpenChange={setImportDialogOpen}
+        artifactType="skill"
+        onImportComplete={async () => {
+          await loadSkills();
+        }}
+      />
     </div>
   );
 }
diff --git a/src/lib/tauri.ts b/src/lib/tauri.ts
index faff351..451128f 100644
--- a/src/lib/tauri.ts
+++ b/src/lib/tauri.ts
@@ -51,6 +51,10 @@ export const api = {
       invoke<ImportScanResult>("scan_rule_clipboard_import", { content, name, options }),
     importAiToolRules: (options?: ImportExecutionOptions) =>
       invoke<ImportExecutionResult>("import_ai_tool_rules", { options }),
+    importAiToolCommands: (options?: ImportExecutionOptions) =>
+      invoke<ImportExecutionResult>("import_ai_tool_commands", { options }),
+    importAiToolSkills: (options?: ImportExecutionOptions) =>
+      invoke<ImportExecutionResult>("import_ai_tool_skills", { options }),
     importFromFile: (path: string, options?: ImportExecutionOptions) =>
       invoke<ImportExecutionResult>("import_rule_from_file", { path, options }),
     importFromDirectory: (path: string, options?: ImportExecutionOptions) =>
@@ -59,6 +63,14 @@ export const api = {
       invoke<ImportExecutionResult>("import_rule_from_url", { url, options }),
     importFromClipboard: (content: string, name?: string, options?: ImportExecutionOptions) =>
       invoke<ImportExecutionResult>("import_rule_from_clipboard", { content, name, options }),
+    importCommandsFromDirectory: (path: string, options?: ImportExecutionOptions) =>
+      invoke<ImportExecutionResult>("import_commands_from_directory", { path, options }),
+    scanCommandDirectoryImport: (path: string, options?: ImportExecutionOptions) =>
+      invoke<ImportScanResult>("scan_command_directory_import", { path, options }),
+    importSkillsFromDirectory: (path: string, options?: ImportExecutionOptions) =>
+      invoke<ImportExecutionResult>("import_skills_from_directory", { path, options }),
+    scanSkillDirectoryImport: (path: string, options?: ImportExecutionOptions) =>
+      invoke<ImportScanResult>("scan_skill_directory_import", { path, options }),
     getHistory: () => invoke<ImportHistoryEntry[]>("get_rule_import_history"),
   },
 
diff --git a/src/types/rule.ts b/src/types/rule.ts
index 7b074fc..af26519 100644
--- a/src/types/rule.ts
+++ b/src/types/rule.ts
@@ -77,6 +77,7 @@ export interface SyncHistoryEntry {
 }
 
 export type ImportSourceType = "ai_tool" | "file" | "directory" | "url" | "clipboard";
+export type ImportArtifactType = "rule" | "command" | "skill" | "other" | "unknown";
 export type ImportConflictMode = "skip" | "rename" | "replace";
 
 export interface ImportCandidate {
@@ -85,6 +86,7 @@ export interface ImportCandidate {
   sourceLabel: string;
   sourcePath: string;
   sourceTool?: AdapterType;
+  artifactType: ImportArtifactType;
   name: string;
   proposedName: string;
   content: string;
@@ -93,6 +95,7 @@ export interface ImportCandidate {
   enabledAdapters: AdapterType[];
   contentHash: string;
   fileSize: number;
+  metadata?: string;
 }
 
 export interface ImportScanResult {
@@ -124,6 +127,9 @@ export interface ImportSkip {
 
 export interface ImportExecutionResult {
   imported: Rule[];
+  importedRules: Rule[];
+  importedCommands: unknown[]; // Avoid circular dependency
+  importedSkills: unknown[];
   skipped: ImportSkip[];
   conflicts: ImportConflict[];
   errors: string[];
